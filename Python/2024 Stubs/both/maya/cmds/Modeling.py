from typing import Union, Optional, List, Tuple, Any

def addMetadata(*args, channelName: Optional[Union[str, bool]] = ..., cn: Optional[Union[str, bool]] = ..., channelType: Optional[Union[str, bool]] = ..., cht: Optional[Union[str, bool]] = ..., indexType: Optional[Union[str, bool]] = ..., idt: Optional[Union[str, bool]] = ..., scene: bool = ..., scn: bool = ..., streamName: Optional[Union[str, bool]] = ..., stn: Optional[Union[str, bool]] = ..., structure: Optional[Union[str, bool]] = ..., str: Optional[Union[str, bool]] = ..., query: bool = ...) -> Any:
    r"""
    Defines the attachment of a metadata structure to one or more selected
    objects. This creates a placeholder with an empty metadata Stream for
    later population through the editMetadata command. It's similar
    in concept to the addAttr command for nodes - a data description
    is added but no data is actually set.
    
    
    When assigning a metadata structure you must specify these flags
    - channelName is the metadata channel type (e.g. "vertex"),
    streamName is the name of the metadata stream to be created,
    and structure is the name of the structure type defining the
    contents of the metadata. The indexType flag is optional.
    If it is not present then the index will be presumed to be a standard
    numerical value.
    
    
    You can query metadata information at a variety of levels. See the
    table below for a full list of the queryable arguments. In each case
    the specification of any of the non-queried arguments filters the list
    of metadata to be examined during the query. For all queries a single
    object must be selected for querying.
    
    
    For example querying the channelName flag with no other
    arguments will return the list of all Channel types on the selected
    object that contain any metadata. Querying the channelName flag
    with the indexType flag specified will return only those
    channel types containing metadata streams that use that particular
    type of index.
    
    
    Query the channelName flag to return the list of any channel types
    that have metadata.
    Specify the channelName and streamName flags and query the
    structure flag to return the name of the structure assigned to the
    given stream (if any).
    Specify a channelName and query the streamName to return
    the list of all streams assigned to that particular channel type.
    If you query the streamName without a specific channelName
    then it returns a list of pairs of (channelName, streamName) for all metadata
    streams.
    
    
    Flag Combinations:
    
    ChannelName IndexType StreamName Structure   Create   Can Query
         0          0          0         0         X        ChannelName, StreamName, Structure
         0          0          0         1         X        ChannelName, StreamName, IndexType
         0          0          1         0         X        ChannelName, Structure, IndexType
         0          0          1         1         X        ChannelName, IndexType
         0          1          0         0         X        ChannelName, StreamName, Structure
         0          1          0         1         X        ChannelName, StreamName
         0          1          1         0         X        ChannelName, Structure
         0          1          1         1         X        ChannelName
         1          0          0         0         X        StreamName, Structure, IndexType
         1          0          0         1         X        StreamName, IndexType
         1          0          1         0         X        Structure, IndexType
         1          0          1         1        (a)       IndexType
         1          1          0         0         X        StreamName, Structure
         1          1          0         1         X        StreamName
         1          1          1         0         X        Structure
         1          1          1         1        (b)       X
        (a) Assign an empty metadata stream with default index type
        (b) Assign an empty metadata stream with the named index type

    Args:
        channelName | cn: (create, query) - Name of the Channel type to which the structure is to be added (e.g. "vertex"). 			In query mode, this flag can accept a value.
        channelType | cht: (create, query) - Obsolete - use the 'channelName' flag instead. 			In query mode, this flag can accept a value.
        indexType | idt: (create, query) - Name of the index type the new Channel should be using. If not specified this defaults to a simple numeric index. Of the native types only a mesh "vertexFace" channel is different, using a "pair" index type. 			In query mode, this flag can accept a value.
        scene | scn: (create, query) - Use this flag when you want to add metadata to the scene as a whole rather than to any individual nodes. If you use this flag and have nodes selected the nodes will be ignored and a warning will be displayed.
        streamName | stn: (create, query) - Name of the empty stream being created. In query mode not specifying a value will return a list of streams on the named channel type. 			In query mode, this flag can accept a value.
        structure | str: (create, query) - Name of the structure which defines the metadata to be attached to the object. In query mode this will return the name of the structure attached at a given stream. 			In query mode, this flag can accept a value.
    """
    ...


def alignCurve(*args, caching: bool = ..., cch: bool = ..., curvatureContinuity: bool = ..., cc: bool = ..., curvatureScale1: Optional[Union[float, bool]] = ..., cs1: Optional[Union[float, bool]] = ..., curvatureScale2: Optional[Union[float, bool]] = ..., cs2: Optional[Union[float, bool]] = ..., joinParameter: Optional[Union[float, bool]] = ..., jnp: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., positionalContinuity: bool = ..., pc: bool = ..., positionalContinuityType: Optional[Union[int, bool]] = ..., pct: Optional[Union[int, bool]] = ..., reverse1: bool = ..., rv1: bool = ..., reverse2: bool = ..., rv2: bool = ..., tangentContinuity: bool = ..., tc: bool = ..., tangentContinuityType: Optional[Union[int, bool]] = ..., tct: Optional[Union[int, bool]] = ..., tangentScale1: Optional[Union[float, bool]] = ..., ts1: Optional[Union[float, bool]] = ..., tangentScale2: Optional[Union[float, bool]] = ..., ts2: Optional[Union[float, bool]] = ..., attach: bool = ..., at: bool = ..., constructionHistory: bool = ..., ch: bool = ..., keepMultipleKnots: bool = ..., kmk: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The curve align command is used to align curves in maya. The main
    alignment options are positional, tangent and curvature continuity.
    Curvature continuity implies tangent continuity.
    
    Positional continuity means the curves (move) or the ends of the
    curves (modify) are changed.
    
    Tangent continuity means one of the curves is modified to be tangent
    at the points where they meet.
    
    Curvature continuity means one of the curves is modified to be
    curvature continuous as well as tangent.
    
    The default behaviour, when no curves or flags are passed, is to only
    do positional and tangent continuity on the active list with the end
    of the first curve and the start of the other curve used for alignment.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        curvatureContinuity | cc: (create, edit, query) - Curvature continuity is on if true and off otherwise. Default: false
        curvatureScale1 | cs1: (create, edit, query) - Curvature scale applied to curvature of first curve for curvature continuity. Default: 0.0
        curvatureScale2 | cs2: (create, edit, query) - Curvature scale applied to curvature of second curve for curvature continuity. Default: 0.0
        joinParameter | jnp: (create, edit, query) - Parameter on reference curve where modified curve is to be aligned to. Default: 123456.0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        positionalContinuity | pc: (create, edit, query) - Positional continuity is on if true and off otherwise. Default: true
        positionalContinuityType | pct: (create, edit, query) - Positional continuity type legal values: 1 - move first curve, 2 - move second curve, 3 - move both curves, 4 - modify first curve, 5 - modify second curve, 6 - modify both curves Default: 1
        reverse1 | rv1: (create, edit, query) - If true, reverse the first input curve before doing align. Otherwise, do nothing to the first input curve before aligning. NOTE: setting this attribute to random values will cause unpredictable results and is not supported. Default: false
        reverse2 | rv2: (create, edit, query) - If true, reverse the second input curve before doing align. Otherwise, do nothing to the second input curve before aligning. NOTE: setting this attribute to random values will cause unpredictable results and is not supported. Default: false
        tangentContinuity | tc: (create, edit, query) - Tangent continuity is on if true and off otherwise. Default: true
        tangentContinuityType | tct: (create, edit, query) - Tangent continuity type legal values: 1 - do tangent continuity on first curve, 2 - do tangent continuity on second curve Default: 1
        tangentScale1 | ts1: (create, edit, query) - Tangent scale applied to tangent of first curve for tangent continuity. Default: 1.0
        tangentScale2 | ts2: (create, edit, query) - Tangent scale applied to tangent of second curve for tangent continuity. Default: 1.0
        attach | at: (create) - True if the curve is to be attached
        constructionHistory | ch: (create) - Turn the construction history on or off.
        keepMultipleKnots | kmk: (create) - True if multiple knots should be left as-is.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def alignSurface(*args, caching: bool = ..., cch: bool = ..., curvatureContinuity: bool = ..., cc: bool = ..., curvatureScale1: Optional[Union[float, bool]] = ..., cs1: Optional[Union[float, bool]] = ..., curvatureScale2: Optional[Union[float, bool]] = ..., cs2: Optional[Union[float, bool]] = ..., directionU: bool = ..., du: bool = ..., joinParameter: Optional[Union[float, bool]] = ..., jnp: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., positionalContinuity: bool = ..., pc: bool = ..., positionalContinuityType: Optional[Union[int, bool]] = ..., pct: Optional[Union[int, bool]] = ..., reverse1: bool = ..., rv1: bool = ..., reverse2: bool = ..., rv2: bool = ..., swap1: bool = ..., sw1: bool = ..., swap2: bool = ..., sw2: bool = ..., tangentContinuity: bool = ..., tc: bool = ..., tangentContinuityType: Optional[Union[int, bool]] = ..., tct: Optional[Union[int, bool]] = ..., tangentScale1: Optional[Union[float, bool]] = ..., ts1: Optional[Union[float, bool]] = ..., tangentScale2: Optional[Union[float, bool]] = ..., ts2: Optional[Union[float, bool]] = ..., twist: bool = ..., tw: bool = ..., attach: bool = ..., at: bool = ..., constructionHistory: bool = ..., ch: bool = ..., keepMultipleKnots: bool = ..., kmk: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The surface align command is used to align surfaces in maya. The main
    alignment options are positional, tangent and curvature continuity.
    Curvature continuity implies tangent continuity.
    
    NOTE: this tool is based on Studio's align tool.
    
    Positional continuity means the surfaces (move) or the ends of the
    surfaces (modify) are changed.
    
    Tangent continuity means one of the surfaces is modified to be tangent
    at the points where they meet.
    
    Curvature continuity means one of the surfaces is modified to be
    curvature continuous as well as tangent.
    
    The default behaviour, when no surfaces or flags are passed, is to only
    do positional and tangent continuity on the active list with the end
    of the first surface and the start of the other surface used for
    alignment.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        curvatureContinuity | cc: (create, edit, query) - Curvature continuity is on if true and off otherwise. Default: false
        curvatureScale1 | cs1: (create, edit, query) - Curvature scale applied to curvature of first surface for curvature continuity. Default: 0.0
        curvatureScale2 | cs2: (create, edit, query) - Curvature scale applied to curvature of second surface for curvature continuity. Default: 0.0
        directionU | du: (create, edit, query) - If true use U direction of surface and V direction otherwise. Default: true
        joinParameter | jnp: (create, edit, query) - Parameter on reference surface where modified surface is to be aligned to. Default: 123456.0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        positionalContinuity | pc: (create, edit, query) - Positional continuity is on if true and off otherwise. Default: true
        positionalContinuityType | pct: (create, edit, query) - Positional continuity type legal values: 1 - move first surface, 2 - move second surface, 3 - move both surfaces, 4 - modify first surface, 5 - modify second surface, 6 - modify both surfaces Default: 1
        reverse1 | rv1: (create, edit, query) - If true, reverse the direction (specified by directionU) of the first input surface before doing align. Otherwise, do nothing to the first input surface before aligning. NOTE: setting this attribute to random values will cause unpredictable results and is not supported. Default: false
        reverse2 | rv2: (create, edit, query) - If true, reverse the direction (specified by directionU) of the second input surface before doing align. Otherwise, do nothing to the second input surface before aligning. NOTE: setting this attribute to random values will cause unpredictable results and is not supported. Default: false
        swap1 | sw1: (create, edit, query) - If true, swap the UV directions of the first input surface before doing align. Otherwise, do nothing to the first input surface before aligning. NOTE: setting this attribute to random values will cause unpredictable results and is not supported. Default: false
        swap2 | sw2: (create, edit, query) - If true, swap the UV directions of the second input surface before doing align. Otherwise, do nothing to the second input surface before aligning. NOTE: setting this attribute to random values will cause unpredictable results and is not supported. Default: false
        tangentContinuity | tc: (create, edit, query) - Tangent continuity is on if true and off otherwise. Default: true
        tangentContinuityType | tct: (create, edit, query) - Tangent continuity type legal values: 1 - do tangent continuity on first surface, 2 - do tangent continuity on second surface Default: 1
        tangentScale1 | ts1: (create, edit, query) - Tangent scale applied to tangent of first surface for tangent continuity. Default: 1.0
        tangentScale2 | ts2: (create, edit, query) - Tangent scale applied to tangent of second surface for tangent continuity. Default: 1.0
        twist | tw: (create, edit, query) - If true, reverse the second surface in the opposite direction (specified by directionU) before doing align. This will avoid twists in the aligned surfaces. Otherwise, do nothing to the second input surface before aligning. NOTE: setting this attribute to random values will cause unpredictable results and is not supported. Default: false
        attach | at: (create) - Should surfaces be attached after alignment?
        constructionHistory | ch: (create) - Turn the construction history on or off.
        keepMultipleKnots | kmk: (create) - Should multiple knots be kept?
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def angleBetween(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., euler: bool = ..., er: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., vector1: Optional[Union[Tuple[float, float, float], bool]] = ..., v1: Optional[Union[Tuple[float, float, float], bool]] = ..., vector1X: Optional[Union[float, bool]] = ..., v1x: Optional[Union[float, bool]] = ..., vector1Y: Optional[Union[float, bool]] = ..., v1y: Optional[Union[float, bool]] = ..., vector1Z: Optional[Union[float, bool]] = ..., v1z: Optional[Union[float, bool]] = ..., vector2: Optional[Union[Tuple[float, float, float], bool]] = ..., v2: Optional[Union[Tuple[float, float, float], bool]] = ..., vector2X: Optional[Union[float, bool]] = ..., v2x: Optional[Union[float, bool]] = ..., vector2Y: Optional[Union[float, bool]] = ..., v2y: Optional[Union[float, bool]] = ..., vector2Z: Optional[Union[float, bool]] = ..., v2z: Optional[Union[float, bool]] = ...) -> Any:
    r"""
    Returns the axis and angle required to rotate one vector onto another.
    If the construction history (ch) flag is ON, then the name of
    the new dependency node is returned.

    Args:
        caching | cch: (create) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create) - Turn the construction history on or off.
        euler | er: (create) - return the rotation as 3 Euler angles instead of axis + angle
        nodeState | nds: (create) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        vector1 | v1: (create) - vector from which to compute the rotation
        vector1X | v1x: (create) - X coordinate of the vector from which to compute the rotation
        vector1Y | v1y: (create) - Y coordinate of the vector from which to compute the rotation
        vector1Z | v1z: (create) - Z coordinate of the vector from which to compute the rotation
        vector2 | v2: (create) - vector to which to compute the rotation
        vector2X | v2x: (create) - X coordinate of the vector to which to compute the rotation
        vector2Y | v2y: (create) - Y coordinate of the vector to which to compute the rotation
        vector2Z | v2z: (create) - Z coordinate of the vector to which to compute the rotation
    """
    ...


def applyMetadata(*args, format: Optional[Union[str, bool]] = ..., fmt: Optional[Union[str, bool]] = ..., scene: bool = ..., scn: bool = ..., value: Optional[Union[str, bool]] = ..., v: Optional[Union[str, bool]] = ...) -> Any:
    r"""
    Define the values of a particular set of metadata on selected objects.
    This command is used in preservation of metadata through Maya file formats
    (.ma/.mb). If any metadata already exists it will be kept and merged with
    the new metadata, overwriting duplicate entries. (i.e. if this command
    specifies data at index N and you already have a value at index N then
    the one this command specifies will be the new value and the old one
    will cease to exist.)
    
    
    Unlike the editMetadata command it is not necessary to first use
    the addMetadata command or API equivalent to attach a metadata
    stream to the object, this command will do both assignment of structure
    and of metadata values. You do have to use the dataStructure
    command or API equivalent to create the structure being assigned first
    though.
    
    
    The formatted input will be in a form expected by the data
    associations serializer (see adsk::Data::AssociationsSerializer for
    more information). The specific serialization type will be the default
    'raw' if the format flag is not used.
    
    
    For example the "raw" format input string
    "channel face\n[STREAMDATA]\nendChannels\nendAssociations"
    with no flags is equivalent to the input "[STREAMDATA]\nendChannels" with
    the channel flag set to 'face'

    Args:
        format | fmt: (create) - Name of the data association format type to use in the value flag parsing. Default value is "raw".
        scene | scn: (create) - Use this flag when you want to apply metadata to the scene as a whole rather than to any individual nodes. If you use this flag and have nodes selected the nodes will be ignored and a warning will be displayed. Scene metadata is incompatible with referenced scenes. Node associated metadata from referenced files will still be readable from master scenes but scene specific metadata of referenced files will not be accessible from a any master scene. This will ensure that referenced files metadata will not end up corrupting the master file scene-metadata.
        value | v: (create) - String containing all of the metadata to be assigned to the selected object.
    """
    ...


def arclen(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command returns the arclength of a curve if the history
    flag is not set (the default).  If the history flag is set, a node
    is created that can produce the arclength, and is connected and
    its name returned.  Having the construction history option on
    makes this command useful for expressions.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create) - Turn the construction history on or off.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def arcLengthDimension(*args) -> Any:
    r"""
    This command is used to create an arcLength dimension to display the
    arcLength of a curve/surface at a specified point on the curve/surface.

    Args:
    """
    ...


def arubaNurbsToPoly(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., localSpace: bool = ..., ls: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command tesselates a NURBS surface and produces a polygonal surface.
    The name of the new polygonal surface is returned.
    If construction history is ON, then the name of the new dependency
    node is returned as well.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create) - Turn the construction history on or off.
        localSpace | ls: (create) - Tesselate in local space
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        object | o: (create) - Create the result, or just the dependency node.
        worldSpace | ws: (create) - Tesselate in world space
    """
    ...


def attachCurve(*args, blendBias: Optional[Union[float, bool]] = ..., bb: Optional[Union[float, bool]] = ..., blendKnotInsertion: bool = ..., bki: bool = ..., caching: bool = ..., cch: bool = ..., keepMultipleKnots: bool = ..., kmk: bool = ..., method: Optional[Union[int, bool]] = ..., m: Optional[Union[int, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., parameter: Optional[Union[float, bool]] = ..., p: Optional[Union[float, bool]] = ..., reverse1: bool = ..., rv1: bool = ..., reverse2: bool = ..., rv2: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This attach command is used to attach curves. Once the curves are
    attached, there will be multiple knots at the joined point(s). These
    can be kept or removed if the user wishes.
    
    If there are two curves, the end of the first curve is attached to the
    start of the second curve. If there are more than two curves, closest
    endpoints are joined.
    
    Note: if the command is done with Keep Original off, the first curve
    is replaced by the attached curve. All other curves will remain, the
    command does not delete them.

    Args:
        blendBias | bb: (create, edit, query) - Skew the result toward the first or the second curve depending on the blend factory being smaller or larger than 0.5. Default: 0.5
        blendKnotInsertion | bki: (create, edit, query) - If set to true, insert a knot in one of the original curves (relative position given by the parameter attribute below) in order to produce a slightly different effect. Default: false
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        keepMultipleKnots | kmk: (create, edit, query) - If true, keep multiple knots at the join parameter. Otherwise remove them. Default: true
        method | m: (create, edit, query) - Attach method (connect-0, blend-1) Default: 0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        parameter | p: (create, edit, query) - The parameter value for the positioning of the newly inserted knot. Default: 0.1
        reverse1 | rv1: (create, edit, query) - If true, reverse the first input curve before doing attach. Otherwise, do nothing to the first input curve before attaching. NOTE: setting this attribute to random values will cause unpredictable results and is not supported. Default: false
        reverse2 | rv2: (create, edit, query) - If true, reverse the second input curve before doing attach. Otherwise, do nothing to the second input curve before attaching. NOTE: setting this attribute to random values will cause unpredictable results and is not supported. Default: false
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def attachSurface(*args, blendBias: Optional[Union[float, bool]] = ..., bb: Optional[Union[float, bool]] = ..., blendKnotInsertion: bool = ..., bki: bool = ..., caching: bool = ..., cch: bool = ..., directionU: bool = ..., du: bool = ..., keepMultipleKnots: bool = ..., kmk: bool = ..., method: Optional[Union[int, bool]] = ..., m: Optional[Union[int, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., parameter: Optional[Union[float, bool]] = ..., p: Optional[Union[float, bool]] = ..., reverse1: bool = ..., rv1: bool = ..., reverse2: bool = ..., rv2: bool = ..., swap1: bool = ..., sw1: bool = ..., swap2: bool = ..., sw2: bool = ..., twist: bool = ..., tw: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This attach command is used to attach surfaces. Once the surfaces are
    attached, there will be multiple knots at the joined point(s). These
    can be kept or removed if the user wishes.
    
    The end of the first surface is attached to the start of the second
    surface in the specified direction.
    
    Note: if the command is done with Keep Original off there will be an
    extra surface in the model (the second surface). The command does not
    delete it. The first surface is replaced by the attached surface.

    Args:
        blendBias | bb: (create, edit, query) - Skew the result toward the first or the second curve depending on the blend factory being smaller or larger than 0.5. Default: 0.5
        blendKnotInsertion | bki: (create, edit, query) - If set to true, insert a knot in one of the original curves (relative position given by the parameter attribute below) in order to produce a slightly different effect. Default: false
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        directionU | du: (create, edit, query) - If true attach in U direction of surface and V direction otherwise. Default: true
        keepMultipleKnots | kmk: (create, edit, query) - If true, keep multiple knots at the join parameter. Otherwise remove them. Default: true
        method | m: (create, edit, query) - Attach method (connect-0, blend-1) Default: 0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        parameter | p: (create, edit, query) - The parameter value for the positioning of the newly inserted knot. Default: 0.1
        reverse1 | rv1: (create, edit, query) - If true, reverse the direction (specified by directionU) of the first input surface before doing attach. Otherwise, do nothing to the first input surface before attaching. NOTE: setting this attribute to random values will cause unpredictable results and is not supported. Default: false
        reverse2 | rv2: (create, edit, query) - If true, reverse the direction (specified by directionU) of the second input surface before doing attach. Otherwise, do nothing to the second input surface before attaching. NOTE: setting this attribute to random values will cause unpredictable results and is not supported. Default: false
        swap1 | sw1: (create, edit, query) - If true, swap the UV directions of the first input surface before doing attach. Otherwise, do nothing to the first input surface before attaching. NOTE: setting this attribute to random values will cause unpredictable results and is not supported. Default: false
        swap2 | sw2: (create, edit, query) - If true, swap the UV directions of the second input surface before doing attach. Otherwise, do nothing to the second input surface before attaching. NOTE: setting this attribute to random values will cause unpredictable results and is not supported. Default: false
        twist | tw: (create, edit, query) - If true, reverse the second surface in the opposite direction (specified by directionU) before doing attach. This will avoid twists in the attached surfaces. Otherwise, do nothing to the second input surface before attaching. NOTE: setting this attribute to random values will cause unpredictable results and is not supported. Default: false
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def bevel(*args, bevelShapeType: Optional[Union[int, bool]] = ..., bst: Optional[Union[int, bool]] = ..., caching: bool = ..., cch: bool = ..., cornerType: Optional[Union[int, bool]] = ..., ct: Optional[Union[int, bool]] = ..., depth: Optional[Union[float, bool]] = ..., d: Optional[Union[float, bool]] = ..., extrudeDepth: Optional[Union[float, bool]] = ..., ed: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., width: Optional[Union[float, bool]] = ..., w: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., joinSurfaces: bool = ..., js: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., numberOfSides: Optional[Union[int, bool]] = ..., ns: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., range: bool = ..., rn: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The bevel command creates a new bevel surface for the specified curve.
    The curve can be any nurbs curves.

    Args:
        bevelShapeType | bst: (create, edit, query) - Shape type: 1 - straight cut, 2 - curve out, 3 - curve in Default: 1
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        cornerType | ct: (create, edit, query) - Corner type: 1 - linear, 2 - circular Default: 2
        depth | d: (create, edit, query) - The depth for bevel Default: 0.5
        extrudeDepth | ed: (create, edit, query) - The extrude depth for bevel Default: 1.0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        tolerance | tol: (create, edit, query) - The tolerance for bevel offsets Default: 0.01
        width | w: (create, edit, query) - The width for bevel Default: 0.5
        constructionHistory | ch: (create) - Turn the construction history on or off.
        joinSurfaces | js: (create, edit, query) - Attach bevelled surfaces into one surface for each input curve. Default:true
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        numberOfSides | ns: (create, edit, query) - How to apply the bevel.  1 - no bevels 2 - bevel at start only 3 - bevel at end only 4 - bevel at start and end  Default: 4
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
        range | rn: (create) - Force a curve range on complete input curve.
    """
    ...


def bevelPlus(*args, bevelInside: bool = ..., bin: bool = ..., capSides: Optional[Union[int, bool]] = ..., cap: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., innerStyle: Optional[Union[int, bool]] = ..., joinSurfaces: bool = ..., js: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., normalsOutwards: bool = ..., no: bool = ..., numberOfSides: Optional[Union[int, bool]] = ..., ns: Optional[Union[int, bool]] = ..., outerStyle: Optional[Union[int, bool]] = ..., os: Optional[Union[int, bool]] = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., range: bool = ..., rn: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The bevelPlus command creates a new bevel surface for the specified
    curves using a given style curve. The first curve should be the
    "outside" curve, and the (optional) rest of them should be inside of
    the first one. For predictable results, the curves should be planar
    and all in the same plane.

    Args:
        bevelInside | bin: (create, edit, query) - If true, ensure surface always remains within the original profile curve Default: false
        capSides | cap: (create, query) - How to cap the bevel.  1 - no caps 2 - cap at start only 3 - cap at end only 4 - cap at start and end  Default:4
        constructionHistory | ch: (create) - Turn the construction history on or off.
        innerStyle | innerStyle: (create, edit, query) - Similar to outerStyle, this style is applied to all but the first (outer) curve specified.
        joinSurfaces | js: (create, edit, query) - Attach bevelled surfaces into one surface for each input curve. Default:true
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        normalsOutwards | no: (create, edit, query) - If enabled, the normals point outwards on the resulting NURBS or poly surface.
        numberOfSides | ns: (create, edit, query) - How to apply the bevel.  1 - no bevels 2 - bevel at start only 3 - bevel at end only 4 - bevel at start and end  Default: 4
        outerStyle | os: (create, edit, query) - Choose a style to use for the bevel of the first (outer) curve.  There are 15 predefined styles (values 0 to 14 can be used to select them). For those experienced with MEL, you can, after the fact, specify a custom curve and use it for the style curve. See the documentation for styleCurve node to see what requirements a style curve must satisfy.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
        range | rn: (create) - Force a curve range on complete input curve.
    """
    ...


def bezierAnchorPreset(*args, preset: Optional[Union[int, bool]] = ..., p: Optional[Union[int, bool]] = ...) -> Any:
    r"""
    This command provides a queryable interface for Bezier curve shapes.

    Args:
        preset | p: (create) - Selects a preset to apply to selected Bezier anchors. Valid arguments are:  0: Bezier 1: Bezier Corner 2: Corner
    """
    ...


def bezierAnchorState(*args, even: bool = ..., ev: bool = ..., smooth: bool = ..., sm: bool = ...) -> Any:
    r"""
    The bezierAnchorState command provides an easy interface to modify anchor states:
    
    - Smooth/Broken anchor tangents
    - Even/Uneven weighted anchor tangents

    Args:
        even | ev: (create) - Sets selected anchors (or attached tangent handles) to even weighting when true, uneven otherwise.
        smooth | sm: (create) - Sets selected anchors (or attached tangent handles) to smooth when true, broken otherwise.
    """
    ...


def bezierCurveToNurbs(*args) -> Any:
    r"""
    The bezierCurveToNurbs command attempts to convert an existing NURBS curve
    to a Bezier curve.

    Args:
    """
    ...


def bezierInfo(*args, anchorFromCV: Optional[Union[int, bool]] = ..., afc: Optional[Union[int, bool]] = ..., cvFromAnchor: Optional[Union[int, bool]] = ..., cfa: Optional[Union[int, bool]] = ..., isAnchorSelected: bool = ..., ias: bool = ..., isTangentSelected: bool = ..., its: bool = ..., onlyAnchorsSelected: bool = ..., oas: bool = ..., onlyTangentsSelected: bool = ..., ots: bool = ...) -> Any:
    r"""
    This command provides a queryable interface for Bezier curve shapes.

    Args:
        anchorFromCV | afc: (create) - Returns the Bezier anchor index from a given CV index
        cvFromAnchor | cfa: (create) - Returns the CV index for a given Bezier anchor index
        isAnchorSelected | ias: (create) - Returns 1 if an anchor CV is currently selected. 0, otherwise.
        isTangentSelected | its: (create) - Returns 1 if a tangent CV is currently selected. 0, otherwise.
        onlyAnchorsSelected | oas: (create) - Returns 1 if the only CV components selected are anchor CVs. 0, otherwise.
        onlyTangentsSelected | ots: (create) - Returns 1 if the only CV components selected are tangent CVs. 0, otherwise.
    """
    ...


def blend2(*args, autoAnchor: bool = ..., aa: bool = ..., autoNormal: bool = ..., an: bool = ..., caching: bool = ..., cch: bool = ..., flipLeftNormal: bool = ..., fln: bool = ..., flipRightNormal: bool = ..., frn: bool = ..., leftAnchor: Optional[Union[float, bool]] = ..., la: Optional[Union[float, bool]] = ..., leftEnd: Optional[Union[float, bool]] = ..., le: Optional[Union[float, bool]] = ..., leftStart: Optional[Union[float, bool]] = ..., ls: Optional[Union[float, bool]] = ..., multipleKnots: bool = ..., mk: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., positionTolerance: Optional[Union[float, bool]] = ..., pt: Optional[Union[float, bool]] = ..., reverseLeft: bool = ..., rvl: bool = ..., reverseRight: bool = ..., rvr: bool = ..., rightAnchor: Optional[Union[float, bool]] = ..., ra: Optional[Union[float, bool]] = ..., rightEnd: Optional[Union[float, bool]] = ..., re: Optional[Union[float, bool]] = ..., rightStart: Optional[Union[float, bool]] = ..., rs: Optional[Union[float, bool]] = ..., tangentTolerance: Optional[Union[float, bool]] = ..., tt: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., crvsInFirstRail: Optional[Union[int, bool]] = ..., cfr: Optional[Union[int, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command creates a surface by blending between given curves.
    This is an enhancement (more user control) compared to blend
    which is now obsolete.

    Args:
        autoAnchor | aa: (create, edit, query) - If true and both paths are closed, automatically determine the value on the right rail so that they match Default: true
        autoNormal | an: (create, edit, query) - If true, the direction of each starting tangent is computed based on given geometry. Default: true
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        flipLeftNormal | fln: (create, edit, query) - If true, flip the starting tangent off the left boundary. Default: false
        flipRightNormal | frn: (create, edit, query) - If true, flip the starting tangent off the right boundary. Default: false
        leftAnchor | la: (create, edit, query) - The reference parameter on the left boundary where the blend surface starts in the case of the closed rail. Default: 0.0
        leftEnd | le: (create, edit, query) - The reference parameter on the left boundary where the blend surface ends. Default: 1.0
        leftStart | ls: (create, edit, query) - The reference parameter on the left boundary where the blend surface starts. Default: 0.0
        multipleKnots | mk: (create, edit, query) - If true, use the new blend which produces fully multiple interior knots Default: true
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        positionTolerance | pt: (create, edit, query) - The positional C(0) tolerance of the blend surface to the adjacent surfaces. Default: 0.1
        reverseLeft | rvl: (create, edit, query) - If true, reverse the direction off the left boundary.  autoDirection must be false for this value to be considered. Default: false
        reverseRight | rvr: (create, edit, query) - If true, reverse the direction of the right boundary.  autoDirection must be false for this value to be considered. Default: false
        rightAnchor | ra: (create, edit, query) - The reference parameter on the right boundary where the blend surface starts in the case of the closed rail. Default: 0.0
        rightEnd | re: (create, edit, query) - The reference parameter on the right boundary where the blend surface ends. Default: 1.0
        rightStart | rs: (create, edit, query) - The reference parameter on the right boundary where the blend surface starts. Default: 0.0
        tangentTolerance | tt: (create, edit, query) - The tangent G(1) continuity tolerance of the blend surface to the adjacent surfaces. Default: 0.1
        constructionHistory | ch: (create) - Turn the construction history on or off.
        crvsInFirstRail | cfr: (create, edit, query) - Number of curves in the first rail of the blend.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
    """
    ...


def blindDataType(*args, dataType: Optional[Union[str, bool]] = ..., dt: Optional[Union[str, bool]] = ..., longDataName: Optional[Union[str, bool]] = ..., ldn: Optional[Union[str, bool]] = ..., longNames: bool = ..., ln: bool = ..., query: bool = ..., q: bool = ..., shortDataName: Optional[Union[str, bool]] = ..., sdn: Optional[Union[str, bool]] = ..., shortNames: bool = ..., sn: bool = ..., typeId: Optional[Union[int, bool]] = ..., id: Optional[Union[int, bool]] = ..., typeNames: bool = ..., tn: bool = ...) -> Any:
    r"""
    This command creates a blind data type, which is represented by a
    blindDataTemplate node in the DG. A blind data type can have one
    or more attributes. On the command line, the attributes should be
    ordered by type for best memory utilization, largest first:
    string, binary, double, float, int, and finally boolean.
    Once a blind data type is created, blind data of that type may
    be assigned using the polyBlindData command. Note that as well
    as polygon components, blind data may be assigned to objects
    and to NURBS patches. A blind data type may not be modified
    after it is created: in order to do so it must be deleted and
    recreated. Any existing blind data of that type would also need
    to be deleted and recreated.
    When used with the query flag, this command will return information
    about the attributes of the specified blind data type.

    Args:
        dataType | dt: (create, multiuse) - Specifies the dataTypes that are part of BlindData node being created. Allowable strings are "int", "float", "double", "string", "boolean" and "binary". Must be used togeter with the -ldn and -sdn flags to specify each attribute.
        longDataName | ldn: (create, multiuse) - Specifies the long names of the datas that are part of BlindData node being created. Must be used togeter with the -dt and -sdn flags to specify each attribute.
        longNames | ln: (create) - Specifies that for a query command the long attributes names be listed.
        query | q: (create) - Specifies that this is a special query type command.
        shortDataName | sdn: (create, multiuse) - Specifies the short names of the data that are part of BlindData node being created. Must be used togeter with the -dt and -ldn flags to specify each attribute.
        shortNames | sn: (create) - Specifies that for a query command the short attribute names be listed.
        typeId | id: (create) - Specifies the typeId of the BlindData type being created.
        typeNames | tn: (create) - Specifies that for a query command the data types be listed.
    """
    ...


def boundary(*args, caching: bool = ..., cch: bool = ..., endPoint: bool = ..., ep: bool = ..., endPointTolerance: Optional[Union[float, bool]] = ..., ept: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., order: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., range: bool = ..., rn: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command produces a boundary surface given 3 or 4 curves.
    This resulting boundary surface passes through two of the given curves
    in one direction, while in the other direction the shape is
    defined by the remaining curve(s).  If the "endPoint" option
    is on, then the curve endpoints must touch before a surface
    will be created.   This is the usual situation where a boundary
    surface is useful.
      Note that there is no tangent continuity option with this command.
    Unless all the curve end points are touching, the resulting
    surface will not pass through all curves.  Instead, use the birail
    command.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        endPoint | ep: (create, edit, query) - True means the curve ends must touch before a surface will be created. Default: false
        endPointTolerance | ept: (create, edit, query) - Tolerance for end points, only used if endPoint attribute is true. Default: 0.1
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        order | order: (create, edit, query) - True if the curve order is important. Default: true
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
        range | rn: (create) - Force a curve range on complete input curve.
    """
    ...


def canCreateManip(*args) -> Any:
    r"""
    This command returns true if there can be a manipulator made for
    the specified selection, false otherwise.

    Args:
    """
    ...


def changeSubdivComponentDisplayLevel(*args, level: Optional[Union[int, bool]] = ..., l: Optional[Union[int, bool]] = ..., relative: bool = ..., r: bool = ..., query: bool = ...) -> Any:
    r"""
    Explicitly forces the subdivision surface to display components at a
    particular level of refinement.

    Args:
        level | l: (create, query) - Specifies the display level of components.
        relative | r: (create, query) - If set, level refers to the relative display level
    """
    ...


def changeSubdivRegion(*args, action: Optional[Union[int, bool]] = ..., a: Optional[Union[int, bool]] = ..., level: Optional[Union[int, bool]] = ..., l: Optional[Union[int, bool]] = ...) -> Any:
    r"""
    Changes a subdivision surface region based on the command parameters.
    The command operates on the selected subdivision surfaces.

    Args:
        action | a: (create) - Specifies the action to the selection region      1 = delete selection region      2 = enlarge selection region
        level | l: (create) - Specify the level of the subdivision surface to perform the operation
    """
    ...


def circle(*args, caching: bool = ..., cch: bool = ..., center: Optional[Union[Tuple[float, float, float], bool]] = ..., c: Optional[Union[Tuple[float, float, float], bool]] = ..., centerX: Optional[Union[float, bool]] = ..., cx: Optional[Union[float, bool]] = ..., centerY: Optional[Union[float, bool]] = ..., cy: Optional[Union[float, bool]] = ..., centerZ: Optional[Union[float, bool]] = ..., cz: Optional[Union[float, bool]] = ..., degree: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., first: Optional[Union[Tuple[float, float, float], bool]] = ..., fp: Optional[Union[Tuple[float, float, float], bool]] = ..., firstPointX: Optional[Union[float, bool]] = ..., fpx: Optional[Union[float, bool]] = ..., firstPointY: Optional[Union[float, bool]] = ..., fpy: Optional[Union[float, bool]] = ..., firstPointZ: Optional[Union[float, bool]] = ..., fpz: Optional[Union[float, bool]] = ..., fixCenter: bool = ..., fc: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., normal: Optional[Union[Tuple[float, float, float], bool]] = ..., nr: Optional[Union[Tuple[float, float, float], bool]] = ..., normalX: Optional[Union[float, bool]] = ..., nrx: Optional[Union[float, bool]] = ..., normalY: Optional[Union[float, bool]] = ..., nry: Optional[Union[float, bool]] = ..., normalZ: Optional[Union[float, bool]] = ..., nrz: Optional[Union[float, bool]] = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., sections: Optional[Union[int, bool]] = ..., s: Optional[Union[int, bool]] = ..., sweep: Optional[Union[float, bool]] = ..., sw: Optional[Union[float, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., useTolerance: bool = ..., ut: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The circle command creates a circle or partial circle (arc)

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        center | c: (create, edit, query) - The center point of the circle.
        centerX | cx: (create, edit, query) - X of the center point. Default: 0
        centerY | cy: (create, edit, query) - Y of the center point. Default: 0
        centerZ | cz: (create, edit, query) - Z of the center point. Default: 0
        degree | d: (create, edit, query) - The degree of the resulting circle: 1 - linear, 3 - cubic Default: 3
        first | fp: (create, edit, query) - The start point of the circle if fixCenter is false. Determines the orientation of the circle if fixCenter is true.
        firstPointX | fpx: (create, edit, query) - X of the first point. Default: 1
        firstPointY | fpy: (create, edit, query) - Y of the first point. Default: 0
        firstPointZ | fpz: (create, edit, query) - Z of the first point. Default: 0
        fixCenter | fc: (create, edit, query) - Fix the center of the circle to the specified center point. Otherwise the circle will start at the specified first point. Default: true
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        normal | nr: (create, edit, query) - The normal of the plane in which the circle will lie.
        normalX | nrx: (create, edit, query) - X of the normal direction. Default: 0
        normalY | nry: (create, edit, query) - Y of the normal direction. Default: 0
        normalZ | nrz: (create, edit, query) - Z of the normal direction. Default: 1
        radius | r: (create, edit, query) - The radius of the circle. Default: 1.0
        sections | s: (create, edit, query) - The number of sections determines the resolution of the circle. Used only if useTolerance is false. Default: 8
        sweep | sw: (create, edit, query) - The sweep angle determines the completeness of the circle. A full circle is 2Pi radians, or 360 degrees. Default: 6.2831853
        tolerance | tol: (create, edit, query) - The tolerance with which to build a circle. Used only if useTolerance is true Default: 0.01
        useTolerance | ut: (create, edit, query) - Use the specified tolerance to determine resolution. Otherwise number of sections will be used. Default: false
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
    """
    ...


def circularFillet(*args, caching: bool = ..., cch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., positionTolerance: Optional[Union[float, bool]] = ..., pt: Optional[Union[float, bool]] = ..., primaryRadius: Optional[Union[float, bool]] = ..., pr: Optional[Union[float, bool]] = ..., secondaryRadius: Optional[Union[float, bool]] = ..., sr: Optional[Union[float, bool]] = ..., tangentTolerance: Optional[Union[float, bool]] = ..., tt: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., curveOnSurface: bool = ..., cos: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The cmd is used to compute the rolling ball surface
    fillet ( circular fillet ) between two given NURBS surfaces.
    To generate trim curves on the surfaces, use -cos true.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        positionTolerance | pt: (create, edit, query) - C(0) Tolerance For Fillet Surface Default: 0.01
        primaryRadius | pr: (create, edit, query) - primary Radius Default: 1.0
        secondaryRadius | sr: (create, edit, query) - secondary Radius Default: 1.0
        tangentTolerance | tt: (create, edit, query) - G(1) Tolerance For Fillet Surface Default: 0.01
        constructionHistory | ch: (create) - Turn the construction history on or off.
        curveOnSurface | cos: (create) - If possible, create 2D curve as a result.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
    """
    ...


def closeCurve(*args, blendBias: Optional[Union[float, bool]] = ..., bb: Optional[Union[float, bool]] = ..., blendKnotInsertion: bool = ..., bki: bool = ..., caching: bool = ..., cch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., parameter: Optional[Union[float, bool]] = ..., p: Optional[Union[float, bool]] = ..., preserveShape: Optional[Union[int, bool]] = ..., ps: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., curveOnSurface: bool = ..., cos: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The closeCurve command closes a curve, making it periodic.
    The pathname to the newly closed curve and the name
    of the resulting dependency node are returned.  If a curve
    is not specified in the command, then the first active curve
    will be used.

    Args:
        blendBias | bb: (create, edit, query) - Skew the result toward the first or the second curve depending on the blend value being smaller or larger than 0.5. Default: 0.5
        blendKnotInsertion | bki: (create, edit, query) - If set to true, insert a knot in one of the original curves (relative position given by the parameter attribute below) in order to produce a slightly different effect. Default: false
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        parameter | p: (create, edit, query) - The parameter value for the positioning of the newly inserted knot. Default: 0.1
        preserveShape | ps: (create, edit, query) - 0 - without preserving the shape 1 - preserve shape 2 - blend Default: 1
        constructionHistory | ch: (create) - Turn the construction history on or off.
        curveOnSurface | cos: (create) - If possible, create 2D curve as a result.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def closeSurface(*args, blendBias: Optional[Union[float, bool]] = ..., bb: Optional[Union[float, bool]] = ..., blendKnotInsertion: bool = ..., bki: bool = ..., caching: bool = ..., cch: bool = ..., direction: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., parameter: Optional[Union[float, bool]] = ..., p: Optional[Union[float, bool]] = ..., preserveShape: Optional[Union[int, bool]] = ..., ps: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The closeSurface command closes a surface in the U, V, or both
    directions, making it periodic. The close direction is controlled
    by the direction flag. If a surface is not specified in the
    command, then the first selected surface will be used.
    
    The pathname to the newly closed surface and the name of the resulting
    dependency node are returned.
    
    This command also handles selected surface isoparms. For example, if
    an isoparm is specified, surface1.u[0.33], then the surface will be
    closed in V, regardless of the direction flag.

    Args:
        blendBias | bb: (create, edit, query) - Skew the result toward the first or the second surface depending on the blend value being smaller or larger than 0.5. Default: 0.5
        blendKnotInsertion | bki: (create, edit, query) - If set to true, insert a knot in one of the original surfaces (relative position given by the parameter attribute below) in order to produce a slightly different effect. Default: false
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        direction | d: (create, edit, query) - The direction in which to close: 0 - U, 1 - V, 2 - Both U and V Default: 0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        parameter | p: (create, edit, query) - The parameter value for the positioning of the newly inserted knot. Default: 0.1
        preserveShape | ps: (create, edit, query) - 0 - without preserving the shape 1 - preserve shape 2 - blend Default: 1
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def coarsenSubdivSelectionList(*args) -> Any:
    r"""
    Coarsens a subdivision surface set of components based on the selection list. The
    selected components are selected at a coarser level.

    Args:
    """
    ...


def cone(*args, axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., caching: bool = ..., cch: bool = ..., degree: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., endSweep: Optional[Union[float, bool]] = ..., esw: Optional[Union[float, bool]] = ..., heightRatio: Optional[Union[float, bool]] = ..., hr: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., pivot: Optional[Union[Tuple[float, float, float], bool]] = ..., p: Optional[Union[Tuple[float, float, float], bool]] = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., sections: Optional[Union[int, bool]] = ..., s: Optional[Union[int, bool]] = ..., spans: Optional[Union[int, bool]] = ..., nsp: Optional[Union[int, bool]] = ..., startSweep: Optional[Union[float, bool]] = ..., ssw: Optional[Union[float, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., useOldInitBehaviour: bool = ..., oib: bool = ..., useTolerance: bool = ..., ut: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The cone command creates a new cone and/or a dependency
    node that creates one, and returns their names.

    Args:
        axis | ax: (create, edit, query) - The primitive's axis
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        degree | d: (create, edit, query) - The degree of the resulting surface: 1 - linear, 3 - cubic Default: 3
        endSweep | esw: (create, edit, query) - The angle at which to end the surface of revolution. Default is 2Pi radians, or 360 degrees. Default: 6.2831853
        heightRatio | hr: (create, edit, query) - Ratio of "height" to "width" Default: 2.0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        pivot | p: (create, edit, query) - The primitive's pivot point
        radius | r: (create, edit, query) - The radius of the object Default: 1.0
        sections | s: (create, edit, query) - The number of sections determines the resolution of the surface in the sweep direction. Used only if useTolerance is false. Default: 8
        spans | nsp: (create, edit, query) - The number of spans determines the resolution of the surface in the opposite direction. Default: 1
        startSweep | ssw: (create, edit, query) - The angle at which to start the surface of revolution Default: 0
        tolerance | tol: (create, edit, query) - The tolerance with which to build the surface. Used only if useTolerance is true Default: 0.01
        useOldInitBehaviour | oib: (create, edit, query) - Create the cone with base on the origin as in Maya V8.0 and below Otherwise create cone centred at origin Default: false
        useTolerance | ut: (create, edit, query) - Use the specified tolerance to determine resolution. Otherwise number of sections will be used. Default: false
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
    """
    ...


def constructionHistory(*args, toggle: bool = ..., tgl: bool = ..., query: bool = ...) -> Any:
    r"""
    This command turns construction history on or off.

    Args:
        toggle | tgl: (create, query) - Turns construction history on or off.
    """
    ...


def createSubdivRegion(*args) -> Any:
    r"""
    Creates a subdivision surface region based on the selection list. Once
    a selection region is created, only the components in the selection list
    or converted from the selection list will be displayed and selectible
    through the UI.

    Args:
    """
    ...


def curve(*args, append: bool = ..., a: bool = ..., bezier: bool = ..., bez: bool = ..., degree: Optional[Union[float, bool]] = ..., d: Optional[Union[float, bool]] = ..., editPoint: Optional[Union[Tuple[float, float, float], bool]] = ..., ep: Optional[Union[Tuple[float, float, float], bool]] = ..., knot: Optional[Union[float, bool]] = ..., k: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., objectSpace: bool = ..., os: bool = ..., periodic: bool = ..., per: bool = ..., point: Optional[Union[Tuple[float, float, float], bool]] = ..., p: Optional[Union[Tuple[float, float, float], bool]] = ..., pointWeight: Optional[Union[Tuple[float, float, float, float], bool]] = ..., pw: Optional[Union[Tuple[float, float, float, float], bool]] = ..., replace: bool = ..., r: bool = ..., worldSpace: bool = ..., ws: bool = ...) -> Any:
    r"""
    The curve command creates a new curve from a list of control vertices
    (CVs).  A string is returned containing the pathname to the newly
    created curve.  You can create a curve from points either in world
    space or object (local) space, either with weights or without.
    You can replace an existing curve by using the "-r/replace"
    flag.  You can append a point to an existing curve by using the
    "-a/append" flag.
     To create a curve-on-surface, use the curveOnSurface command.
     To change the degree of a curve, use the rebuildCurve command.
     To change the of parameter range curve, use the rebuildCurve command.

    Args:
        append | a: (create) - Appends point(s) to the end of an existing curve. If you use this flag, you must specify the name of the curve to append to, at the end of the command.  (See examples below.)
        bezier | bez: (create) - The created curve will be a bezier curve.
        degree | d: (create) - The degree of the new curve.  Default is 3.  Note that you need (degree+1) curve points to create a visible curve span.  eg. you must place 4 points for a degree 3 curve.
        editPoint | ep: (create, multiuse) - The x, y, z position of an edit point.  "linear" means that this flag can take values with units.  This flag can not be used with the -point or the -pointWeight flags.
        knot | k: (create, multiuse) - A knot value in a knot vector.  One flag per knot value. There must be (numberOfPoints + degree - 1) knots and the knot vector must be non-decreasing.
        name | n: (create) - Name of the curve
        objectSpace | os: (create) - Points are in object, or "local" space.  This is the default. You cannot specify both "-os" and "-ws" in the same command.
        periodic | per: (create) - If on, creates a curve that is periodic.  Default is off.
        point | p: (create, multiuse) - The x, y, z position of a point.  "linear" means that this flag can take values with units.
        pointWeight | pw: (create, multiuse) - The x,y,z and w values of a point, where the w is a weight value. A rational curve will be created if this flag is used. "linear" means that this flag can take values with units.
        replace | r: (create) - Replaces an entire existing curve. If you use this flag, you must specify the name of the curve to replace, at the end of the command.  (See examples below.)
        worldSpace | ws: (create) - Points are in world space.  The default is "-os". You cannot specify both "-os" and "-ws" in the same command.
    """
    ...


def curveIntersect(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., direction: Optional[Union[Tuple[float, float, float], bool]] = ..., d: Optional[Union[Tuple[float, float, float], bool]] = ..., directionX: Optional[Union[float, bool]] = ..., dx: Optional[Union[float, bool]] = ..., directionY: Optional[Union[float, bool]] = ..., dy: Optional[Union[float, bool]] = ..., directionZ: Optional[Union[float, bool]] = ..., dz: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., useDirection: bool = ..., ud: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    You must specify two curves to intersect.
    
    This command either returns the parameter values at which the given
    pair of curves intersect, or returns a dependency node that provides
    the intersection information. If you want to find the intersection of
    the curves in a specific direction you must use BOTH the
    "-useDirection" flag and the "direction" flag.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create) - Turn the construction history on or off.
        direction | d: (edit, query) - The direction that the input curves are projected in before intersecting.  This vector is only used if "useDirection" flag is true.
        directionX | dx: (edit, query) - The X component of the direction that the input curves are projected in before intersecting.  This vector is only used if "useDirection" flag is true.
        directionY | dy: (edit, query) - The Y component of the direction that the input curves are projected in before intersecting.  This vector is only used if "useDirection" flag is true.
        directionZ | dz: (edit, query) - The Z component of the direction that the input curves are projected in before intersecting.  This vector is only used if "useDirection" flag is true.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        tolerance | tol: (edit, query) - The tolerance that the intersection is calculated with. For example, given two curves end-to-end, the ends must be within tolerance for an intersection to be returned. Default: 0.001
        useDirection | ud: (edit, query) - If true, use direction flag.  The input curves are first projected in a specified direction and then intersected. If false, this command will only find true 3D intersections. Default: false
    """
    ...


def curveOnSurface(*args, append: bool = ..., a: bool = ..., degree: Optional[Union[float, bool]] = ..., d: Optional[Union[float, bool]] = ..., knot: Optional[Union[float, bool]] = ..., k: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., periodic: bool = ..., per: bool = ..., positionUV: Optional[Union[Tuple[float, float], bool]] = ..., uv: Optional[Union[Tuple[float, float], bool]] = ..., replace: bool = ..., r: bool = ...) -> Any:
    r"""
    The curve command creates a new curve from a list of control vertices
    (CVs).  A string is returned containing the pathname to the newly
    created curve.  You can create a curve from points either in world
    space or object (local) space, either with weights or without.
    You can replace an existing curve by using the "-r/replace"
    flag.  You can append a point to an existing curve by using the
    "-a/append" flag.
     To create a curve-on-surface, use the curveOnSurface command.
     To change the degree of a curve, use the rebuildCurve command.
     To change the of parameter range curve, use the rebuildCurve command.
    
    The curve-on-surface command creates a new curve-on-surface from a
    list of control vertices (CVs).  A string is returned containing
    the pathname to the newly created curve-on-surface.
    You can replace an existing curve by using the "-r/replace"
    flag. You can append points to an existing curve-on-surface by
    using the "-a/append" flag.
    See also the curve command, which describes how to query curve
    attributes.

    Args:
        append | a: (create) - Appends point(s) to the end of an existing curve. If you use this flag, you must specify the name of the curve to append to, at the end of the command.  (See examples below.)
        degree | d: (create) - The degree of the new curve.  Default is 3.  Note that you need (degree+1) curve points to create a visible curve span.  eg. you must place 4 points for a degree 3 curve.
        knot | k: (create, multiuse) - A knot value in a knot vector.  One flag per knot value. There must be (numberOfPoints + degree - 1) knots and the knot vector must be non-decreasing.
        name | n: (create) - Name of the curve
        periodic | per: (create) - If on, creates a curve that is periodic.  Default is off.
        positionUV | uv: (create, multiuse) - The uv position of a point.
        replace | r: (create) - Replaces an entire existing curve. If you use this flag, you must specify the name of the curve to replace, at the end of the command.  (See examples below.)
    """
    ...


def cylinder(*args, axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., caching: bool = ..., cch: bool = ..., degree: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., endSweep: Optional[Union[float, bool]] = ..., esw: Optional[Union[float, bool]] = ..., heightRatio: Optional[Union[float, bool]] = ..., hr: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., pivot: Optional[Union[Tuple[float, float, float], bool]] = ..., p: Optional[Union[Tuple[float, float, float], bool]] = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., sections: Optional[Union[int, bool]] = ..., s: Optional[Union[int, bool]] = ..., spans: Optional[Union[int, bool]] = ..., nsp: Optional[Union[int, bool]] = ..., startSweep: Optional[Union[float, bool]] = ..., ssw: Optional[Union[float, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., useTolerance: bool = ..., ut: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The cylinder command creates a new cylinder and/or a
    dependency node that creates one, and returns their names.

    Args:
        axis | ax: (create, edit, query) - The primitive's axis
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        degree | d: (create, edit, query) - The degree of the resulting surface: 1 - linear, 3 - cubic Default: 3
        endSweep | esw: (create, edit, query) - The angle at which to end the surface of revolution. Default is 2Pi radians, or 360 degrees. Default: 6.2831853
        heightRatio | hr: (create, edit, query) - Ratio of "height" to "width" Default: 2.0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        pivot | p: (create, edit, query) - The primitive's pivot point
        radius | r: (create, edit, query) - The radius of the object Default: 1.0
        sections | s: (create, edit, query) - The number of sections determines the resolution of the surface in the sweep direction. Used only if useTolerance is false. Default: 8
        spans | nsp: (create, edit, query) - The number of spans determines the resolution of the surface in the opposite direction. Default: 1
        startSweep | ssw: (create, edit, query) - The angle at which to start the surface of revolution Default: 0
        tolerance | tol: (create, edit, query) - The tolerance with which to build the surface. Used only if useTolerance is true Default: 0.01
        useTolerance | ut: (create, edit, query) - Use the specified tolerance to determine resolution. Otherwise number of sections will be used. Default: false
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
    """
    ...


def dataStructure(*args, asFile: Optional[Union[str, bool]] = ..., af: Optional[Union[str, bool]] = ..., asString: Optional[Union[str, bool]] = ..., dataType: bool = ..., dt: bool = ..., format: Optional[Union[str, bool]] = ..., fmt: Optional[Union[str, bool]] = ..., listMemberNames: Optional[Union[str, bool]] = ..., lmn: Optional[Union[str, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., remove: bool = ..., rem: bool = ..., removeAll: bool = ..., ral: bool = ..., query: bool = ...) -> Any:
    r"""
    Takes in a description of the structure and creates it, adding it to
    the list of available data structures. The structure definition can
    either be supplied in the asString flag or exist in a file that is
    referenced by the asFile flag.
    
    
    If the remove flag is specified with a name flag then the data
    structure will be removed. This is to keep all structure operations
    in a single command rather than create separate commands to create,
    remove, and query the data structures. When you use the removeAll
    flag then every existing metadata structure is removed. Use with care!
    Note that removed structures may still be in use in metadata Streams after
    removal, they are just no longer available for the creation of new Streams.
    
    
    Both the creation modes and the remove mode are undoable.
    
    
    Creation of an exact duplicate of an existing structure (including name)
    will succeed silently without actually creating a new structure.
    Attempting to create a new non-duplicate structure with the same name
    as an existing structure will fail as there is no way to disambiguate
    two structures with the same name.
    
    
    Querying modes are defined to show information both on the created
    structures and the structure serialization formats that have been
    registered. The serialization formats preserve the structure
    information as text (e.g. raw, XML, JSON). Since the raw structure
    type is built in it will be assumed when none are specified.
    
    
    General query with no flags will return the list of names of all
    currently existing structures.
    
    
    Querying the format flag will return the list of all registered structure
    serialization formats.
    
    
    Querying with the format supplied before the query flag will
    show the detailed description of that particular structure
    serialization format.
    
    
    Querying the asString flag with a structure name and serialization
    format supplied before the query flag will return a string
    representing the named data structure in the serialization format
    specified by the format flag. Even if the format is the same as
    the one that created the structure the query return string may not
    be identical since the queried value is formatted in a standard
    way - original formatting is not preserved.
    
    
    Querying the asFile flag with a structure name supplied before the
    query flag will return the original file from which the structure
    was generated. If the structure was created using the asString
    flag or through the API then an empty string will be returned.
    
    
    Querying the name flag returns the list of all structures created
    so far.

    Args:
        asFile | af: (create, query) - Specify a file that contains the serialized data which describes the structure.  The format of the data is specified by the 'format' flag.
        asString | asString: (create, query) - Specify the string containing the serialized data which describes the structure. The format of the data is specified by the 'format' flag.
        dataType | dt: (create, query) - Used with the flag 'listMemberNames' to query the type of the member. The type is appended after each relative member in the array. For example, if the format is "name=idStructure:int32=id:string=name" the returned array is "id int32 name string".
        format | fmt: (create, query) - Format of data to expect in the structure description. "raw" is supported natively and will be assumed if the format type is omitted. Others are available via plug-in. You can query the available formats by using this flag in query mode. 			In query mode, this flag can accept a value.
        listMemberNames | lmn: (create, query) - Query the member names in the dataStructure. The member names will be returned in an array. The name of the data structure will not be returned. To get the type of each member, use 'dataType' together. Then the type of the member will be appended in the array after their relative member. For example, if the format is "name=idStructure:int32=id:string=name" the returned array is "id int32 name string".
        name | n: (query) - Query mode only.  Name of the data structure to be queried, or set to list the available names. 			In query mode, this flag can accept a value.
        remove | rem: (create) - Remove the named data structure. It's an error if it doesn't exist.
        removeAll | ral: (create) - Remove all metadata structures. This flag can not be used in conjunction with any other flags.
    """
    ...


def detachCurve(*args, caching: bool = ..., cch: bool = ..., keep: bool = ..., k: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., parameter: Optional[Union[float, bool]] = ..., p: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., curveOnSurface: bool = ..., cos: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The detachCurve command detaches a curve into pieces, given a list
    of parameter values.  You can also specify which pieces to keep and
    which to discard using the "-k" flag.
    The names of the newly detached curve(s) is returned.  If history is on,
    then the name of the resulting dependency node is also returned.
      You can use this command to open a periodic curve at a particular
    parameter value.  You would use this command with only one "-p" flag.
      If you are specifying "-k" flags, then you must specify one, none
    or all "-k" flags.  If you are specifying all "-k" flags, there
    must be one more "-k" flag than "-p" flags.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        keep | k: (create, edit, multiuse, query) - Whether or not to keep a detached piece.  This multi attribute should be one element larger than the parameter multi attribute. Default: true
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        parameter | p: (create, edit, multiuse, query) - Parameter values to detach at Default: 0.0
        constructionHistory | ch: (create) - Turn the construction history on or off.
        curveOnSurface | cos: (create) - If possible, create 2D curve as a result.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def detachSurface(*args, caching: bool = ..., cch: bool = ..., direction: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., keep: bool = ..., k: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., parameter: Optional[Union[float, bool]] = ..., p: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The detachSurface command detaches a surface into pieces, given a list
    of parameter values and a direction.  You can also specify which
    pieces to keep and which to discard using the "-k" flag.
    The names of the newly detached surface(s) are returned.  If history
    is on, the name of the resulting dependency node is also returned.
      You can only detach in either U or V (not both) with a single detachSurface operation.
        You can use this command to open a closed surface at a particular
    parameter value.  You would use this command with only one "-p" flag.
      If you are specifying "-k" flags, then you must specify one, none
    or all "-k" flags.  If you are specifying all "-k" flags, there
    must be one more "-k" flag than "-p" flags.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        direction | d: (create, edit, query) - Direction in which to detach: 0 - V direction, 1 - U direction Default: 1
        keep | k: (create, edit, multiuse, query) - Keep the detached pieces. Default: true
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        parameter | p: (create, edit, multiuse, query) - Parameter at which to detach. Default: 0.0
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def doubleProfileBirailSurface(*args, blendFactor: Optional[Union[float, bool]] = ..., bl: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., tangentContinuityProfile1: bool = ..., tp1: bool = ..., tangentContinuityProfile2: bool = ..., tp2: bool = ..., transformMode: Optional[Union[int, bool]] = ..., tm: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The arguments are 4 cuves called "profile1" "profile2" "rail1" "rail2".
    
    This command builds a railed surface by sweeping profile "profile1"
    along the two given rail curves "rail1", "rail2" until "profile2" is
    reached. By using the -blend control, the railed surface creation
    could be biased more towards one of the two profile curves. The curves
    ( both profiles and rails ) could also be surface curves ( isoparams,
    curve on surfaces ). If the profile curves are surface curves the
    surface constructed could be made tangent continuous to the surfaces
    underlying the profiles using the flags -tp1, -tp2 respectively.
    Current Limitation: Its necessary that the two profile curves
    intersect the rail curves for successful surface creation.

    Args:
        blendFactor | bl: (create, edit, query) - A blend factor applied in between the two profiles. The amount of influence 'inputProfile1' has in the surface creation. Default: 0.5
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        tangentContinuityProfile1 | tp1: (create, edit, query) - Need tangent continuity across the input profile at inputProfile1. Default: false
        tangentContinuityProfile2 | tp2: (create, edit, query) - Need tangent continuity across the input curve at inputProfile2. Default: false
        transformMode | tm: (create, edit, query) - transform mode ( Non proportional, proportional ). Non proportional is default value. Default: 0
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
    """
    ...


def duplicateCurve(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., local: bool = ..., l: bool = ..., maxValue: Optional[Union[float, bool]] = ..., max: Optional[Union[float, bool]] = ..., mergeItems: bool = ..., mi: bool = ..., minValue: Optional[Union[float, bool]] = ..., min: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., range: bool = ..., rn: bool = ..., relative: bool = ..., r: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The duplicateCurve command takes a curve on a surface and
    and returns the 3D curve. The curve on a surface could be
    isoparam component, trimmed edge or curve on surface object.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create) - Turn the construction history on or off.
        local | l: (create) - Copy the transform of the surface and connect to the local space version instead.
        maxValue | max: (create, edit, query) - Maximum parameter value for the curve segment.  Must be greater than or equal to the minValue attribute. If relative is true, then this attribute has maximum value of 1.0. Default: -1.0
        mergeItems | mi: (create) - Merge component results where possible. For example, instead of returning a[1] and a[2], return a[1:2].
        minValue | min: (create, edit, query) - Minimum parameter value for the curve segment If relative is true, then this attribute has minimum value of 0.0. Default: 1.0
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        range | rn: (create) - Force a curve range on complete input curve.
        relative | r: (create, edit, query) - True means use a relative parameter range, from 0.0 to 1.0. Otherwise, the parameter values are absolute values. Default: false
    """
    ...


def duplicateSurface(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., faceCountU: Optional[Union[int, bool]] = ..., fcu: Optional[Union[int, bool]] = ..., faceCountV: Optional[Union[int, bool]] = ..., fcv: Optional[Union[int, bool]] = ..., firstFaceU: Optional[Union[int, bool]] = ..., ffu: Optional[Union[int, bool]] = ..., firstFaceV: Optional[Union[int, bool]] = ..., ffv: Optional[Union[int, bool]] = ..., local: bool = ..., l: bool = ..., mergeItems: bool = ..., mi: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The duplicateSurface command takes a surface patch (face) and
    and returns the 3D surface. Connected patches are returned
    as a single surface.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create) - Turn the construction history on or off.
        faceCountU | fcu: (create, edit, query) - Number of faces in U direction Default: 1
        faceCountV | fcv: (create, edit, query) - Number of faces in V direction Default: 1
        firstFaceU | ffu: (create, edit, query) - First face (U direction index) Default: 0
        firstFaceV | ffv: (create, edit, query) - First face (V direction index) Default: 0
        local | l: (create) - Copy the transform of the surface and connect to the local space version instead.
        mergeItems | mi: (create) - Merge component results where possible. For example, instead of returning a[1] and a[2], return a[1:2].
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def editMetadata(*args, memberName: Optional[Union[str, bool]] = ..., mn: Optional[Union[str, bool]] = ..., remove: bool = ..., rem: bool = ..., stringValue: Optional[Union[str, bool]] = ..., sv: Optional[Union[str, bool]] = ..., value: Optional[Union[float, bool]] = ..., v: Optional[Union[float, bool]] = ..., channelName: Optional[Union[str, bool]] = ..., cn: Optional[Union[str, bool]] = ..., channelType: Optional[Union[str, bool]] = ..., cht: Optional[Union[str, bool]] = ..., endIndex: Optional[Union[str, bool]] = ..., eix: Optional[Union[str, bool]] = ..., index: Optional[Union[str, bool]] = ..., idx: Optional[Union[str, bool]] = ..., indexType: Optional[Union[str, bool]] = ..., idt: Optional[Union[str, bool]] = ..., scene: bool = ..., scn: bool = ..., startIndex: Optional[Union[str, bool]] = ..., six: Optional[Union[str, bool]] = ..., streamName: Optional[Union[str, bool]] = ..., stn: Optional[Union[str, bool]] = ...) -> Any:
    r"""
    This command is used to set metadata elements onto or remove metadata
    elements from an object. Before using this command you must first attach
    a metadata stream type to the object using the addMetadata command
    or an API equivalent. The command has four basic variations:
    
    Set per-component metadata on meshes
    Remove per-component metadata on meshes
    Set generic metadata on any object
    Remove generic metadata on any object
    
    
    The difference between the set and remove variations
    (1,3 vs. 2,4) is that set requires both a member name to be set
    and a new value to be set. (The reason removal doesn't use a member
    name is that you can only remove an entire metadata structural element,
    you cannot remove only a single member from it.)
    
    
    When metadata values are set or removed the action is performed on
    every selected component or index. This provides an easy method to
    set or remove a bunch of metadata en masse.
    
    
    The general usage (variations 3, 4) lets you select specific pieces
    of metadata through the channelName and index
    flags. Note that since index is a multi-use flag you
    can select many different elements from the same Channel and set or
    remove the metadata on all of them in one command.
    
    
    Metadata on meshes is special in that the Channel types "vertex",
    "edge", "face", and "vertexFace" are directly connected to the
    components of the same name. To make setting these metadata
    Channels easier you can simply select or specify on the command
    line the corresponding components rather than using the channelName
    and index flags. For example the selection "myMesh.vtx[8:10]"
    corresponds to channelName = vertex and index = 8, 9, 10
    (as a multi-use flag).
    
    
    Note that the metadata is assigned to an object and except in the special
    case of mesh geometry does not flow through the dependency graph. In
    meshes the metadata will move from node to node wherever the geometry
    is connected, although it will not adjust itself automatically for changes
    in topology. Internal data is arranged to minimize the amount of copying
    no matter how many other nodes are connected to it.
    
    
    Only a single node or scene, component type, channel type, and value type
    are allowed in a single command. This keeps the data simple at the possible
    cost of requiring multiple calls to the command to set more than one
    structure member's value.
    
    
    Certain nodes have metadata supplied by input attributes. If you edit one
    of those with an incoming connection on such an attribute then the metadata
    edit will not be applied directly it will be put into an 'editMetadata' node
    for application during DG evaluation. Since the details of the metadata are
    not known until the evaluation happens less rigorous compatibility checking
    is performed. The editMetadata node has its own facilities for verifying and
    reporting illegal metadata edits. Successive edits to the same metadata in
    this way appends each edit to the same editMetadata node.

    Args:
        memberName | mn: (create) - Name of the Structure member being edited. The names of the members are set up in the Structure definition, either through the description passed in through the "dataStructure" command or via the API used to create that Structure.
        remove | rem: (create) - If the remove flag is set then the metadata will be removed rather than have values set. In this mode the "memberName", "value", and "stringValue" flags are ignored. "memberName" is ignored because when deleting metadata all members of a structure must be removed as a group. The others are ignored since when deleting you don't need a value to be set.
        stringValue | sv: (create, multiuse) - String value to be set into the specified metadata locations. This flag can only be used when the data member is a numeric type. If the member has N dimensions (e.g. string[2]) then this flag must appear N times (e.g. 2 times) The same values are applied to the specified metadata member on all affected components or metadata indices. Only one of the value, and stringValue flags can be specified at once and the type must match the type of the structure member named by the "member" flag.
        value | v: (create, multiuse) - Numeric value to be set into the specified metadata locations. This flag can only be used when the data member is a numeric type. If the member has N dimensions (e.g. float[3]) then this flag must appear N times (e.g. 3 times) The same values are applied to the specified metadata member on all affected components or metadata indices. All numeric member types should use this type of value specification, i.e. everything except string and matrix types. Only one of the value, and stringValue flags can be specified at once and the type must match the type of the structure member named by the "member" flag.
        channelName | cn: (create, query) - Filter the metadata selection to only recognize metadata belonging to the specified named Channel (e.g. "vertex"). This flag is ignored if the components on the selection list are being used to specify the metadata of interest. 			In query mode, this flag can accept a value.
        channelType | cht: (create, query) - Obsolete - use the 'channelName' flag instead. 			In query mode, this flag can accept a value.
        endIndex | eix: (create) - The metadata is stored in a Stream, which is an indexed list. If you have mesh components selected then the metadata indices are implicit in the list of selected components. If you select only the node or scene then this flag may be used in conjunction with the startIndex flag to specify a range of indices from which to retrieve the metadata. It is an error to have the value of startIndex be greater than that of endIndex.   See also the index flag for an alternate way to specify multiple indices. This flag can only be used on index types that support a range (e.g. integer values - it makes no sense to request a range between two strings)  			In query mode, this flag can accept a value.
        index | idx: (create, multiuse, query) - In the typical case metadata is indexed using a simple integer value. Certain types of data may use other index types. e.g. a "vertexFace" component will use a "pair" index type, which is two integer values; one for the face ID of the component and the second for the vertex ID.   The index flag takes a string, formatted in the way the specified indexType requires. All uses of the index flag have the same indexType. If the type was not specified it is assumed to be a simple integer value.  			In query mode, this flag can accept a value.
        indexType | idt: (create, query) - Name of the index type the new Channel should be using. If not specified this defaults to a simple integer index. Of the native types only a mesh "vertexFace" channel is different, using a "pair" index type. 			In query mode, this flag can accept a value.
        scene | scn: (create, query) - Use this flag when you want to add metadata to the scene as a whole rather than to any individual nodes. If you use this flag and have nodes selected the nodes will be ignored and a warning will be displayed.
        startIndex | six: (create) - The metadata is stored in a Stream, which is an indexed list. If you have mesh components selected then the metadata indices are implicit in the list of selected components. If you select only the node or scene then this flag may be used in conjunction with the endIndex flag to specify a range of indices from which to retrieve the metadata. It is an error to have the value of startIndex be greater than that of endIndex.   See also the index flag for an alternate way to specify multiple indices. This flag can only be used on index types that support a range (e.g. integer values - it makes no sense to request a range between two strings)  			In query mode, this flag can accept a value.
        streamName | stn: (create, query) - Name of the metadata Stream. Depending on context it could be the name of a Stream to be created, or the name of the Stream to pass through the filter. 			In query mode, this flag can accept a value.
    """
    ...


def extendCurve(*args, caching: bool = ..., cch: bool = ..., distance: Optional[Union[float, bool]] = ..., d: Optional[Union[float, bool]] = ..., extendMethod: Optional[Union[int, bool]] = ..., em: Optional[Union[int, bool]] = ..., extensionType: Optional[Union[int, bool]] = ..., et: Optional[Union[int, bool]] = ..., inputPoint: Optional[Union[Tuple[float, float, float], bool]] = ..., ip: Optional[Union[Tuple[float, float, float], bool]] = ..., join: bool = ..., jn: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., pointX: Optional[Union[float, bool]] = ..., px: Optional[Union[float, bool]] = ..., pointY: Optional[Union[float, bool]] = ..., py: Optional[Union[float, bool]] = ..., pointZ: Optional[Union[float, bool]] = ..., pz: Optional[Union[float, bool]] = ..., removeMultipleKnots: bool = ..., rmk: bool = ..., start: Optional[Union[int, bool]] = ..., s: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., curveOnSurface: bool = ..., cos: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., noChanges: bool = ..., nc: bool = ..., object: bool = ..., o: bool = ..., range: bool = ..., rn: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command extends a curve or creates a new curve as an extension

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        distance | d: (create, edit, query) - The distance to extend Used only for extendMethod is byDistance. Default: 1
        extendMethod | em: (create, edit, query) - The method with which to extend: 0 - based on distance, 2 - to a 3D point Default: 0
        extensionType | et: (create, edit, query) - The type of extension: 0 - linear, 1 - circular, 2 - extrapolate Default: 0
        inputPoint | ip: (create, edit, query) - The point to extend to (optional)
        join | jn: (create, edit, query) - If true, join the extension to original curve Default: true
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        pointX | px: (create, edit, query) - X of the point to extend to Default: 0
        pointY | py: (create, edit, query) - Y of the point to extend to Default: 0
        pointZ | pz: (create, edit, query) - Z of the point to extend to Default: 0
        removeMultipleKnots | rmk: (create, edit, query) - If true remove multiple knots at join Used only if join is true. Default: false
        start | s: (create, edit, query) - Which end of the curve to extend. 0 - end, 1 - start, 2 - both Default: 1
        constructionHistory | ch: (create) - Turn the construction history on or off.
        curveOnSurface | cos: (create) - If possible, create 2D curve as a result.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        noChanges | nc: (create, edit, query) - If set then the operation node will be automatically put into pass-through mode.
        object | o: (create) - Create the result, or just the dependency node.
        range | rn: (create) - Force a curve range on complete input curve.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def extendSurface(*args, caching: bool = ..., cch: bool = ..., distance: Optional[Union[float, bool]] = ..., d: Optional[Union[float, bool]] = ..., extendDirection: Optional[Union[int, bool]] = ..., ed: Optional[Union[int, bool]] = ..., extendMethod: Optional[Union[int, bool]] = ..., em: Optional[Union[int, bool]] = ..., extendSide: Optional[Union[int, bool]] = ..., es: Optional[Union[int, bool]] = ..., extensionType: Optional[Union[int, bool]] = ..., et: Optional[Union[int, bool]] = ..., join: bool = ..., jn: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command extends a surface or creates a new surface as an extension.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        distance | d: (create, edit, query) - The distance to extend (for by distance only) Default: 1
        extendDirection | ed: (create, edit, query) - Which parametric direction of the surface to extend ( 0 - U, 1 - V, 2 - both ) Default: 0
        extendMethod | em: (create, edit, query) - The extend method (0 - distance) Default: 0
        extendSide | es: (create, edit, query) - Which end of the surface to extend ( 0 - end, 1 - start, 2 - both ) Default: 1
        extensionType | et: (create, edit, query) - The type of extension (0 - tangent, 2 - extrapolate) Default: 0
        join | jn: (create, edit, query) - Join extension to original Default: true
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def extrude(*args, caching: bool = ..., cch: bool = ..., degreeAlongLength: Optional[Union[int, bool]] = ..., dl: Optional[Union[int, bool]] = ..., direction: Optional[Union[Tuple[float, float, float], bool]] = ..., d: Optional[Union[Tuple[float, float, float], bool]] = ..., directionX: Optional[Union[float, bool]] = ..., dx: Optional[Union[float, bool]] = ..., directionY: Optional[Union[float, bool]] = ..., dy: Optional[Union[float, bool]] = ..., directionZ: Optional[Union[float, bool]] = ..., dz: Optional[Union[float, bool]] = ..., extrudeType: Optional[Union[int, bool]] = ..., et: Optional[Union[int, bool]] = ..., fixedPath: bool = ..., fpt: bool = ..., length: Optional[Union[float, bool]] = ..., l: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., pivot: Optional[Union[Tuple[float, float, float], bool]] = ..., p: Optional[Union[Tuple[float, float, float], bool]] = ..., reverseSurfaceIfPathReversed: bool = ..., rsp: bool = ..., rotation: Optional[Union[float, bool]] = ..., ro: Optional[Union[float, bool]] = ..., scale: Optional[Union[float, bool]] = ..., sc: Optional[Union[float, bool]] = ..., subCurveSubSurface: bool = ..., scs: bool = ..., useComponentPivot: Optional[Union[int, bool]] = ..., ucp: Optional[Union[int, bool]] = ..., useProfileNormal: bool = ..., upn: bool = ..., constructionHistory: bool = ..., ch: bool = ..., mergeItems: bool = ..., mi: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., range: bool = ..., rn: bool = ..., rebuild: bool = ..., rb: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command computes a surface given a profile curve and possibly
    a path curve. There are three ways to extrude a profile curve. The
    most basic method is called a "distance" extrude where direction and
    length are specified. No path curve is necessary in this case. The
    second method is called "flat" extrude. This method sweeps the profile
    curve down the path curve without changing the orientation of the
    profile curve. Finally, the third method is called "tube" extrude.
    This method sweeps a profile curve down a path curve while the
    profile curve rotates so that it maintains a relationship with the
    path curve.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        degreeAlongLength | dl: (create, edit, query) - Surface degree along the distance when a distance extrude is performed Default: 1
        direction | d: (create, edit, query) - The direction in which to extrude. Use only for distance extrudeType and useProfileNormal off
        directionX | dx: (create, edit, query) - X of the direction Default: 0
        directionY | dy: (create, edit, query) - Y of the direction Default: 1
        directionZ | dz: (create, edit, query) - Z of the direction Default: 0
        extrudeType | et: (create, edit, query) - The extrude type (distance-0, flat-1, or tube-2) Default: 2
        fixedPath | fpt: (create, edit, query) - If true, the resulting surface will be placed at the path curve. Otherwise, the resulting surface will be placed at the profile curve. Default: false
        length | l: (create, edit, query) - The distance to extrude. Use only for distance extrudeType Default: 1
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        pivot | p: (create, edit, query) - The pivot point used for tube extrudeType
        reverseSurfaceIfPathReversed | rsp: (create, edit, query) - If true, extrude type is tube (2) and path has been internally reversed then computed surface is reversed in the direction corresponding to the path. Default: false
        rotation | ro: (create, edit, query) - Amount to rotate the profile curve as it sweeps along the path curve. Default: 0.0
        scale | sc: (create, edit, query) - Amount to scale the profile curve as it sweeps along the path curve. Default: 1.0
        subCurveSubSurface | scs: (create, edit, query) - If true, curve range on the path will get applied to the resulting surface instead of cut before the extrude. Default: false
        useComponentPivot | ucp: (create, edit, query) - Use closest endpoint of the path - 0, component pivot - 1 or the center of the bounding box of the profile - 2 Default: 0
        useProfileNormal | upn: (create, edit, query) - If true, use the profile curve normal for the direction in which to extrude. Use only for distance or tube extrudeType. Default: false
        constructionHistory | ch: (create) - Turn the construction history on or off.
        mergeItems | mi: (create) - Merge component results where possible. For example, instead of returning a[1] and a[2], return a[1:2].
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
        range | rn: (create) - Force a curve range on complete input curve.
        rebuild | rb: (create) - Rebuild the input curve(s) before using them in the operation.  Use nurbsCurveRebuildPref to set the parameters for the conversion.
    """
    ...


def filletCurve(*args, bias: Optional[Union[float, bool]] = ..., b: Optional[Union[float, bool]] = ..., blendControl: bool = ..., bc: bool = ..., caching: bool = ..., cch: bool = ..., circular: bool = ..., cir: bool = ..., curveParameter1: Optional[Union[float, bool]] = ..., cp1: Optional[Union[float, bool]] = ..., curveParameter2: Optional[Union[float, bool]] = ..., cp2: Optional[Union[float, bool]] = ..., depth: Optional[Union[float, bool]] = ..., d: Optional[Union[float, bool]] = ..., freeformBlend: bool = ..., fb: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., join: bool = ..., jn: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., trim: bool = ..., t: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The curve fillet command creates a fillet curve between two curves.
    If no objects are specified in the command line, then the first two
    active curves are used. The fillet created can be circular (with
    a radius) or freeform (with a type of tangent or blend).

    Args:
        bias | b: (create, edit, query) - Adjusting the bias value causes the fillet curve to be skewed to one of the input curves. Available only if blendControl is true. Default: 0.0
        blendControl | bc: (create, edit, query) - If true then depth and bias can be controlled. Otherwise, depth and bias are not available options. Default: false
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        circular | cir: (create, edit, query) - Curve fillet will be created as circular if true or freeform if false. Default: true
        curveParameter1 | cp1: (create, edit, query) - Parameter where fillet curve will contact the primary input curve. Default: 0.0
        curveParameter2 | cp2: (create, edit, query) - Parameter where fillet curve will contact the secondary input curve. Default: 0.0
        depth | d: (create, edit, query) - Adjusts the depth of the fillet curve. Available only if blendControl is true. Default: 0.5
        freeformBlend | fb: (create, edit, query) - The freeform type is blend if true or tangent if false. Available if the fillet type is freeform. Default: false
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        radius | r: (create, edit, query) - The radius if creating a circular fillet. Default: 1.0
        constructionHistory | ch: (create) - Turn the construction history on or off.
        join | jn: (create) - Should the fillet be joined?
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
        trim | t: (create) - Should the fillet be trimmed?
    """
    ...


def filterExpand(*args, expand: bool = ..., ex: bool = ..., fullPath: bool = ..., fp: bool = ..., selectionMask: Optional[Union[int, bool]] = ..., sm: Optional[Union[int, bool]] = ..., symActive: bool = ..., sma: bool = ..., symNegative: bool = ..., smn: bool = ..., symPositive: bool = ..., smp: bool = ..., symSeam: bool = ..., sms: bool = ...) -> Any:
    r"""
    Based on selected components (or components specified on the command line),
    the command filters and/or expands the list given
    the options.
    Returns a string array containing all matching selection items.
    Selection masks are as follows:
    
    
    Object Type Mask 
     Handle                         0            
     Nurbs Curves                     9            
     Nurbs Surfaces                 10        
     Nurbs Curves    On Surface          11        
     Polygon                          12        
     Locator XYZ                     22        
     Orientation Locator             23        
     Locator UV                     24        
     Control Vertices (CVs)         28        
     Edit Points                     30        
     Polygon Vertices              31        
     Polygon Edges                 32        
     Polygon Face                     34        
     Polygon UVs                      35        
     Subdivision Mesh Points         36        
     Subdivision Mesh Edges         37        
     Subdivision Mesh Faces         38        
     Curve Parameter Points         39        
     Curve Knot                     40        
     Surface Parameter Points          41        
     Surface Knot                     42        
     Surface Range                 43        
     Trim Surface Edge             44        
     Surface Isoparms              45        
     Lattice Points                 46        
     Particles                     47        
     Scale Pivots                     49        
     Rotate Pivots                 50        
     Select Handles                 51        
     Subdivision Surface             68        
     Polygon Vertex Face              70        
     NURBS Surface Face              72        
     Subdivision Mesh UVs             73

    Args:
        expand | ex: (create) - Each item is a single entity if this is true.  Default is true.
        fullPath | fp: (create) - If this is true and the selection item is a DAG object, return its full selection path, instead of the name of the object only when this value is false.  Default is false.
        selectionMask | sm: (create, multiuse) - Specify the selection mask
        symActive | sma: (create) - If symmetry is enabled only return the components on the active symmetry side of the object. This flag has no effect if symmetry is not active.
        symNegative | smn: (create) - If symmetry is enabled only return the components on the negative side of the object relative to the current symmetry plane. This flag has no effect if symmetry is not active.
        symPositive | smp: (create) - If symmetry is enabled only return the components on the positive side of the object relative to the current symmetry plane. This flag has no effect if symmetry is not active.
        symSeam | sms: (create) - If symmetry is enabled only return the components that lie equally on both sides of the object relative to the current symmetry plane. This flag has no effect if symmetry is not active.
    """
    ...


def fitBspline(*args, caching: bool = ..., cch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The fitBspline command fits the CVs from an input curve
    and and returns a 3D curve.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        tolerance | tol: (create, edit, query) - Tolerance for the fit.  The resulting curve will be kept within tolerance of the given points. Default: 0.1
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
    """
    ...


def freeFormFillet(*args, bias: Optional[Union[float, bool]] = ..., b: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., depth: Optional[Union[float, bool]] = ..., d: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., positionTolerance: Optional[Union[float, bool]] = ..., pt: Optional[Union[float, bool]] = ..., tangentTolerance: Optional[Union[float, bool]] = ..., tt: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., range: bool = ..., rn: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command creates a free form surface fillet across two surface
    trim edges or isoparms or curve on surface. The fillet surface
    creation has blend controls in the form of bias and depth. The bias
    value scales the tangents at the two ends across the two selected
    curves. The depth values controls the curvature of the fillet across
    the two selected curves. The default values of depth, bias are 0.5
    and 0.5 respectively.

    Args:
        bias | b: (create, edit, query) - Bias value for fillet Default: 0.5
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        depth | d: (create, edit, query) - Depth value for fillet Default: 0.5
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        positionTolerance | pt: (create, edit, query) - C(0) Tolerance For Filleted Surface creation Default: 0.1
        tangentTolerance | tt: (create, edit, query) - G(1) continuity Tolerance For Filleted Surface creation Default: 0.1
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
        range | rn: (create) - Force a curve range on complete input curve.
    """
    ...


def geomToBBox(*args, bakeAnimation: bool = ..., ba: bool = ..., combineMesh: bool = ..., cm: bool = ..., endTime: Optional[Union[Union[float, Tuple[float, float]], bool]] = ..., et: Optional[Union[Union[float, Tuple[float, float]], bool]] = ..., keepOriginal: bool = ..., ko: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nameSuffix: Optional[Union[str, bool]] = ..., ns: Optional[Union[str, bool]] = ..., sampleBy: Optional[Union[Union[float, Tuple[float, float]], bool]] = ..., sb: Optional[Union[Union[float, Tuple[float, float]], bool]] = ..., shaderColor: Optional[Union[Tuple[float, float, float], bool]] = ..., sc: Optional[Union[Tuple[float, float, float], bool]] = ..., single: bool = ..., s: bool = ..., startTime: Optional[Union[Union[float, Tuple[float, float]], bool]] = ..., st: Optional[Union[Union[float, Tuple[float, float]], bool]] = ...) -> Any:
    r"""
    Create polygonal mesh bounding boxes for geometry.
    Can also create a single bounding box per hierarchy.

    Args:
        bakeAnimation | ba: (create) - Bake the animation. Can be used with startTime, endTime and sampleBy flags. If used alone, the time slider will be used to specify the startTime and endTime.
        combineMesh | cm: (create) - Combine resulting bounding boxes. Mutually exclusive with -s/single option.
        endTime | et: (create) - Used with bakeAnimation flag. Specifies the end time of the baking process.
        keepOriginal | ko: (create) - Do not remove the selected nodes used to create the bounding boxes.
        name | n: (create) - Specifies the bounding box name.
        nameSuffix | ns: (create) - Specifies the bounding box name suffix.
        sampleBy | sb: (create) - Used with bakeAnimation flag. Specifies the animation evaluation time increment.
        shaderColor | sc: (create) - Set the color attribute of the Lambert material associate with the bounding box. The RGB values should be defined between 0 to 1.0. Default value is 0.5 0.5 0.5.
        single | s: (create) - Create a single bounding box per hierarchy selected.
        startTime | st: (create) - Used with bakeAnimation flag. Specifies the start time of the baking process.
    """
    ...


def getMetadata(*args, dataType: bool = ..., dt: bool = ..., listChannelNames: bool = ..., lcn: bool = ..., listMemberNames: bool = ..., lmn: bool = ..., listStreamNames: bool = ..., lsn: bool = ..., memberName: Optional[Union[str, bool]] = ..., mn: Optional[Union[str, bool]] = ..., channelName: Optional[Union[str, bool]] = ..., cn: Optional[Union[str, bool]] = ..., channelType: Optional[Union[str, bool]] = ..., cht: Optional[Union[str, bool]] = ..., endIndex: Optional[Union[str, bool]] = ..., eix: Optional[Union[str, bool]] = ..., index: Optional[Union[str, bool]] = ..., idx: Optional[Union[str, bool]] = ..., indexType: Optional[Union[str, bool]] = ..., idt: Optional[Union[str, bool]] = ..., scene: bool = ..., scn: bool = ..., startIndex: Optional[Union[str, bool]] = ..., six: Optional[Union[str, bool]] = ..., streamName: Optional[Union[str, bool]] = ..., stn: Optional[Union[str, bool]] = ...) -> Any:
    r"""
    This command is used to retrieve the values of metadata elements from a node or scene.
    It is restricted to returning a single structure member at a time. For convenience
    the detail required is only enough to find a single Member of a single Structure
    on a single metadata Channel.
    
    
    In the simplest case if there is a single Stream on one metadata Channel
    which uses a Structure with only one Member then all that is required is the
    name of the object containing the metadata. In the most complex case the
    'channelName', 'streamName', and 'memberName' are all required to narrow down
    the metadata to a single unique Member.
    
    
    In general for scripting it's a good idea to use all flags anyway since there
    could be metadata added anywhere. The shortcuts are mainly for quick entry when
    entering commands directly in the script editor or command line.
    
    
    When an Index is specified where data is not present the command fails with a
    message telling you which Index or Indices didn't have values. Use the
    hasMetadata command first to determine where metadata exists if you
    need to know in advance where to find valid metadata.
    
    Filter Flags
    channelName - Only look for metadata on one particular Channel type
    streamName - Only look for metadata on one particular named Stream. When
    used in conjunction with channelName then ignore Streams with a matching
    name but a different Channel type
    index - Only look for metadata on one or more specific Index values of
    a Stream. Requires use of the streamName flag. Does not require the
    indexType flag as that will be inferred by the streamName.
    startIndex/endIndex - Same as index but using an entire range of
    Index values rather than a single one. Not valid for index types not supporting
    ranges (e.g. strings)
    indexType - Only look for metadata using a particular Index type. Can
    have its scope narrowed by other filter flags as well.
    memberName - The particular Member in the metadata in a Structure to
    retrieve. If this is not specified the Structure can only have a single Member.
    
    
    Metadata on meshes is special in that the Channel types "vertex",
    "edge", "face", and "vertexFace" are directly connected to the
    components of the same name. To make getting these metadata
    Channels easier you can simply select or specify on the command
    line the corresponding components rather than using the channelName
    and index/startIndex/endIndex flags. For
    example the selection "myMesh.vtx[8:10]" corresponds to
    channelName = vertex and either index = 8, 9, 10
    as a multi-use flag or setIndex = 8, endIndex=10.
    
    
    Only a single node or scene and unique metadata Structure Member are
    allowed in a single command. This keeps the data simple at the possible
    cost of requiring multiple calls to the command to get more than one
    Structure Member's value.
    
    
    When the data is returned it will be in Index order with an entire Member
    appearing together. For example if you were retrieving float[3] metadata on
    three components you would get the nine values back in the order:
    index[0]-float[0], index[0]-float[1], index[0]-float[2],
    index[1]-float[0], index[1]-float[1], index[1]-float[2],
    index[2]-float[0], index[2]-float[1], index[2]-float[2]. In the Python
    implementation the float[3] values will be an array each so you would
    get back three float[3] arrays.

    Args:
        dataType | dt: (create) - Used with the flag 'streamName' and 'memberName' to query the dataType of the specfied member.
        listChannelNames | lcn: (create) - Query the channel names on the shape. This flag can be used with some flags to filter the results. It can be used with the flag 'streamName' to get the channel with the specfied stream and the flag 'memberName' to get the channel in which the stream contains the specified member. It cannot be used with the flag 'channelName'.
        listMemberNames | lmn: (create) - Query the member names on the shape. This flag can be used with some flags to filter the results. It can be used with 'streamName' to get the member which is in the specified stream and the flag 'channelName' to get the member which is used in the specfied channel. It cannot be used with the flag 'memberName'.
        listStreamNames | lsn: (create) - Query the stream names on the shape. This flag can be used with some flags to filter the results. It can be used with the flag 'channelName' to get the stream names on the specified channel and the flag 'memberName' to get the stream names which has the specified member. It cannot be used with the flag 'streamName'.
        memberName | mn: (create) - Name of the Structure member being retrieved. The names of the members are set up in the Structure definition, either through the description passed in through the "dataStructure" command or via the API used to create that Structure. This flag is only necessary when selected Structures have more than one member.
        channelName | cn: (create, query) - Filter the metadata selection to only recognize metadata belonging to the specified named Channel (e.g. "vertex"). This flag is ignored if the components on the selection list are being used to specify the metadata of interest. 			In query mode, this flag can accept a value.
        channelType | cht: (create, query) - Obsolete - use the 'channelName' flag instead. 			In query mode, this flag can accept a value.
        endIndex | eix: (create) - The metadata is stored in a Stream, which is an indexed list. If you have mesh components selected then the metadata indices are implicit in the list of selected components. If you select only the node or scene then this flag may be used in conjunction with the startIndex flag to specify a range of indices from which to retrieve the metadata. It is an error to have the value of startIndex be greater than that of endIndex.   See also the index flag for an alternate way to specify multiple indices. This flag can only be used on index types that support a range (e.g. integer values - it makes no sense to request a range between two strings)  			In query mode, this flag can accept a value.
        index | idx: (create, multiuse, query) - In the typical case metadata is indexed using a simple integer value. Certain types of data may use other index types. e.g. a "vertexFace" component will use a "pair" index type, which is two integer values; one for the face ID of the component and the second for the vertex ID.   The index flag takes a string, formatted in the way the specified indexType requires. All uses of the index flag have the same indexType. If the type was not specified it is assumed to be a simple integer value.  			In query mode, this flag can accept a value.
        indexType | idt: (create, query) - Name of the index type the new Channel should be using. If not specified this defaults to a simple integer index. Of the native types only a mesh "vertexFace" channel is different, using a "pair" index type. 			In query mode, this flag can accept a value.
        scene | scn: (create, query) - Use this flag when you want to add metadata to the scene as a whole rather than to any individual nodes. If you use this flag and have nodes selected the nodes will be ignored and a warning will be displayed.
        startIndex | six: (create) - The metadata is stored in a Stream, which is an indexed list. If you have mesh components selected then the metadata indices are implicit in the list of selected components. If you select only the node or scene then this flag may be used in conjunction with the endIndex flag to specify a range of indices from which to retrieve the metadata. It is an error to have the value of startIndex be greater than that of endIndex.   See also the index flag for an alternate way to specify multiple indices. This flag can only be used on index types that support a range (e.g. integer values - it makes no sense to request a range between two strings)  			In query mode, this flag can accept a value.
        streamName | stn: (create, query) - Name of the metadata Stream. Depending on context it could be the name of a Stream to be created, or the name of the Stream to pass through the filter. 			In query mode, this flag can accept a value.
    """
    ...


def globalStitch(*args, caching: bool = ..., cch: bool = ..., lockSurface: bool = ..., lk: bool = ..., maxSeparation: Optional[Union[float, bool]] = ..., ms: Optional[Union[float, bool]] = ..., modificationResistance: Optional[Union[float, bool]] = ..., mr: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., sampling: Optional[Union[int, bool]] = ..., sam: Optional[Union[int, bool]] = ..., stitchCorners: Optional[Union[int, bool]] = ..., sc: Optional[Union[int, bool]] = ..., stitchEdges: Optional[Union[int, bool]] = ..., se: Optional[Union[int, bool]] = ..., stitchPartialEdges: bool = ..., spe: bool = ..., stitchSmoothness: Optional[Union[int, bool]] = ..., ss: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command computes a globalStitch of NURBS surfaces. There
    should be at least one  NURBS surface. The
    NURBS surface(s) should be untrimmed.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        lockSurface | lk: (create, edit, multiuse, query) - Keep the NURBS surface at the specified multi index unchanged by the fitting. Default: false
        maxSeparation | ms: (create, edit, query) - Maximum separation that will still be stitched. Default: 0.1
        modificationResistance | mr: (create, edit, query) - Modification resistance weight for surface CVs. Default: 1e-1
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        sampling | sam: (create, edit, query) - Sampling when stitching edges. Default: 1
        stitchCorners | sc: (create, edit, query) - Stitch corners of surfaces. 0 - off 1 - closest point 2 - closest knot Default: 1
        stitchEdges | se: (create, edit, query) - Stitch edges of surfaces. 0 - off 1 - closest point 2 - matching params Default: 1
        stitchPartialEdges | spe: (create, edit, query) - Toggle on (off) partial edge stitching. Default: false
        stitchSmoothness | ss: (create, edit, query) - Set type of smoothness of edge join. 0 - off 1 - tangent 2 - normal Default: 0
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
    """
    ...


def grid(*args, default: bool = ..., df: bool = ..., displayAxes: bool = ..., da: bool = ..., displayAxesBold: bool = ..., dab: bool = ..., displayDivisionLines: bool = ..., ddl: bool = ..., displayGridLines: bool = ..., dgl: bool = ..., displayOrthographicLabels: bool = ..., dol: bool = ..., displayPerspectiveLabels: bool = ..., dpl: bool = ..., divisions: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., orthographicLabelPosition: Optional[Union[str, bool]] = ..., olp: Optional[Union[str, bool]] = ..., perspectiveLabelPosition: Optional[Union[str, bool]] = ..., plp: Optional[Union[str, bool]] = ..., reset: bool = ..., r: bool = ..., size: Optional[Union[float, bool]] = ..., s: Optional[Union[float, bool]] = ..., spacing: Optional[Union[float, bool]] = ..., sp: Optional[Union[float, bool]] = ..., style: Optional[Union[int, bool]] = ..., st: Optional[Union[int, bool]] = ..., toggle: bool = ..., tgl: bool = ..., query: bool = ...) -> Any:
    r"""
    This command changes the size and spacing of lines on the ground
    plane displayed in the perspective and orthographic views.
    
    This command lets you reset the ground plane, change its size
    and grid line spacing, grid subdivisions and display options.

    Args:
        default | df: (query) - Used to specify/query default values.
        displayAxes | da: (query) - Specify true to display the grid axes.
        displayAxesBold | dab: (query) - Specify true to accent the grid axes by drawing them with a thicker line.
        displayDivisionLines | ddl: (query) - Specify true to display the subdivision lines between grid lines.
        displayGridLines | dgl: (query) - Specify true to display the grid lines.
        displayOrthographicLabels | dol: (query) - Specify true to display the grid line numeric labels in the orthographic views.
        displayPerspectiveLabels | dpl: (query) - Specify true to display the grid line numeric labels in the perspective view.
        divisions | d: (query) - Sets the number of subdivisions between major grid lines. The default is 10. If the spacing is 10 units, setting divisions to 10 will cause division lines to appear 1 unit apart.
        orthographicLabelPosition | olp: (query) - The position of the grid's numeric labels in orthographic views. Valid values are    "axis" and "edge".
        perspectiveLabelPosition | plp: (query) - The position of the grid's numeric labels in perspective views. Valid values are    "axis" and "edge".
        reset | r: () - Resets the ground plane to its default values
        size | s: (query) - Sets the size of the grid in linear units.  The default is 12 units.
        spacing | sp: (query) - Sets the spacing between major grid lines in linear units. The default is 10 units.
        style | st: (query) - This flag is obsolete and should not be used.
        toggle | tgl: (query) - Turns the ground plane display off in all windows, including orthographic windows.  Default is true.
    """
    ...


def hardenPointCurve(*args, caching: bool = ..., cch: bool = ..., multiplicity: Optional[Union[int, bool]] = ..., m: Optional[Union[int, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The hardenPointCurve command changes the knots of a curve given a list
    of control point indices so that the knot corresponding to that
    control point gets the specified multiplicity.  Multiplicity of -1 is
    the universal value used for multiplicity equal to the degree of
    the curve.
    
    limitations
    The CV whose multiplicity is being raised needs to have its
    neighbouring CVs of multiplicity 1.  How many neighbours depends on
    the degree of the curve and the difference in CV multiplicities before
    and after this operation.  For example, if you're changing a CV of
    multiplicity 1 into a CV of multiplicity 3, you will need the 4
    neighbouring CVs (2 on each side) to be of multiplicity 1.  The CVs
    that do not satisfy that requirement will be ignored.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        multiplicity | m: (create, edit, query) - the required multiplicity of the curve knot Default: -1
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def hasMetadata(*args, asList: bool = ..., al: bool = ..., ignoreDefault: bool = ..., id: bool = ..., memberName: Optional[Union[str, bool]] = ..., mn: Optional[Union[str, bool]] = ..., channelName: Optional[Union[str, bool]] = ..., cn: Optional[Union[str, bool]] = ..., channelType: Optional[Union[str, bool]] = ..., cht: Optional[Union[str, bool]] = ..., endIndex: Optional[Union[str, bool]] = ..., eix: Optional[Union[str, bool]] = ..., index: Optional[Union[str, bool]] = ..., idx: Optional[Union[str, bool]] = ..., indexType: Optional[Union[str, bool]] = ..., idt: Optional[Union[str, bool]] = ..., scene: bool = ..., scn: bool = ..., startIndex: Optional[Union[str, bool]] = ..., six: Optional[Union[str, bool]] = ..., streamName: Optional[Union[str, bool]] = ..., stn: Optional[Union[str, bool]] = ...) -> Any:
    r"""
    This command is used to query for the presence of metadata elements on a node,
    components, or scene. The command works at all levels of metadata presence, from
    the existence of any metadata at all on a node or scene right down to the presence
    of metadata values set on a particular metadata Stream index.
    
    Filter Flags
    channelName - Only look for metadata on one particular Channel type
    streamName - Only look for metadata on one particular named Stream. When
    used in conjunction with channelName then ignore Streams with a matching
    name but a different Channel type
    index - Only look for metadata on one or more specific Index values of
    a Stream. Requires use of the streamName flag. Does not require the
    indexType flag as that will be inferred by the streamName.
    startIndex/endIndex - Same as index but using an entire range of
    Index values rather than a single one
    indexType - Only look for metadata using a particular Index type. Can
    have its scope narrowed by other filter flags as well.
    ignoreDefault - Treat any metadata that still has the default value
    (e.g. 0 for numerics, "" for strings) the same as metadata that isn't present.
    This means that any metadata with default values will not be reported. It is
    useful for quickly finding values that you have changed. When this flag is
    set you can also use the memberName filter to narrow down the check to
    a particular member of the metadata Structure. Without that filter it will only
    skip over metadata where every member of the Structure has a non-default value.
    memberName - Only look at one particular Member in the metadata in a
    Structure. Only used when checking for non-default values as existence is based
    on the entire Structure, not any particular Member.
    
    Operation Flags
    normal mode - Return True for every specified location containing
    metadata. This combines with the filter flags as follows:
    no flag - True if there is any metadata at all on the node or scene
    channelName - True if there is any metadata at all on the Channel
            with the given name
    streamName - True if there is any metadata at all on the Stream
            with the given name
    index/startIndex/endIndex - An array of booleans ordered the same
            as the natural ordering of the Index values (i.e. specifying index 3, 2, and 4
            in that order will still return booleans in the order for indices 2,3,4)
            where True means that there is metadata assigned at that Index. This form is
            better suited with the asList modification since with that variation it
            is easier to tell exactly which indices have the metadata.
    
    
    asList - Adding this flag switches the return values from a single boolean
    or array of booleans to an array of strings indicating exactly which metadata elements
    have values. The return values of the command are changed to be the following:
    no flag - List of Channel names with metadata
    channelName - List of Stream names in the Channel with metadata
    streamName - List of Index values on the Stream with metadata
    index/startIndex/endIndex - List of Index values with metadata,
            restricted to the set of specified Index values.

    Args:
        asList | al: (create) - Use this flag when you want to return string values indicating where the metadata lives rather than boolean values. See the command description for more details on what this flag will return.
        ignoreDefault | id: (create) - Use this flag when you want to skip over any metadata that has only default values. i.e. the metadata may exist but it hasn't had a new value set yet (non-zero for numerics, non-empty strings, etc.) See the command description for more details on how this flag filters the search.
        memberName | mn: (create) - Name of the Structure member being checked. The names of the members are set up in the Structure definition, either through the description passed in through the "dataStructure" command or via the API used to create that Structure. As the assignment of metadata is on a per-structure basis this flag only needs to be specified when querying for non-default values. If you query for non-default values and omit this flag then it checks that any of the members have a non-default value.
        channelName | cn: (create, query) - Filter the metadata selection to only recognize metadata belonging to the specified named Channel (e.g. "vertex"). This flag is ignored if the components on the selection list are being used to specify the metadata of interest. 			In query mode, this flag can accept a value.
        channelType | cht: (create, query) - Obsolete - use the 'channelName' flag instead. 			In query mode, this flag can accept a value.
        endIndex | eix: (create) - The metadata is stored in a Stream, which is an indexed list. If you have mesh components selected then the metadata indices are implicit in the list of selected components. If you select only the node or scene then this flag may be used in conjunction with the startIndex flag to specify a range of indices from which to retrieve the metadata. It is an error to have the value of startIndex be greater than that of endIndex.   See also the index flag for an alternate way to specify multiple indices. This flag can only be used on index types that support a range (e.g. integer values - it makes no sense to request a range between two strings)  			In query mode, this flag can accept a value.
        index | idx: (create, multiuse, query) - In the typical case metadata is indexed using a simple integer value. Certain types of data may use other index types. e.g. a "vertexFace" component will use a "pair" index type, which is two integer values; one for the face ID of the component and the second for the vertex ID.   The index flag takes a string, formatted in the way the specified indexType requires. All uses of the index flag have the same indexType. If the type was not specified it is assumed to be a simple integer value.  			In query mode, this flag can accept a value.
        indexType | idt: (create, query) - Name of the index type the new Channel should be using. If not specified this defaults to a simple integer index. Of the native types only a mesh "vertexFace" channel is different, using a "pair" index type. 			In query mode, this flag can accept a value.
        scene | scn: (create, query) - Use this flag when you want to add metadata to the scene as a whole rather than to any individual nodes. If you use this flag and have nodes selected the nodes will be ignored and a warning will be displayed.
        startIndex | six: (create) - The metadata is stored in a Stream, which is an indexed list. If you have mesh components selected then the metadata indices are implicit in the list of selected components. If you select only the node or scene then this flag may be used in conjunction with the endIndex flag to specify a range of indices from which to retrieve the metadata. It is an error to have the value of startIndex be greater than that of endIndex.   See also the index flag for an alternate way to specify multiple indices. This flag can only be used on index types that support a range (e.g. integer values - it makes no sense to request a range between two strings)  			In query mode, this flag can accept a value.
        streamName | stn: (create, query) - Name of the metadata Stream. Depending on context it could be the name of a Stream to be created, or the name of the Stream to pass through the filter. 			In query mode, this flag can accept a value.
    """
    ...


def illustratorCurves(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., illustratorFilename: Optional[Union[str, bool]] = ..., ifn: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., tolerance: Optional[Union[float, bool]] = ..., tl: Optional[Union[float, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The illustratorCurves command creates NURBS curves from an input
    Adobe(R) Illustrator(R) file.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create) - Turn the construction history on or off.
        illustratorFilename | ifn: (create) - Input Adobe(R) Illustrator(R) file name.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        object | o: (create) - Create the result, or just the dependency node.
        tolerance | tl: (create, edit, query) - CVs on the output curve get snapped if the distance between two contiguous CVs are lesser than this tolerance value. Default: 0.001f
    """
    ...


def insertKnotCurve(*args, addKnots: bool = ..., add: bool = ..., caching: bool = ..., cch: bool = ..., insertBetween: bool = ..., ib: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., numberOfKnots: Optional[Union[int, bool]] = ..., nk: Optional[Union[int, bool]] = ..., parameter: Optional[Union[float, bool]] = ..., p: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., curveOnSurface: bool = ..., cos: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The insertKnotCurve command inserts knots into a curve given a list
    of parameter values. The number of knots to add at each parameter value
    and whether the knots are added or complemented can be specified.
    The name of the curve is returned.
    If construction history is on, the name of the resulting
    dependency node is also returned.
    
    An edit point will appear where you insert the knot. Also, the
    number of spans and CVs in the curve will increase in the area where
    the knot is inserted.
    
    You can insert up to "degree" knots at a
    curve parameter that isn't already an edit point. eg. for a
    degree three curve, you can insert up to 3 knots.
    
    Use this operation if you need more CVs in a local area of the curve.
    Use this operation (or "hardenPoint") if you want to create a corner
    in a curve.

    Args:
        addKnots | add: (create, edit, query) - Whether to add knots or complement.  Complement means knots will be added to reach the specified number of knots. Default: true
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        insertBetween | ib: (create, edit, query) - If set to true, and there is more than one parameter value specified, the knots will get inserted at equally spaced intervals between the given parameter values, rather than at the parameter values themselves. Default: false
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        numberOfKnots | nk: (create, edit, multiuse, query) - How many knots to insert.  At any point on the curve, there can be a maximum of "degree" knots. Default: 1
        parameter | p: (create, edit, multiuse, query) - Parameter value(s) where knots are added Default: 0.0
        constructionHistory | ch: (create) - Turn the construction history on or off.
        curveOnSurface | cos: (create) - If possible, create 2D curve as a result.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def insertKnotSurface(*args, addKnots: bool = ..., add: bool = ..., caching: bool = ..., cch: bool = ..., direction: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., insertBetween: bool = ..., ib: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., numberOfKnots: Optional[Union[int, bool]] = ..., nk: Optional[Union[int, bool]] = ..., parameter: Optional[Union[float, bool]] = ..., p: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The insertKnotSurface command inserts knots (aka isoparms) into a
    surface given a list of parameter values.  The number of knots
    to add at each parameter value
    and whether the knots are added or complemented can be specified.
    The name of the surface is returned and
    if history is on, the name of the resulting dependency node is
    also returned.
    
    You must specify one, none or all number of knots with the "-nk" flag.
    eg. if you specify none, then the default (one) knot will be added
    at each specified parameter value.  If you specify one "-nk" value
    then that number of knots will be added at each parameter value.
    Otherwise, you must specify the same number of "-nk" flags as "-p" flags,
    defining the number of knots to be added at each specified parameter value.
    
    You can insert up to "degree" knots at a
    parameter value that isn't already an isoparm.  eg. for a degree 3
    surface, you can insert up to 3 knots.
    
    Use this operation if you need more CVs in a local area of the surface.
    Use this operation if you want to create a corner in the surface.
    
    Note: A single insertKnotSurface command cannot insert in both directions
    at once; you must use two separate commands to do this.

    Args:
        addKnots | add: (create, edit, query) - Whether to add knots or complement.  Complement means knots will be added to reach the specified number of knots. Default: true
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        direction | d: (create, edit, query) - Direction in which to insert knot: 0 - V direction, 1 - U direction Default: 1
        insertBetween | ib: (create, edit, query) - If set to true, and there is more than one parameter value specified, the knots will get inserted at equally spaced intervals between the given parameter values, rather than at the parameter values themselves. Default: false
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        numberOfKnots | nk: (create, edit, multiuse, query) - How many knots to insert Default: 1
        parameter | p: (create, edit, multiuse, query) - Parameter value(s) where knots are added Default: 0.0
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def intersect(*args, caching: bool = ..., cch: bool = ..., firstSurface: bool = ..., fs: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., curveOnSurface: bool = ..., cos: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The intersect command creates a curve on surface where all surfaces
    intersect with each other. By default, the curve on surface is created
    for both surfaces. However, by using the -fs flag, only the first
    surface will have a curve on surface. Also, the intersection curve
    can be created as a 3D curve rather than a curve on surface.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        firstSurface | fs: (edit, query) - Creates a curve-on-surface on the first surface only or on all surfaces (default).
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        tolerance | tol: (create, edit, query) - Tolerance to fit to. Default: 0.01
        constructionHistory | ch: (create) - Turn the construction history on or off.
        curveOnSurface | cos: (create) - If possible, create 2D curve as a result.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
    """
    ...


def loft(*args, autoReverse: bool = ..., ar: bool = ..., caching: bool = ..., cch: bool = ..., close: bool = ..., c: bool = ..., createCusp: bool = ..., cc: bool = ..., degree: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., reverse: bool = ..., r: bool = ..., reverseSurfaceNormals: bool = ..., rsn: bool = ..., sectionSpans: Optional[Union[int, bool]] = ..., ss: Optional[Union[int, bool]] = ..., uniform: bool = ..., u: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., range: bool = ..., rn: bool = ..., rebuild: bool = ..., rb: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command computes a skinned (lofted) surface passing through
    a number of NURBS curves. There must be at least two curves
    present. The NURBS curves may be surface isoparms, curve on
    surfaces, trimmed edges or polygon edges.

    Args:
        autoReverse | ar: (create, edit, query) - If set to true, the direction of the curves for the loft is computed automatically.  If set to false, the values of the multi-use reverse flag are used instead. Default: true
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        close | c: (create, edit, query) - If set to true, the resulting surface will be closed (periodic) with the start (end) at the first curve.  If set to false, the surface will remain open. Default: false
        createCusp | cc: (create, edit, multiuse, query) - Multi-use flag; each occurence of the flag refers to the matching curve in the loft operation; if the flag is set the particular profile will have a cusp (tangent break) in the resulting surface. Default: false
        degree | d: (create, edit, query) - The degree of the resulting surface Default: 3
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        reverse | r: (create, edit, multiuse, query) - Multi-use flag; each occurence of the flag refers to the matching curve in the loft operation; if the flag is set the particular curve will be reversed before being used in the loft operation. Default: false
        reverseSurfaceNormals | rsn: (create, edit, query) - If set, the surface normals on the output NURBS surface will be reversed.  This is accomplished by swapping the U and V parametric directions. Default: false
        sectionSpans | ss: (create, edit, query) - The number of surface spans between consecutive curves in the loft. Default: 1
        uniform | u: (create, edit, query) - If set to true, the resulting surface will have uniform parameterization in the loft direction.  If set to false, the parameterization will be chord length. Default: false
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
        range | rn: (create) - Force a curve range on complete input curve.
        rebuild | rb: (create) - Rebuild the input curve(s) before using them in the operation.  Use nurbsCurveRebuildPref to set the parameters for the conversion.
    """
    ...


def makeSingleSurface(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., stitchTolerance: float = ..., st: float = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command performs a stitch and tessellate operation.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        object | o: (create) - Create the result, or just the dependency node.
        stitchTolerance | st: (edit) - Stitch tolerance. Default: 0.1
    """
    ...


def manipOptions(*args, enableSmartDuplicate: bool = ..., esd: bool = ..., enableSmartExtrude: bool = ..., ese: bool = ..., forceRefresh: bool = ..., fr: bool = ..., handleSize: Optional[Union[float, bool]] = ..., hs: Optional[Union[float, bool]] = ..., hideManipOnCtrl: bool = ..., hmc: bool = ..., hideManipOnShift: bool = ..., hms: bool = ..., hideManipOnShiftCtrl: bool = ..., hsc: bool = ..., linePick: Optional[Union[float, bool]] = ..., lp: Optional[Union[float, bool]] = ..., lineSize: Optional[Union[float, bool]] = ..., ls: Optional[Union[float, bool]] = ..., middleMouseRepositioning: bool = ..., mm: bool = ..., pivotRotateHandleOffset: Optional[Union[int, bool]] = ..., pro: Optional[Union[int, bool]] = ..., planeHandleOffset: Optional[Union[int, bool]] = ..., pho: Optional[Union[int, bool]] = ..., pointSize: Optional[Union[float, bool]] = ..., ps: Optional[Union[float, bool]] = ..., preselectHighlight: bool = ..., psh: bool = ..., refreshMode: Optional[Union[int, bool]] = ..., rm: Optional[Union[int, bool]] = ..., relative: bool = ..., r: bool = ..., rememberActiveHandle: bool = ..., rah: bool = ..., rememberActiveHandleAfterToolSwitch: bool = ..., rhs: bool = ..., scale: Optional[Union[float, bool]] = ..., s: Optional[Union[float, bool]] = ..., showExtrudeSliders: bool = ..., ses: bool = ..., showPivotRotateHandle: bool = ..., spr: bool = ..., showPlaneHandles: bool = ..., sph: bool = ..., smartDuplicateType: Optional[Union[int, bool]] = ..., sdt: Optional[Union[int, bool]] = ..., query: bool = ...) -> Any:
    r"""
    Changes the global manipulator parameters

    Args:
        enableSmartDuplicate | esd: (create, query) - Enables Shift-Duplicate option on t/r/s manips.
        enableSmartExtrude | ese: (create, query) - Enables Shift-Extrude option on t/r/s manips.
        forceRefresh | fr: (create) - Force a refresh if there is any deferred evaluation.
        handleSize | hs: (create, query) - Sets the maximum handles size in pixels, for small handles
        hideManipOnCtrl | hmc: (create, query) - Hide transform manip when the Ctrl key is pressed.
        hideManipOnShift | hms: (create, query) - Hide transform manip when the Shift key is pressed.
        hideManipOnShiftCtrl | hsc: (create, query) - Hide transform manip when the Shift and Ctrl keys are both pressed.
        linePick | lp: (create, query) - Set the width of picking zone for long handles
        lineSize | ls: (create, query) - Set the width of long handles (drawn as lines)
        middleMouseRepositioning | mm: (create, query) - Specify if the middle mouse should reposition
        pivotRotateHandleOffset | pro: (create, query) - Set the offset of the pivot rotation handle.
        planeHandleOffset | pho: (create, query) - Set the offset of the planar drag handles.
        pointSize | ps: (create, query) - Set the size of points (used to display previous states)
        preselectHighlight | psh: (create, query) - Set whether manip handles should be highlighted when moving mouse.
        refreshMode | rm: (create, query) - Set the global refresh mode.
        relative | r: (create) - All values are interpreted as multiplication factors instead of final values.
        rememberActiveHandle | rah: (create, query) - Set whether manip handles should be remembered after selection change.
        rememberActiveHandleAfterToolSwitch | rhs: (create, query) - Set whether manip handles should be remembered after manipulator change.
        scale | s: (create, query) - Global scaling factor of all manipulators
        showExtrudeSliders | ses: (create, query) - Specify if the extrude sliders are to be shown on the manip
        showPivotRotateHandle | spr: (create, query) - Toggles the visibility of the pivot rotation handle.
        showPlaneHandles | sph: (create, query) - Toggles the visibility of the planar drag handles.
        smartDuplicateType | sdt: (create, query) - Change Shift-Duplicate or Shift-Extrude between Copy and Instance on t/r/s manips.
    """
    ...


def manipPivot(*args, bakeOri: bool = ..., bo: bool = ..., moveToolOri: Optional[Union[int, bool]] = ..., mto: Optional[Union[int, bool]] = ..., ori: Optional[Union[Tuple[float, float, float], bool]] = ..., o: Optional[Union[Tuple[float, float, float], bool]] = ..., oriValid: bool = ..., ov: bool = ..., pinPivot: bool = ..., pin: bool = ..., pos: Optional[Union[Tuple[float, float, float], bool]] = ..., p: Optional[Union[Tuple[float, float, float], bool]] = ..., posValid: bool = ..., pv: bool = ..., reset: bool = ..., r: bool = ..., resetOri: bool = ..., ro: bool = ..., resetPos: bool = ..., rp: bool = ..., rotateToolOri: Optional[Union[int, bool]] = ..., rto: Optional[Union[int, bool]] = ..., scaleToolOri: Optional[Union[int, bool]] = ..., sto: Optional[Union[int, bool]] = ..., snapOri: bool = ..., so: bool = ..., snapPos: bool = ..., sp: bool = ..., valid: bool = ..., v: bool = ..., query: bool = ...) -> Any:
    r"""
    Changes transform component pivot used by the move/rotate/scale manipulators.

    Args:
        bakeOri | bo: (create, query) - Bake pivot orientation. Automatically bake pivot orientation changes into the transform hierarchy / geometry.
        moveToolOri | mto: (create) - Change move tool's axis orientation to the specified mode. This flag is the same as using "manipMoveContext -e -mode" on the Move tool except that this command is undoable.
        ori | o: (create, query) - Component pivot orientation in world-space.
        oriValid | ov: (query) - Returns true if component pivot orientation is valid.
        pinPivot | pin: (create, query) - Pin component pivot. Selection changes will not reset the pivot position/orientation when a custom pivot is set and pinning is on.
        pos | p: (create, query) - Component pivot position in world-space.
        posValid | pv: (query) - Returns true if component pivot position is valid.
        reset | r: (create) - Clear the saved component pivot position and orientation.
        resetOri | ro: (create) - Clear the saved component pivot orientation.
        resetPos | rp: (create) - Clear the saved component pivot position.
        rotateToolOri | rto: (create) - Change rotate tool's axis orientation to the specified mode. This flag is the same as using "manipRotateContext -e -mode" on the Rotate tool except that this command is undoable.
        scaleToolOri | sto: (create) - Change scale tool's axis orientation to the specified mode. This flag is the same as using "manipScaleContext -e -mode" on the Scale tool except that this command is undoable.
        snapOri | so: (create, query) - Snap pivot orientation. Modify pivot orientation when snapping the pivot to a component.
        snapPos | sp: (create, query) - Snap pivot position. Modify pivot position when snapping the pivot to a component.
        valid | v: (query) - Returns true if component pivot position or orientation is valid.
    """
    ...


def moveVertexAlongDirection(*args, direction: Optional[Union[Tuple[float, float, float], bool]] = ..., d: Optional[Union[Tuple[float, float, float], bool]] = ..., magnitude: Optional[Union[float, bool]] = ..., m: Optional[Union[float, bool]] = ..., normalDirection: Optional[Union[float, bool]] = ..., n: Optional[Union[float, bool]] = ..., uDirection: Optional[Union[float, bool]] = ..., u: Optional[Union[float, bool]] = ..., uvNormalDirection: Optional[Union[Tuple[float, float, float], bool]] = ..., uvn: Optional[Union[Tuple[float, float, float], bool]] = ..., vDirection: Optional[Union[float, bool]] = ..., v: Optional[Union[float, bool]] = ...) -> Any:
    r"""
    The command moves the selected vertex ( control vertex ) in
    the specified unit direction by the given magnitude. The vertex(ices)
    may also be moved in the direction of unit normal ( -n flag ).
    For NURBS surface vertices the direction of movement could also
    be either in tangent along U or tangent along V.  The flags -n,
    -u, -v and -d are mutually exclusive, ie. the selected vertices
    can be all moved in only -n or -u or -v or -d.

    Args:
        direction | d: (create, multiuse) - move the vertex along the direction as specified. The direction is normalized.
        magnitude | m: (create, multiuse) - move by the specified magnitude in the direction vector.
        normalDirection | n: (create, multiuse) - move components in the direction of normal by the given magnitude at the respective components. The normal is 'normalized'.
        uDirection | u: (create, multiuse) - move components in the direction of tangent along U at the respective components where appropriate. The flag is ignored for polygons, NURBS curves. The u direction is normalized.
        uvNormalDirection | uvn: (create, multiuse) - move in the triad space [u,v,n] at the respective components by the specified displacements. The flag is ignored for polygons, NURBS curves.
        vDirection | v: (create, multiuse) - move components in the direction of tangent along V at the respective components where appropriate. The flag is ignored for polygons, NURBS curves.
    """
    ...


def multiProfileBirailSurface(*args, caching: bool = ..., cch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., tangentContinuityProfile1: bool = ..., tp1: bool = ..., tangentContinuityProfile2: bool = ..., tp2: bool = ..., transformMode: Optional[Union[int, bool]] = ..., tm: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The cmd creates a railed surface by sweeping the profiles using two
    rail curves. The two rails are the last two arguments. For examples,
    if 5 curves are specified, they will correspond to "curve1" "curve2"
    "curve3" "rail1" "rail2".
    
    In this case, the cmd creates a railed surface by sweeping the profile
    "curve1" to profile "curve2", profile "curve2" to profile "curve3"
    along the two rail curves "rail1", "rail2". There must be atleast 3
    profile curves followed by the two rail curves. The profile curves
    must intersect the two rail curves. The constructed may be made
    tangent continuous to the first and last profile using the flags -tp1,
    -tp2 provided the profiles are surface curves i.e. isoparms, curve on
    surface or trimmed edge.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        tangentContinuityProfile1 | tp1: (create, edit, query) - Tangent continuous across the first profile. The profile must be a surface curve. Default: false
        tangentContinuityProfile2 | tp2: (create, edit, query) - Tangent continuous across the last profile. The profile must be a surface curve. Default: false
        transformMode | tm: (create, edit, query) - transform mode ( Non proportional, proportional ). Non proportional is default value. Default: 0
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
    """
    ...


def nurbsBoolean(*args, caching: bool = ..., cch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., operation: Optional[Union[int, bool]] = ..., op: Optional[Union[int, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tlb: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nsrfsInFirstShell: Optional[Union[int, bool]] = ..., nsf: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., smartConnection: bool = ..., sc: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command performs a boolean operation.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        operation | op: (create, edit, query) - Type of Boolean operation. Default: 0
        tolerance | tlb: (create, edit, query) - fitting tolerance. Default: 0.01
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nsrfsInFirstShell | nsf: (create) - The number of selection items comprising the first shell.
        object | o: (create) - Create the result, or just the dependency node.
        smartConnection | sc: (create) - Look for any of the selection items having a boolean operation as history. Default is true.
    """
    ...


def nurbsCopyUVSet(*args, edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This is only a sample command for debugging purposes,
    which makes a copy of the implicit st parameterization
    on a nurbs surface to be the 1st explicit uvset.

    Args:
    """
    ...


def nurbsCube(*args, axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., caching: bool = ..., cch: bool = ..., degree: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., heightRatio: Optional[Union[float, bool]] = ..., hr: Optional[Union[float, bool]] = ..., lengthRatio: Optional[Union[float, bool]] = ..., lr: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., patchesU: Optional[Union[int, bool]] = ..., u: Optional[Union[int, bool]] = ..., patchesV: Optional[Union[int, bool]] = ..., v: Optional[Union[int, bool]] = ..., pivot: Optional[Union[Tuple[float, float, float], bool]] = ..., p: Optional[Union[Tuple[float, float, float], bool]] = ..., width: Optional[Union[float, bool]] = ..., w: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The nurbsCube command creates a new NURBS Cube made up of six
    planes. It creates an unit cube with center at origin by default.

    Args:
        axis | ax: (create, edit, query) - The primitive's axis
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        degree | d: (create, edit, query) - The degree of the resulting surface. 1 - linear, 2 - quadratic, 3 - cubic, 5 - quintic, 7 - heptic Default: 3
        heightRatio | hr: (create, edit, query) - Ratio of "height" to "width" Default: 1.0
        lengthRatio | lr: (create, edit, query) - Ratio of "length" to "width" Default: 1.0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        patchesU | u: (create, edit, query) - Number of sections in U Default: 1
        patchesV | v: (create, edit, query) - Number of sections in V Default: 1
        pivot | p: (create, edit, query) - The primitive's pivot point
        width | w: (create, edit, query) - Width of the object Default: 1.0
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
    """
    ...


def nurbsCurveToBezier(*args) -> Any:
    r"""
    The nurbsCurveToBezier command attempts to convert an existing NURBS curve
    to a Bezier curve.

    Args:
    """
    ...


def nurbsEditUV(*args, angle: Optional[Union[float, bool]] = ..., a: Optional[Union[float, bool]] = ..., pivotU: Optional[Union[float, bool]] = ..., pu: Optional[Union[float, bool]] = ..., pivotV: Optional[Union[float, bool]] = ..., pv: Optional[Union[float, bool]] = ..., relative: bool = ..., r: bool = ..., rotateRatio: Optional[Union[float, bool]] = ..., rr: Optional[Union[float, bool]] = ..., rotation: bool = ..., rot: bool = ..., scale: bool = ..., s: bool = ..., scaleU: Optional[Union[float, bool]] = ..., su: Optional[Union[float, bool]] = ..., scaleV: Optional[Union[float, bool]] = ..., sv: Optional[Union[float, bool]] = ..., uValue: Optional[Union[float, bool]] = ..., u: Optional[Union[float, bool]] = ..., vValue: Optional[Union[float, bool]] = ..., v: Optional[Union[float, bool]] = ..., query: bool = ...) -> Any:
    r"""
    Command Edits UVs on NURBS objects. When used with the query flag, it
    returns the UV values associated with the specified components.

    Args:
        angle | a: (create, query) - Specifies the angle value (in degrees) by which the UV values are to be rotated.
        pivotU | pu: (create, query) - Specifies the pivot value, in the u direction, about which the scale or rotate is to be performed.
        pivotV | pv: (create, query) - Specifies the pivot value, in the v direction, about which the scale or rotate is to be performed.
        relative | r: (create, query) - Specifies whether this command is editing the values relative to the currently existing values. Default is true;
        rotateRatio | rr: (create, query) - Specifies the ratio value by which the UV values are to be rotated. Default is 1.0
        rotation | rot: (create, query) - Specifies whether this command is editing the values with rotation values
        scale | s: (create, query) - Specifies whether this command is editing the values with scale values
        scaleU | su: (create, query) - Specifies the scale value in the u direction.
        scaleV | sv: (create, query) - Specifies the scale value in the v direction.
        uValue | u: (create, query) - Specifies the value, in the u direction - absolute if relative flag is false..
        vValue | v: (create, query) - Specifies the value, in the v direction - absolute if relative flag is false..
    """
    ...


def nurbsPlane(*args, axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., caching: bool = ..., cch: bool = ..., degree: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., lengthRatio: Optional[Union[float, bool]] = ..., lr: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., patchesU: Optional[Union[int, bool]] = ..., u: Optional[Union[int, bool]] = ..., patchesV: Optional[Union[int, bool]] = ..., v: Optional[Union[int, bool]] = ..., pivot: Optional[Union[Tuple[float, float, float], bool]] = ..., p: Optional[Union[Tuple[float, float, float], bool]] = ..., width: Optional[Union[float, bool]] = ..., w: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The nurbsPlane command creates a new NURBS Plane and return the name
    of the new surface. It creates an unit plane with center at origin by
    default.

    Args:
        axis | ax: (create, edit, query) - The primitive's axis
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        degree | d: (create, edit, query) - The degree of the resulting surface 1 - linear, 2 - quadratic, 3 - cubic, 5 - quintic, 7 - heptic Default: 3
        lengthRatio | lr: (create, edit, query) - The ratio of "length" to "width" of the plane. Default: 1.0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        patchesU | u: (create, edit, query) - The number of spans in the U direction. Default: 1
        patchesV | v: (create, edit, query) - The number of spans in the V direction. Default: 1
        pivot | p: (create, edit, query) - The primitive's pivot point
        width | w: (create, edit, query) - The width of the plane Default: 1.0
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
    """
    ...


def nurbsSelect(*args, borderSelection: bool = ..., bs: bool = ..., bottomBorder: bool = ..., bb: bool = ..., growSelection: Optional[Union[int, bool]] = ..., gs: Optional[Union[int, bool]] = ..., leftBorder: bool = ..., lb: bool = ..., rightBorder: bool = ..., rb: bool = ..., shrinkSelection: Optional[Union[int, bool]] = ..., ss: Optional[Union[int, bool]] = ..., topBorder: bool = ..., tb: bool = ...) -> Any:
    r"""
    Performs selection operations on NURBS objects.
    If any of the border flags is set, then the appropriate borders are
    selected. Otherwise the current CV selection is used, or all CVs if
    the surfaces is selected as an object.
    The growSelection, shrinkSelection, borderSelection flags are then applied
    in that order.
    In practice, it is recommended to use one flag at a time, except for
    the border flags.

    Args:
        borderSelection | bs: (create) - Extract the border of the current CV selection.
        bottomBorder | bb: (create) - Selects the bottom border of the surface (V=0).
        growSelection | gs: (create) - Grows the CV selection by the given number of CV
        leftBorder | lb: (create) - Selects the left border of the surface (U=0).
        rightBorder | rb: (create) - Selects the right border of the surface (U=MAX).
        shrinkSelection | ss: (create) - Shrinks the CV selection by the given number of CV
        topBorder | tb: (create) - Selects the top border of the patches (V=MAX).
    """
    ...


def nurbsSquare(*args, caching: bool = ..., cch: bool = ..., center: Optional[Union[Tuple[float, float, float], bool]] = ..., c: Optional[Union[Tuple[float, float, float], bool]] = ..., centerX: Optional[Union[float, bool]] = ..., cx: Optional[Union[float, bool]] = ..., centerY: Optional[Union[float, bool]] = ..., cy: Optional[Union[float, bool]] = ..., centerZ: Optional[Union[float, bool]] = ..., cz: Optional[Union[float, bool]] = ..., degree: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., normal: Optional[Union[Tuple[float, float, float], bool]] = ..., nr: Optional[Union[Tuple[float, float, float], bool]] = ..., normalX: Optional[Union[float, bool]] = ..., nrx: Optional[Union[float, bool]] = ..., normalY: Optional[Union[float, bool]] = ..., nry: Optional[Union[float, bool]] = ..., normalZ: Optional[Union[float, bool]] = ..., nrz: Optional[Union[float, bool]] = ..., sideLength1: Optional[Union[float, bool]] = ..., sl1: Optional[Union[float, bool]] = ..., sideLength2: Optional[Union[float, bool]] = ..., sl2: Optional[Union[float, bool]] = ..., spansPerSide: Optional[Union[int, bool]] = ..., sps: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The nurbsSquare command creates a square

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        center | c: (create, edit, query) - The center point of the square.
        centerX | cx: (create, edit, query) - X of the center point. Default: 0
        centerY | cy: (create, edit, query) - Y of the center point. Default: 0
        centerZ | cz: (create, edit, query) - Z of the center point. Default: 0
        degree | d: (create, edit, query) - The degree of the resulting circle: 1 - linear, 2 - quadratic, 3 - cubic, 5 - quintic, 7 - heptic Default: 3
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        normal | nr: (create, edit, query) - The normal of the plane in which the square will lie.
        normalX | nrx: (create, edit, query) - X of the normal direction. Default: 0
        normalY | nry: (create, edit, query) - Y of the normal direction. Default: 0
        normalZ | nrz: (create, edit, query) - Z of the normal direction. Default: 1
        sideLength1 | sl1: (create, edit, query) - The length of a side on the square. Default: 1.0
        sideLength2 | sl2: (create, edit, query) - The length of an adjacent side on the square. Default: 1.0
        spansPerSide | sps: (create, edit, query) - The number of spans per side determines the resolution of the square. Default: 1
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
    """
    ...


def nurbsToPoly(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., curvatureTolerance: Optional[Union[int, bool]] = ..., cvt: Optional[Union[int, bool]] = ..., explicitTessellationAttributes: bool = ..., eta: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., smoothEdge: bool = ..., ues: bool = ..., smoothEdgeRatio: Optional[Union[float, bool]] = ..., esr: Optional[Union[float, bool]] = ..., uDivisionsFactor: Optional[Union[float, bool]] = ..., nuf: Optional[Union[float, bool]] = ..., vDivisionsFactor: Optional[Union[float, bool]] = ..., nvf: Optional[Union[float, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command tesselates a NURBS surface and produces a polygonal surface.
    The name of the new polygonal surface is returned.
    If construction history is ON, then the name of the new dependency
    node is returned as well.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create) - Turn the construction history on or off.
        curvatureTolerance | cvt: (create, edit, query) - Presets for level of secondary criteria curvature tolerance: 0 = highest tolerance, 1 = high tolerance, 2 = medium tolerance, 3 = no tolerance Default: 2
        explicitTessellationAttributes | eta: (create, edit, query) - specify advanced or novice mode for tessellation parameters Default: true
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        object | o: (create) - Create the result, or just the dependency node.
        smoothEdge | ues: (create, edit, query) - Specifies if the decision to continue tessellation should be based on the nurbs edge smoothness Default: false
        smoothEdgeRatio | esr: (create, edit, query) - Specifies the edge smooth ratio.  The higher the value, the smoother the edge will be. Default: 0.99
        uDivisionsFactor | nuf: (create, edit, query) - Specifies the tessellation increase factor in U for novice mode Default: 1.5
        vDivisionsFactor | nvf: (create, edit, query) - Specifies the tessellation increase factor in V for novice mode Default: 1.5
    """
    ...


def nurbsToPolygonsPref(*args, chordHeight: Optional[Union[float, bool]] = ..., cht: Optional[Union[float, bool]] = ..., chordHeightRatio: Optional[Union[float, bool]] = ..., chr: Optional[Union[float, bool]] = ..., delta3D: Optional[Union[float, bool]] = ..., d: Optional[Union[float, bool]] = ..., edgeSwap: bool = ..., es: bool = ..., format: Optional[Union[int, bool]] = ..., f: Optional[Union[int, bool]] = ..., fraction: Optional[Union[float, bool]] = ..., ft: Optional[Union[float, bool]] = ..., matchRenderTessellation: Optional[Union[int, bool]] = ..., mrt: Optional[Union[int, bool]] = ..., merge: Optional[Union[int, bool]] = ..., m: Optional[Union[int, bool]] = ..., mergeTolerance: Optional[Union[float, bool]] = ..., mt: Optional[Union[float, bool]] = ..., minEdgeLen: Optional[Union[float, bool]] = ..., mel: Optional[Union[float, bool]] = ..., polyCount: Optional[Union[int, bool]] = ..., pc: Optional[Union[int, bool]] = ..., polyType: Optional[Union[int, bool]] = ..., pt: Optional[Union[int, bool]] = ..., uNumber: Optional[Union[int, bool]] = ..., un: Optional[Union[int, bool]] = ..., uType: Optional[Union[int, bool]] = ..., ut: Optional[Union[int, bool]] = ..., useChordHeight: bool = ..., uch: bool = ..., useChordHeightRatio: bool = ..., ucr: bool = ..., vNumber: Optional[Union[int, bool]] = ..., vn: Optional[Union[int, bool]] = ..., vType: Optional[Union[int, bool]] = ..., vt: Optional[Union[int, bool]] = ..., query: bool = ...) -> Any:
    r"""
    This command sets the values used by the nurbs-to-polygons
    (or "tesselate") preference.  This preference is used by
    Maya menu items and is saved between Maya sessions.
    To query any of the flags, use the "-query" flag.
    For more information on the flags, see the node documentation for
    the "nurbsTessellate" node.

    Args:
        chordHeight | cht: (create, query) - 
        chordHeightRatio | chr: (create, query) - 
        delta3D | d: (create, query) - 
        edgeSwap | es: (create, query) - 
        format | f: (create, query) - Valid values are 0, 1 and 2.
        fraction | ft: (create, query) - 
        matchRenderTessellation | mrt: (create, query) - 
        merge | m: (create, query) - 
        mergeTolerance | mt: (create, query) - 
        minEdgeLen | mel: (create, query) - 
        polyCount | pc: (create, query) - 
        polyType | pt: (create, query) - 
        uNumber | un: (create, query) - 
        uType | ut: (create, query) - 
        useChordHeight | uch: (create, query) - 
        useChordHeightRatio | ucr: (create, query) - 
        vNumber | vn: (create, query) - 
        vType | vt: (create, query) - 
    """
    ...


def nurbsToSubdiv(*args, addUnderTransform: bool = ..., aut: bool = ..., caching: bool = ..., cch: bool = ..., collapsePoles: bool = ..., cp: bool = ..., constructionHistory: bool = ..., ch: bool = ..., matchPeriodic: bool = ..., mp: bool = ..., maxPolyCount: Optional[Union[int, bool]] = ..., mpc: Optional[Union[int, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., reverseNormal: bool = ..., rn: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command converts a NURBS surface and produces a subd surface.
    The name of the new subdivision surface is returned.
    If construction history is ON, then the name of the new dependency
    node is returned as well.

    Args:
        addUnderTransform | aut: (create, edit, query) - Specify whether the new surface should be added under the old transform or not.
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        collapsePoles | cp: (create, edit, query) - Collapse poles into a single point Default: false
        constructionHistory | ch: (create) - Turn the construction history on or off.
        matchPeriodic | mp: (create, edit, query) - Match periodic surface texture mapping in the result. Default: false
        maxPolyCount | mpc: (create, edit, query) - The maximum number of base mesh faces in the resulting subdivision surface. Default: 1000
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        object | o: (create) - Create the result, or just the dependency node.
        reverseNormal | rn: (create, edit, query) - Reverse the NURBS surface normal in the conversion. Default: true
    """
    ...


def nurbsToSubdivPref(*args, bridge: Optional[Union[int, bool]] = ..., br: Optional[Union[int, bool]] = ..., capType: Optional[Union[int, bool]] = ..., ct: Optional[Union[int, bool]] = ..., collapsePoles: bool = ..., cp: bool = ..., matchPeriodic: bool = ..., mp: bool = ..., maxPolyCount: Optional[Union[int, bool]] = ..., mpc: Optional[Union[int, bool]] = ..., offset: Optional[Union[float, bool]] = ..., o: Optional[Union[float, bool]] = ..., reverseNormal: bool = ..., rn: bool = ..., solidType: Optional[Union[int, bool]] = ..., st: Optional[Union[int, bool]] = ..., trans00: Optional[Union[float, bool]] = ..., t00: Optional[Union[float, bool]] = ..., trans01: Optional[Union[float, bool]] = ..., t01: Optional[Union[float, bool]] = ..., trans02: Optional[Union[float, bool]] = ..., t02: Optional[Union[float, bool]] = ..., trans10: Optional[Union[float, bool]] = ..., t10: Optional[Union[float, bool]] = ..., trans11: Optional[Union[float, bool]] = ..., t11: Optional[Union[float, bool]] = ..., trans12: Optional[Union[float, bool]] = ..., t12: Optional[Union[float, bool]] = ..., trans20: Optional[Union[float, bool]] = ..., t20: Optional[Union[float, bool]] = ..., trans21: Optional[Union[float, bool]] = ..., t21: Optional[Union[float, bool]] = ..., trans22: Optional[Union[float, bool]] = ..., t22: Optional[Union[float, bool]] = ..., trans30: Optional[Union[float, bool]] = ..., t30: Optional[Union[float, bool]] = ..., trans31: Optional[Union[float, bool]] = ..., t31: Optional[Union[float, bool]] = ..., trans32: Optional[Union[float, bool]] = ..., t32: Optional[Union[float, bool]] = ..., query: bool = ...) -> Any:
    r"""
    This command sets the values used by the nurbs-to-subdivision surface
    preference.  This preference is used by the nurbs creation commands
    and is saved between Maya sessions.
    
    To query any of the flags, use the "-query" flag.
    
    For more information on the flags, see the node documentation for
    the "nurbsToSubdivProc" node.

    Args:
        bridge | br: (create, query) - Valid values are 0, 1, 2 or 3.
        capType | ct: (create, query) - Valid values are 0 or 1.
        collapsePoles | cp: (create, query) - 
        matchPeriodic | mp: (create, query) - 
        maxPolyCount | mpc: (create, query) - 
        offset | o: (create, query) - 
        reverseNormal | rn: (create, query) - 
        solidType | st: (create, query) - Valid values are 0, 1 or 2.
        trans00 | t00: (create, query) - 
        trans01 | t01: (create, query) - 
        trans02 | t02: (create, query) - 
        trans10 | t10: (create, query) - 
        trans11 | t11: (create, query) - 
        trans12 | t12: (create, query) - 
        trans20 | t20: (create, query) - 
        trans21 | t21: (create, query) - 
        trans22 | t22: (create, query) - 
        trans30 | t30: (create, query) - 
        trans31 | t31: (create, query) - 
        trans32 | t32: (create, query) - 
    """
    ...


def nurbsUVSet(*args, create: bool = ..., c: bool = ..., useExplicit: bool = ..., ue: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Allows user to toggle between implicit and explicit UVs on a NURBS object. Also
    provides a facility to create, delete, rename and set the current explicit UVSet.
    An implicit UVSet is non-editable. It uses the parametric make-up of the NURBS object
    to determine the location of UVs (isoparm intersections). NURBS objects also support
    explicit UVSets which are similar to the UVs of a polygonal object. UVs are created
    at the knots (isoparm intersections) of the object and are fully editable. In order
    to access UV editing capabilities on a NURBS object an explicit UVSet must be created
    and set as the current UVSet.

    Args:
        create | c: (create, edit, query) - Creates an explicit UV set on the specified surface. If the surface already has an explicit UV set this flag will do nothing. Use the -ue/useExplicit flag to set/unset the explicit UV set as the current UV set.
        useExplicit | ue: (create, edit, query) - Toggles the usage of explicit/implicit UVs. When true, explicit UVs will be used, otherwise the object will use implicit UVs.
    """
    ...


def offsetCurve(*args, caching: bool = ..., cch: bool = ..., connectBreaks: Optional[Union[int, bool]] = ..., cb: Optional[Union[int, bool]] = ..., cutLoop: bool = ..., cl: bool = ..., cutRadius: Optional[Union[float, bool]] = ..., cr: Optional[Union[float, bool]] = ..., distance: Optional[Union[float, bool]] = ..., d: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., normal: Optional[Union[Tuple[float, float, float], bool]] = ..., nr: Optional[Union[Tuple[float, float, float], bool]] = ..., reparameterize: bool = ..., rp: bool = ..., stitch: bool = ..., st: bool = ..., subdivisionDensity: Optional[Union[int, bool]] = ..., sd: Optional[Union[int, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., useGivenNormal: bool = ..., ugn: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., range: bool = ..., rn: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The offset command creates new offset curves from the selected curves.
    The connecting type for breaks in offsets is off (no connection),
    circular (connect with an arc) or linear (connect linearly resulting
    in a sharp corner). If loop cutting is on then any loops in the
    offset curves are trimmed away. For the default cut radius of 0.0 a
    sharp corner is created at each intersection. For values greater than
    0.0 a small arc of that radius is created at each intersection.
    The cut radius value is only valid when loop cutting is on.
    Offsets (for planar curves) are calculated in the plane of that curve
    and 3d curves are offset in 3d. The subdivisionDensity flag is the maximum
    number of times the offset object can be subdivided (i.e. calculate
    the offset until the offset comes within tolerance or the iteration
    reaches this maximum.)
    The reparameterize option allows the offset curve to have a different
    parameterization to the original curve. This avoids uneven parameter
    distributions in the offset curve that can occur with large offsets
    of curves, but is more expensive to compute.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        connectBreaks | cb: (create, edit, query) - Connect breaks method (between gaps): 0 - off, 1 - circular, 2 - linear Default: 2
        cutLoop | cl: (create, edit, query) - Do loop cutting. Default: false
        cutRadius | cr: (create, edit, query) - Loop cut radius. Only used if cutLoop attribute is set true. Default: 0.0
        distance | d: (create, edit, query) - Offset distance Default: 1.0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        normal | nr: (create, edit, query) - Offset plane normal
        reparameterize | rp: (create, edit, query) - Do reparameterization. It is not advisable to change this value. Default: false
        stitch | st: (create, edit, query) - Stitch curve segments together. It is not advisable to change this value. Default: true
        subdivisionDensity | sd: (create, edit, query) - Maximum subdivision density per span Default: 5
        tolerance | tol: (create, edit, query) - Tolerance Default: 0.01
        useGivenNormal | ugn: (create, edit, query) - Use the given normal (or, alternativelly, geometry normal) Default: 1
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        range | rn: (create) - Force a curve range on complete input curve.
    """
    ...


def offsetCurveOnSurface(*args, caching: bool = ..., cch: bool = ..., checkPoints: Optional[Union[int, bool]] = ..., cp: Optional[Union[int, bool]] = ..., connectBreaks: Optional[Union[int, bool]] = ..., cb: Optional[Union[int, bool]] = ..., cutLoop: bool = ..., cl: bool = ..., distance: Optional[Union[float, bool]] = ..., d: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., stitch: bool = ..., st: bool = ..., subdivisionDensity: Optional[Union[int, bool]] = ..., sd: Optional[Union[int, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., range: bool = ..., rn: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The offsetCurveOnSurface command offsets a curve on surface resulting
    in another curve on surface.
    The connecting type for breaks in offsets is off (no connection),
    circular (connect with an arc) or linear (connect linearly resulting
    in a sharp corner). If loop cutting is on then any loops in the
    offset curves are trimmed away and a sharp corner is created at each
    intersection. The subdivisionDensity flag is the maximum
    number of times the offset object can be subdivided (i.e. calculate
    the offset until the offset comes within tolerance or the iteration
    reaches this maximum.) The checkPoints flag sets the number of points
    per span at which the distance of the offset curve from the original
    curve is determined. The tolerance flag determines how accurately the
    offset curve should satisfy the required offset distance. A satisfactory
    offset curve is one for which all of the checkpoints are within the
    given tolerance of the required offset.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        checkPoints | cp: (create, edit, query) - Checkpoints for fit quality per span. Not advisable to change this value. Default: 3
        connectBreaks | cb: (create, edit, query) - Connect breaks method (between gaps): 0 - off, 1 - circular, 2 - linear Default: 2
        cutLoop | cl: (create, edit, query) - Do loop cutting. Default: false
        distance | d: (create, edit, query) - Offset distance Default: 1.0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        stitch | st: (create, edit, query) - Stitch curve segments together. Not advisable to change this value. Default: true
        subdivisionDensity | sd: (create, edit, query) - Maximum subdivision density per span Default: 5
        tolerance | tol: (create, edit, query) - Tolerance Default: 0.01
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        range | rn: (create) - Force a curve range on complete input curve.
    """
    ...


def offsetSurface(*args, caching: bool = ..., cch: bool = ..., distance: Optional[Union[float, bool]] = ..., d: Optional[Union[float, bool]] = ..., method: Optional[Union[int, bool]] = ..., m: Optional[Union[int, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The offset command creates new offset surfaces from the
    selected surfaces. The default method is a surface offset,
    which offsets relative to the surface itself. The CV offset
    method offsets the CVs directly rather than the surface, so is
    usually slightly less accurate but is faster. The offset
    surface will always have the same degree, number of CVs and
    knot spacing as the original surface.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        distance | d: (create, edit, query) - Offset distance Default: 1.0
        method | m: (create, edit, query) - Offset method 0 - Surface Fit 1 - CV Fit Default: 0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
    """
    ...


def planarSrf(*args, caching: bool = ..., cch: bool = ..., degree: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., keepOutside: bool = ..., ko: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., range: bool = ..., rn: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command computes a planar trimmed surface given
    planar boundary curves that form a closed region.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        degree | d: (create, edit, query) - The degree of the resulting surface: 1 - linear, 3 - cubic Default: 3
        keepOutside | ko: (create, edit, query) - If true, keep the regions outside the given curves. Default: false
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        tolerance | tol: (create, edit, query) - The distance tolerance for the cvs of the curves to be in the same plane. Default: 0.01
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
        range | rn: (create) - Force a curve range on complete input curve.
    """
    ...


def plane(*args, length: Optional[Union[float, bool]] = ..., l: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., position: Optional[Union[Tuple[float, float, float], bool]] = ..., p: Optional[Union[Tuple[float, float, float], bool]] = ..., rotation: Optional[Union[Tuple[float, float, float], bool]] = ..., r: Optional[Union[Tuple[float, float, float], bool]] = ..., size: Optional[Union[float, bool]] = ..., s: Optional[Union[float, bool]] = ..., width: Optional[Union[float, bool]] = ..., w: Optional[Union[float, bool]] = ...) -> Any:
    r"""
    The command creates a sketch plane (also known as a "construction plane")
    in space.  To create an object (such as a NURBS curve, joint chain or
    polygon) on a construction plane, you need to first make the plane live.
    See also the makeLive command.

    Args:
        length | l: (create) - The length of plane. "linear" means that this flag can handle values with units.
        name | n: (create) - Name the resulting object.
        position | p: (create) - 3D position where the centre of the plane is positioned. "linear" means that this flag can handle values with units.
        rotation | r: (create) - The rotation of plane. "angle" means that this flag can handle values with units.
        size | s: (create) - The combined size (size x size) of plane. "linear" means that this flag can handle values with units.
        width | w: (create) - The width of plane. "linear" means that this flag can handle values with units.
    """
    ...


def pointCurveConstraint(*args, caching: bool = ..., cch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., pointConstraintUVW: Optional[Union[Tuple[float, float, float], bool]] = ..., puv: Optional[Union[Tuple[float, float, float], bool]] = ..., pointWeight: Optional[Union[float, bool]] = ..., pw: Optional[Union[float, bool]] = ..., position: Optional[Union[Tuple[float, float, float], bool]] = ..., p: Optional[Union[Tuple[float, float, float], bool]] = ..., weight: Optional[Union[float, bool]] = ..., w: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The command enables direct manipulation of a NURBS curve. It does so
    by apply a position constraint at the specified parameter location on
    the NURBS curve.
    
    If construction history for the cmd is enabled, a locator is created
    to enable subsequent interactive manipulation of the curve. The
    locator position may be key framed or transformed and the "curve1"
    will try to match the position of the locator.
    
    The argument is a curve location

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        pointConstraintUVW | puv: (create, edit, query) - Point constraint parameter space location on input NURBS Object
        pointWeight | pw: (create, edit, query) - Point constraint weight. Determines how strong an influence the constraint has on the input NURBS object. Default: 1.0
        position | p: (create) - The new desired position in space for the nurbs object at the specified parameter space component. If not specified, the position is taken to be the one evaluated at the parameter space component on the nurbs object.
        weight | w: (create) - weight of the lsq constraint. The larger the weight, the least squares constraint is strictly met.
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def pointOnCurve(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., curvatureCenter: bool = ..., cc: bool = ..., curvatureRadius: bool = ..., cr: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., normal: bool = ..., no: bool = ..., normalizedNormal: bool = ..., nn: bool = ..., normalizedTangent: bool = ..., nt: bool = ..., parameter: Optional[Union[float, bool]] = ..., pr: Optional[Union[float, bool]] = ..., position: bool = ..., p: bool = ..., tangent: bool = ..., t: bool = ..., turnOnPercentage: bool = ..., top: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command returns information for a point on a NURBS curve.
    If no flag is specified, it assumes p/position by default.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create) - Turn the construction history on or off.
        curvatureCenter | cc: (create) - Returns the (x,y,z) center of curvature of the specified point on the curve
        curvatureRadius | cr: (create) - Returns the radius of curvature of the specified point on the curve
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        normal | no: (create) - Returns the (x,y,z) normal of the specified point on the curve
        normalizedNormal | nn: (create) - Returns the (x,y,z) normalized normal of the specified point on the curve
        normalizedTangent | nt: (create) - Returns the (x,y,z) normalized tangent of the specified point on the curve
        parameter | pr: (edit, query) - The parameter value on curve Default: 0.0
        position | p: (create) - Returns the (x,y,z) position of the specified point on the curve
        tangent | t: (create) - Returns the (x,y,z) tangent of the specified point on the curve
        turnOnPercentage | top: (edit, query) - Whether the parameter is normalized (0,1) or not Default: false
    """
    ...


def pointOnSurface(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., normal: bool = ..., no: bool = ..., normalizedNormal: bool = ..., nn: bool = ..., normalizedTangentU: bool = ..., ntu: bool = ..., normalizedTangentV: bool = ..., ntv: bool = ..., parameterU: Optional[Union[float, bool]] = ..., u: Optional[Union[float, bool]] = ..., parameterV: Optional[Union[float, bool]] = ..., v: Optional[Union[float, bool]] = ..., position: bool = ..., p: bool = ..., tangentU: bool = ..., tu: bool = ..., tangentV: bool = ..., tv: bool = ..., turnOnPercentage: bool = ..., top: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command returns information for a point on a surface.
    If no flag is specified, this command assumes p/position by default.
    If more than one flag is specifed, then a string array is returned.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create) - Turn the construction history on or off.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        normal | no: (create, edit, query) - Returns the (x,y,z) normal of the specified point on the surface
        normalizedNormal | nn: (create, edit, query) - Returns the (x,y,z) normalized normal of the specified point on the surface
        normalizedTangentU | ntu: (create, edit, query) - Returns the (x,y,z) normalized U tangent of the specified point on the surface
        normalizedTangentV | ntv: (create, edit, query) - Returns the (x,y,z) normalized V tangent of the specified point on the surface
        parameterU | u: (edit, query) - The U parameter value on surface Default: 0.0
        parameterV | v: (edit, query) - The V parameter value on surface Default: 0.0
        position | p: (create, edit, query) - Returns the (x,y,z) positon of the specified point on the surface
        tangentU | tu: (create, edit, query) - Returns the (x,y,z) U tangent of the specified point on the surface
        tangentV | tv: (create, edit, query) - Returns the (x,y,z) V tangent of the specified point on the surface
        turnOnPercentage | top: (edit, query) - Whether the parameter is normalized (0,1) or not Default: false
    """
    ...


def pointPosition(*args, local: bool = ..., l: bool = ..., world: bool = ..., w: bool = ...) -> Any:
    r"""
    This command returns the world or local space position for any type of
    point object. Valid selection items are:
    - curve and surface CVs
    - poly vertices
    - lattice points
    - particles
    - curve and surface edit points
    - curve and surface parameter points
    - poly uvs
    - rotate/scale/joint pivots
    - selection handles
    - locators, param locators and arc length locators
    
    It works on the selected object or you can specify the object in
    the command. By default, if no flag is specified then the world
    position is returned.

    Args:
        local | l: (create) - Return the point in local space coordinates.
        world | w: (create) - Return the point in world space coordinates.
    """
    ...


def polyAppend(*args, append: Optional[Union[List[Union[float, List[float]]], bool]] = ..., a: Optional[Union[List[Union[float, List[float]]], bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., edge: Optional[Union[int, bool]] = ..., ed: Optional[Union[int, bool]] = ..., hole: bool = ..., hl: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., point: Optional[Union[Tuple[float, float, float], bool]] = ..., p: Optional[Union[Tuple[float, float, float], bool]] = ..., subdivision: Optional[Union[int, bool]] = ..., s: Optional[Union[int, bool]] = ..., texture: Optional[Union[int, bool]] = ..., tx: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Appends a new face to the selected polygonal object.
    The first argument must be a border edge.
    The new face will be automatically closed.
    Only works with one object selected.

    Args:
        append | a: (create, multiuse) - Appends to the given polygon object.  The append flag should be used multiple times to specify the edges, points, and holes that make up the new face that is being added.  You may specify an edge by passing a single argument which will be the edges index.  A point is specified with three arguments which are the coordinates of the point in the objects local space.  Pass no arguments indicates that the values which follow shall specify a hole.  In Python, pass an empty tuple to specify no arguments.
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        edge | ed: (create, multiuse) - Adds the given edge of the selected object to the new face. This edge must be a border, which will be then shared by the new face and the neighboring one. The new face is oriented according to the orientation of the given edge(s).  Note that this flag should be avoided in Python.  You may use the "append" flag instead and pass one argument.
        hole | hl: (create, multiuse) - Add a hole. The following points and edges will define a hole.  Note that this flag should be avoided in Python.  You may use the "append" flag instead and pass an empty tuple ().
        name | n: (create) - Give a name to the resulting node.
        point | p: (create, multiuse) - Adds a new point to the new face. Coordinates of free points are given in the local object reference.  Note that this flag should be avoided in Python.  You may use the "append" flag instead and pass three arguments.
        subdivision | s: (create, edit, query) - This flag specifies the level of subdivisions. Automatically subdivides new edges into the given number of edges. Existing edges cannot be subdivided. C : Default is 1 (no subdivision). Q: When queried, this flag returns an int.
        texture | tx: (create, edit, query) - Specifies how new faces are mapped.  0 - None; 1 - Normalize; 2 - Unitize C: Default is 0 (no mapping). Q: When queried, this flag returns an int
    """
    ...


def polyAppendVertex(*args, append: Optional[Union[List[Union[float, List[float]]], bool]] = ..., a: Optional[Union[List[Union[float, List[float]]], bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., hole: bool = ..., h: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., point: Optional[Union[Tuple[float, float, float], bool]] = ..., p: Optional[Union[Tuple[float, float, float], bool]] = ..., texture: Optional[Union[int, bool]] = ..., tx: Optional[Union[int, bool]] = ..., vertex: Optional[Union[int, bool]] = ..., v: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Appends a new face to the selected polygonal object. The direction
    of the normal is given by the vertex order: the face normal points
    towards the user when the vertices rotate counter clockwise. Note
    that holes must be described in the opposite direction.
    Only works with one object selected.

    Args:
        append | a: (create, multiuse) - Append a vertex or a point to the selected object, or mark the start of a hole.  This flag may also be used in place of the "hole", "vertex" and "point" flags. If no argument is passed to the "append" flag, then it marks the beginning of a hole (use an empty tuple in Python '()').  If one argument is passed, then the argument is considered to be an index into the vertices of the selected object, as with the "vertex" flag.  If three arguments are passed, then it is interpreted as the coordinates of a new point which will be inserted, as with the "point" flag.
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        hole | h: (create, multiuse) - Add a hole. The following points and edges will define a hole.  Note that this flag should be avoided in Python.  You may use the "append" flag instead and pass an empty tuple '()' to specify the start of a hole.
        name | n: (create) - Give a name to the resulting node.
        point | p: (create, multiuse) - Adds a new point to the new face. Coordinates of free points are given in the local object reference.  Note that this flag should be avoided in Python.  You may use the "append" flag instead and pass three arguments.
        texture | tx: (create, edit, query) - Specifies how new faces are mapped. 0 - None; 1 - Normalize; 2 - Unitize C: Default is 0 (no mapping). Q: When queried, this flag returns an int
        vertex | v: (create, multiuse) - Adds the given vertex of the selected object to the new face.  Note that this flag should be avoided in Python.  You may use the "append" flag instead and pass one argument.
    """
    ...


def polyAutoProjection(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createNewMap: bool = ..., cm: bool = ..., insertBeforeDeformers: bool = ..., ibd: bool = ..., layout: Optional[Union[int, bool]] = ..., l: Optional[Union[int, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., optimize: Optional[Union[int, bool]] = ..., o: Optional[Union[int, bool]] = ..., percentageSpace: Optional[Union[float, bool]] = ..., ps: Optional[Union[float, bool]] = ..., planes: Optional[Union[int, bool]] = ..., p: Optional[Union[int, bool]] = ..., projectBothDirections: bool = ..., pb: bool = ..., scaleMode: Optional[Union[int, bool]] = ..., sc: Optional[Union[int, bool]] = ..., skipIntersect: bool = ..., si: bool = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., layoutMethod: Optional[Union[int, bool]] = ..., lm: Optional[Union[int, bool]] = ..., pivot: Optional[Union[Tuple[float, float, float], bool]] = ..., pvt: Optional[Union[Tuple[float, float, float], bool]] = ..., pivotX: Optional[Union[float, bool]] = ..., pvx: Optional[Union[float, bool]] = ..., pivotY: Optional[Union[float, bool]] = ..., pvy: Optional[Union[float, bool]] = ..., pivotZ: Optional[Union[float, bool]] = ..., pvz: Optional[Union[float, bool]] = ..., rotate: Optional[Union[Tuple[float, float, float], bool]] = ..., ro: Optional[Union[Tuple[float, float, float], bool]] = ..., rotateX: Optional[Union[float, bool]] = ..., rx: Optional[Union[float, bool]] = ..., rotateY: Optional[Union[float, bool]] = ..., ry: Optional[Union[float, bool]] = ..., rotateZ: Optional[Union[float, bool]] = ..., rz: Optional[Union[float, bool]] = ..., scale: Optional[Union[Tuple[float, float, float], bool]] = ..., s: Optional[Union[Tuple[float, float, float], bool]] = ..., scaleX: Optional[Union[float, bool]] = ..., sx: Optional[Union[float, bool]] = ..., scaleY: Optional[Union[float, bool]] = ..., sy: Optional[Union[float, bool]] = ..., scaleZ: Optional[Union[float, bool]] = ..., sz: Optional[Union[float, bool]] = ..., translate: Optional[Union[Tuple[float, float, float], bool]] = ..., t: Optional[Union[Tuple[float, float, float], bool]] = ..., translateX: Optional[Union[float, bool]] = ..., tx: Optional[Union[float, bool]] = ..., translateY: Optional[Union[float, bool]] = ..., ty: Optional[Union[float, bool]] = ..., translateZ: Optional[Union[float, bool]] = ..., tz: Optional[Union[float, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Projects a map onto an object, using several orthogonal projections
    simultaneously.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createNewMap | cm: (create) - Set to true if a new map should be created
        insertBeforeDeformers | ibd: (create) - Set to true if the new node created should inserted before any deformer nodes.
        layout | l: (create, edit, query) - What layout algorithm should be used: 0 UV pieces are set to no layout. 1 UV pieces are aligned along the U axis. 2 UV pieces are moved in a square shape.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        optimize | o: (create, edit, query) - Use two different flavors for the cut generation. 0 Every face is assigned to the best plane. This optimizes the map distortion. 1 Small UV pieces are incorporated into larger ones, when the extra distortion introduced is reasonable. This tends to produce fewer UV pieces.
        percentageSpace | ps: (create, edit, query) - When layout is set to square, this value is a percentage of the texture area which is added around each UV piece. It can be used to ensure each UV piece uses different pixels in the texture. Maximum value is 5 percent.
        planes | p: (create, edit, query) - Number of intermediate projections used. Valid numbers are 4, 5, 6, 8, and 12. C: Default is 6.
        projectBothDirections | pb: (create, edit, query) - This flag specifies which reference to use. If "on" : projections are mirrored on directly opposite faces. If "off" : projections are not mirrored on opposite faces. C: Default is "off". Q: When queried, this flag returns an integer.
        scaleMode | sc: (create, edit, query) - How to scale the pieces, after projections: 0 No scale is applied. 1 Uniform scale to fit in unit square. 2 Non proportional scale to fit in unit square.
        skipIntersect | si: (create, edit, query) - When on, self intersection of UV pieces are not tested. This makes the projection faster and produces fewer pieces, but may lead to overlaps in UV space.
        uvSetName | uvs: (create) - Name of the UV set to be created
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
        layoutMethod | lm: (create, edit, query) - Set which layout method to use: 0 Block Stacking. 1 Shape Stacking.
        pivot | pvt: (create, edit, query) - This flag specifies the pivot for scaling and rotation. C: Default is 0.0 0.0 0.0. Q: When queried, this flag returns a float[3].
        pivotX | pvx: (create, edit, query) - This flag specifies the X pivot for scaling and rotation. C: Default is 0.0. Q: When queried, this flag returns a float.
        pivotY | pvy: (create, edit, query) - This flag specifies the Y pivot for scaling and rotation. C: Default is 0.0. Q: When queried, this flag returns a float.
        pivotZ | pvz: (create, edit, query) - This flag specifies the Z pivot for scaling and rotation. C: Default is 0.0. Q: When queried, this flag returns a float.
        rotate | ro: (create, edit, query) - This flag specifies the rotation angles around X, Y, Z. C: Default is 0.0 0.0 0.0. Q: When queried, this flag returns a float[3].
        rotateX | rx: (create, edit, query) - This flag specifies the rotation angle around X. C: Default is 0.0. Q: When queried, this flag returns a float.
        rotateY | ry: (create, edit, query) - This flag specifies the rotation angle around Y. C: Default is 0.0. Q: When queried, this flag returns a float.
        rotateZ | rz: (create, edit, query) - This flag specifies the rotation angle around Z. C: Default is 0.0. Q: When queried, this flag returns a float.
        scale | s: (create, edit, query) - This flag specifies the scaling vector. C: Default is 1.0 1.0 1.0. Q: When queried, this flag returns a float[3].
        scaleX | sx: (create, edit, query) - This flag specifies X for scaling vector. C: Default is 1.0. Q: When queried, this flag returns a float.
        scaleY | sy: (create, edit, query) - This flag specifies Y for scaling vector. C: Default is 1.0. Q: When queried, this flag returns a float.
        scaleZ | sz: (create, edit, query) - This flag specifies Z for scaling vector. C: Default is 1.0. Q: When queried, this flag returns a float.
        translate | t: (create, edit, query) - This flag specifies the translation vector. C: Default is 0.0 0.0 0.0. Q: When queried, this flag returns a float[3].
        translateX | tx: (create, edit, query) - This flag specifies the X translation vector. C: Default is 0.0. Q: When queried, this flag returns a float.
        translateY | ty: (create, edit, query) - This flag specifies the Y translation vector. C: Default is 0.0. Q: When queried, this flag returns a float.
        translateZ | tz: (create, edit, query) - This flag specifies the Z translation vector. C: Default is 0.0. Q: When queried, this flag returns a float.
    """
    ...


def polyAverageNormal(*args, allowZeroNormal: bool = ..., azn: bool = ..., distance: Optional[Union[float, bool]] = ..., d: Optional[Union[float, bool]] = ..., postnormalize: bool = ..., pon: bool = ..., prenormalize: bool = ..., prn: bool = ..., replaceNormalXYZ: Optional[Union[Tuple[float, float, float], bool]] = ..., xyz: Optional[Union[Tuple[float, float, float], bool]] = ...) -> Any:
    r"""
    Set normals of vertices or vertex-faces to an average value when the vertices
    within a given threshold.
    First, it sorts out the containing edges, and set them to be soft, if it is
    possible, so to let the normals appear to be "merged". The remained components
    then are sorted into lumps where vertices in each lump are within the given
    threshold. For all vertices and vertex-faces, set their normals to the average
    normal in the lump.
    Selected vertices may or may not on the same object.
    If objects are selected, it is assumed that all vertices are selected.
    If edges or faces are selected, it is assumed that the related vertex-faces
    are selected.

    Args:
        allowZeroNormal | azn: (create) - Specifies whether to allow zero normals to be created. By default it is false. If it is false, replaceNormal is needed.
        distance | d: (create) - Specifies the distance threshold. All vertices within the threshold are considered when computing an average normal. By default it is 0.0.
        postnormalize | pon: (create) - Specifies whether to normalize the resulting normals. By default it is true.
        prenormalize | prn: (create) - Specifies whether to normalize the normals before averaging. By default it is true.
        replaceNormalXYZ | xyz: (create) - If the allowZeroNormal is false, this value is used to replace the zero normals. By default it is (1, 0, 0).
    """
    ...


def polyAverageVertex(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., iterations: Optional[Union[int, bool]] = ..., i: Optional[Union[int, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Moves the selected vertices of a polygonal object to round its shape.
    Translate, move, rotate or scale vertices.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        iterations | i: (create, edit, query) - Number of rounding steps.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyAxis(*args, arrowType: Optional[Union[int, bool]] = ..., arw: Optional[Union[int, bool]] = ..., axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., frameType: Optional[Union[int, bool]] = ..., ftp: Optional[Union[int, bool]] = ..., lengthX: Optional[Union[float, bool]] = ..., lx: Optional[Union[float, bool]] = ..., lengthY: Optional[Union[float, bool]] = ..., ly: Optional[Union[float, bool]] = ..., lengthZ: Optional[Union[float, bool]] = ..., lz: Optional[Union[float, bool]] = ..., materialTemplate: Optional[Union[str, bool]] = ..., mt: Optional[Union[str, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., rightHanded: bool = ..., rhd: bool = ..., scale: Optional[Union[float, bool]] = ..., sca: Optional[Union[float, bool]] = ..., subdivisionsAxis: Optional[Union[int, bool]] = ..., sa: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The polyAxis command creates a new polygonal shape representing a coordinate system.

    Args:
        arrowType | arw: (create, edit, query) - This flag specifies the shape at the ends of the axis The valid values are 0, 1 and 2. 0 means a flat end shape. 1 means a rounded end shape. 2 means a cone end shape.  C: Default is the cone end shape
        axis | ax: (create, edit, query) - This flag specifies the primitive axis used to build the frame. This is the axis that will point up. Q: When queried, this flag returns a float[3].
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        frameType | ftp: (create, edit, query) - This flag allows a specific frame type to be created The valid values are 0 and 1. 0 implies an axis shape will be created. 1 implies an wedge shape will be created.  C: Default is the axis shape
        lengthX | lx: (create, edit, query) - This flag specifies the length of the x-axis.
        lengthY | ly: (create, edit, query) - This flag specifies the length of the y-axis.
        lengthZ | lz: (create, edit, query) - This flag specifies the length of the z-axis.
        materialTemplate | mt: (create) - Assign the specified material template to geoemtry. If it does not exist one will be created with materials assigned to each axis
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        object | o: (create) - Create the result, or just the dependency node (where applicable).
        radius | r: (create, edit, query) - This flag specifies the radius of the axis.
        rightHanded | rhd: (create, edit, query) - When this is set to true the result will be a shape representing a right handed coordinate system
        scale | sca: (create, edit, query) - This flag specifies the overall scale of the frame shape.
        subdivisionsAxis | sa: (create, edit, query) - This specifies the number of subdivisions for the axis.
    """
    ...


def polyBevel(*args, angleTolerance: Optional[Union[float, bool]] = ..., at: Optional[Union[float, bool]] = ..., autoFit: bool = ..., af: bool = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., mergeVertexTolerance: Optional[Union[float, bool]] = ..., mvt: Optional[Union[float, bool]] = ..., mergeVertices: bool = ..., mv: bool = ..., miteringAngle: Optional[Union[float, bool]] = ..., ma: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., offset: Optional[Union[float, bool]] = ..., o: Optional[Union[float, bool]] = ..., offsetAsFraction: bool = ..., oaf: bool = ..., roundness: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., segments: Optional[Union[int, bool]] = ..., sg: Optional[Union[int, bool]] = ..., smoothingAngle: Optional[Union[float, bool]] = ..., sa: Optional[Union[float, bool]] = ..., subdivideNgons: bool = ..., sn: bool = ..., useLegacyBevelAlgorithm: bool = ..., com: bool = ..., uvAssignment: Optional[Union[int, bool]] = ..., ua: Optional[Union[int, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Bevel edges.

    Args:
        angleTolerance | at: (create, edit, query) - Angular tolerance for creation of extra triangles Note this attribute is for compatability only and should not be modified in Maya 7.0 files Default: 20.0
        autoFit | af: (create, edit, query) - If autoFit is on, it computes a smooth roundness :  new facets round off a smooth angle. Default: true
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        mergeVertexTolerance | mvt: (create, edit, query) - Tolerance within which to merge vertices Default: 0.0
        mergeVertices | mv: (create, edit, query) - Merge vertices within a tolerance Default: false
        miteringAngle | ma: (create, edit, query) - Miter faces that have angles less than this value Default: 0.0
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        offset | o: (create, edit, query) - The offset for bevel. Default: 0.2
        offsetAsFraction | oaf: (create, edit, query) - If on, the offset value is treated as a fraction between zero and one. Default: false
        roundness | r: (create, edit, query) - The roundness of bevel, it is taken into account when autoFit is off. Default: 0.5
        segments | sg: (create, edit, query) - The number of segments used for beveling. Default: 1
        smoothingAngle | sa: (create, edit, query) - Create new edges as hard edges if the angle between adjacent faces exceeds this value Default: 0.0
        subdivideNgons | sn: (create, edit, query) - Subdivide new faces with more than 4 edges Default: false
        useLegacyBevelAlgorithm | com: (create, edit, query) - If on, bevel is done the way maya 2014 did Default: false
        uvAssignment | ua: (create, edit, query) - Technique used to compute UVs on new faces 0 computes new UVs by projecting along surface normal of original mesh onto new mesh 1 computes new UVs by projecting along surface normal of new mesh onto original mesh Default: 0
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyBevel3(*args, angleTolerance: Optional[Union[float, bool]] = ..., at: Optional[Union[float, bool]] = ..., autoFit: bool = ..., af: bool = ..., caching: bool = ..., cch: bool = ..., chamfer: bool = ..., c: bool = ..., constructionHistory: bool = ..., ch: bool = ..., depth: Optional[Union[float, bool]] = ..., d: Optional[Union[float, bool]] = ..., fillNgons: bool = ..., fn: bool = ..., mergeVertexTolerance: Optional[Union[float, bool]] = ..., mvt: Optional[Union[float, bool]] = ..., mergeVertices: bool = ..., mv: bool = ..., miterAlong: Optional[Union[int, bool]] = ..., mia: Optional[Union[int, bool]] = ..., mitering: Optional[Union[int, bool]] = ..., m: Optional[Union[int, bool]] = ..., miteringAngle: Optional[Union[float, bool]] = ..., ma: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., offset: Optional[Union[float, bool]] = ..., o: Optional[Union[float, bool]] = ..., offsetAsFraction: bool = ..., oaf: bool = ..., roundness: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., segments: Optional[Union[int, bool]] = ..., sg: Optional[Union[int, bool]] = ..., smoothingAngle: Optional[Union[float, bool]] = ..., sa: Optional[Union[float, bool]] = ..., uvAssignment: Optional[Union[int, bool]] = ..., ua: Optional[Union[int, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Bevel edges.

    Args:
        angleTolerance | at: (create, edit, query) - Angular tolerance for creation of extra triangles Note this attribute is for compatability only and should not be modified in Maya 7.0 files Default: 20.0
        autoFit | af: (create, edit, query) - If autoFit is on, it computes a smooth roundness :  new facets round off a smooth angle. Default: true
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        chamfer | c: (create, edit, query) - If chamfer is on, the surface is smoothed out at bevels. When it is off, the shape of the surface remains the same. Default: true
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        depth | d: (create, edit, query) - The depth of bevel. One means a smooth surface, -1 means maximum depth. Default: 1.0
        fillNgons | fn: (create, edit, query) - Subdivide new faces with more than 4 edges Default: false
        mergeVertexTolerance | mvt: (create, edit, query) - Tolerance within which to merge vertices Default: 0.0
        mergeVertices | mv: (create, edit, query) - Merge vertices within a tolerance Default: false
        miterAlong | mia: (create, edit, query) - Controls in which direction new vertices should we offseted. Default: 0
        mitering | m: (create, edit, query) - Controls how the topology should look like at corners. Default: 0
        miteringAngle | ma: (create, edit, query) - Miter faces that have angles less than this value Default: 0.0
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        offset | o: (create, edit, query) - The offset for bevel. Default: 0.2
        offsetAsFraction | oaf: (create, edit, query) - If on, the offset value is treated as a fraction between zero and one. Default: false
        roundness | r: (create, edit, query) - The roundness of bevel, it is taken into account when autoFit is off. Default: 0.5
        segments | sg: (create, edit, query) - The number of segments used for beveling. Default: 1
        smoothingAngle | sa: (create, edit, query) - Create new edges as hard edges if the angle between adjacent faces exceeds this value Default: 0.0
        uvAssignment | ua: (create, edit, query) - Technique used to compute UVs on new faces 0 computes new UVs by projecting along surface normal of original mesh onto new mesh 1 computes new UVs by projecting along surface normal of new mesh onto original mesh Default: 0
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyBlendColor(*args, baseColorName: Optional[Union[str, bool]] = ..., bcn: Optional[Union[str, bool]] = ..., blendFunc: Optional[Union[int, bool]] = ..., bfn: Optional[Union[int, bool]] = ..., blendWeightA: Optional[Union[float, bool]] = ..., bwa: Optional[Union[float, bool]] = ..., blendWeightB: Optional[Union[float, bool]] = ..., bwb: Optional[Union[float, bool]] = ..., blendWeightC: Optional[Union[float, bool]] = ..., bwc: Optional[Union[float, bool]] = ..., blendWeightD: Optional[Union[float, bool]] = ..., bwd: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., dstColorName: Optional[Union[str, bool]] = ..., dst: Optional[Union[str, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., srcColorName: Optional[Union[str, bool]] = ..., src: Optional[Union[str, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Takes two color sets and blends them together into a third specified color set.

    Args:
        baseColorName | bcn: (edit, query) - Name of the color set to blend from
        blendFunc | bfn: (edit, query) - Type of blending function to use
        blendWeightA | bwa: (edit, query) - Blend weight for linear and bilinear blending functions
        blendWeightB | bwb: (edit, query) - Blend weight for bilinear and channel blending functions
        blendWeightC | bwc: (edit, query) - Blend weight for channel functions
        blendWeightD | bwd: (edit, query) - Blend weight for channel functions
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        dstColorName | dst: (edit, query) - Name of the color set to copy to
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        srcColorName | src: (edit, query) - Name of the color set to copy from
    """
    ...


def polyBlindData(*args, associationType: Optional[Union[str, bool]] = ..., at: Optional[Union[str, bool]] = ..., binaryData: Optional[Union[str, bool]] = ..., bnd: Optional[Union[str, bool]] = ..., booleanData: bool = ..., bd: bool = ..., delete: bool = ..., doubleData: Optional[Union[float, bool]] = ..., dbd: Optional[Union[float, bool]] = ..., int64Data: Optional[Union[int, bool]] = ..., lid: Optional[Union[int, bool]] = ..., intData: Optional[Union[int, bool]] = ..., ind: Optional[Union[int, bool]] = ..., longDataName: Optional[Union[str, bool]] = ..., ldn: Optional[Union[str, bool]] = ..., rescan: bool = ..., res: bool = ..., reset: bool = ..., rst: bool = ..., shape: bool = ..., sh: bool = ..., shortDataName: Optional[Union[str, bool]] = ..., sdn: Optional[Union[str, bool]] = ..., stringData: Optional[Union[str, bool]] = ..., sd: Optional[Union[str, bool]] = ..., typeId: Optional[Union[int, bool]] = ..., id: Optional[Union[int, bool]] = ..., edit: bool = ...) -> Any:
    r"""
    Command creates blindData types (basically creates an instance of
    TdnPolyBlindData). When used with the query flag, it returns the data
    types that define this blindData type.
    This command is to be used create a blindData node *and* to edit the same..
    The associationType flag *has* to be specified at all times.. This is
    because if an instance of the specified BD typeId exists in the history
    chain but if the associationType is not the same, then a new polyBlindData
    node is created..
    For object level blind data, only the object itself must be specified.
    A new compound attribute BlindDataNNNN will be created on the object.
    Blind data attribute names must be unique across types for object level
    blind data.
    So, the command will require the following to be specified:
        - typeId,
        - associationType
        - longDataName or shortDataName of data being edited.
        - The actual data being specified.
        - The components that this data is to be attached to.

    Args:
        associationType | at: (create, edit) - Specifies the dataTypes that are part of BlindData node being created. Allowable associations are "object" for any object, and "vertex" "edge" and "face" for mesh objects. Other associations for other geometry types may be added.
        binaryData | bnd: (create, edit, multiuse) - Specifies the data type is a binary data value
        booleanData | bd: (create, edit, multiuse) - Specifies the data type is a boolean logic value
        delete | delete: (create, edit) - Specifies that this will remove the blind data if found
        doubleData | dbd: (create, edit, multiuse) - Specifies the data type is a floating point double value
        int64Data | lid: (create, edit, multiuse) - Specifies the data type is an 64-bit integer value
        intData | ind: (create, edit, multiuse) - Specifies the data type is an integer value
        longDataName | ldn: (create, edit, multiuse) - Specifies the long name of the data that is being modified by this command.
        rescan | res: (create, edit) - Enables a rescan of blind data nodes for cached information
        reset | rst: (create, edit) - Specifies that this command will reset the given attribute to default value
        shape | sh: (create, edit) - For object association only, apply blind data to the shape(s) below this node instead of the node itself
        shortDataName | sdn: (create, edit, multiuse) - Specifies the short name of the data that is being modified by this command.
        stringData | sd: (create, edit, multiuse) - Specifies the data type is a string value
        typeId | id: (create, edit) - Specifies the typeId of the BlindData type being created
    """
    ...


def polyBooleanCmd(*args, addMesh: str = ..., am: str = ..., changeSmoothMesh: Tuple[str, bool] = ..., csm: Tuple[str, bool] = ..., classification: Optional[Union[int, bool]] = ..., cls: Optional[Union[int, bool]] = ..., interactiveUpdate: bool = ..., iu: bool = ..., newInputDisplay: Optional[Union[int, bool]] = ..., nid: Optional[Union[int, bool]] = ..., newInputOperation: Optional[Union[int, bool]] = ..., nio: Optional[Union[int, bool]] = ..., operation: Optional[Union[int, bool]] = ..., op: Optional[Union[int, bool]] = ..., removeMesh: str = ..., rm: str = ..., reorderMesh: Tuple[str, int] = ..., rom: Tuple[str, int] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command creates a new poly as the result of a boolean operation on input polys.

    Args:
        addMesh | am: (edit) - Add a new mesh to the boolean stack.
        changeSmoothMesh | csm: (edit) - Set one of the inputs to use a smoothed version of the mesh.
        classification | cls: (edit, query) - Changes how intersections of open and closed manifolds are treated. 1 = Edge.  2 = Normal.  3 = Auto
        interactiveUpdate | iu: (edit, query) - Changes how interactive manipulation of input meshes trigger updates of the boolean node. If true, will trigger compute while dragging a manipulator. If false, will not trigger a compute until the manipulator is released.
        newInputDisplay | nid: (edit, query) - Default display mode to apply to new inputs. 0 = Wireframe.  1 = Shaded.  2 = Bounding Box.  3 = X-Ray.  4 = Hidden.
        newInputOperation | nio: (edit, query) - Default boolean operation to apply to new inputs if not specified.  Values are: 1=Union, 2=Difference A-B, 3=Intersection, 4=Difference B-A, 5=Split, 6=Split Edges, 7=Hole Punch, 8=Cut Out
        operation | op: (create, multiuse) - Specifies the boolean operation to run.  Values are: 1=Union, 2=Difference A-B, 3=Intersection, 4=Difference B-A, 5=Split, 6=Split Edges, 7=Hole Punch, 8=Cut Out
        removeMesh | rm: (edit) - Remove a  mesh from the boolean stack.
        reorderMesh | rom: (edit) - Change the position of a mesh in the boolean stack to a specific index.
    """
    ...


def polyBoolOp(*args, faceAreaThreshold: Optional[Union[float, bool]] = ..., fat: Optional[Union[float, bool]] = ..., operation: Optional[Union[int, bool]] = ..., op: Optional[Union[int, bool]] = ..., preserveColor: bool = ..., pcr: bool = ..., useThresholds: bool = ..., uth: bool = ..., vertexDistanceThreshold: Optional[Union[float, bool]] = ..., vdt: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., mergeUVSets: Optional[Union[int, bool]] = ..., muv: Optional[Union[int, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command creates a new poly as the result of a boolean
    operation on input polys : union, intersection, difference.
    Only for difference, the order of the selected objects is
    important :
    result = object1 - object2.
    If no objects are specified in the command line, then the
    objects from the active list are used.

    Args:
        faceAreaThreshold | fat: (create, edit, query) - Area threshold to determine whether faces should be collapsed before boolean. Attribute is ignored unless useThresholds is set to true Default: 0.0001
        operation | op: (create, edit, query) - Boolean operation type. 1=union, 2=difference, 3=intersection. Default type is union. Default: kBoolOpUnion
        preserveColor | pcr: (create, edit, query) - If true, boolean op will compute color for the new mesh. If false, the new mesh won't have any color set. Default: false
        useThresholds | uth: (create, edit, query) - If true, merge vertices with separations less then vertexDistanceThreshold and collapse faces with areas less then faceAreaThreshold. If false, do not merge vertices or collapse faces Default: false
        vertexDistanceThreshold | vdt: (create, edit, query) - Tolerance to determine whether vertices (and edges) should be merged before boolean operation is applied. Attribute is ignored unless useThresholds is set to true Default: 0.001
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        mergeUVSets | muv: (create, edit, query) - Specify how UV sets will be merged on the output mesh.  0 = "No Merge": Each UV set on each mesh will become a new UV set in the output. 1 = "Merge By Name": UV sets with the same name will be merged. 2 = "Merge By UV Links": UV sets will be merged so that UV linking on the input meshes continues to work.  The default is merge by name.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def polyBridgeEdge(*args, bridgeOffset: Optional[Union[int, bool]] = ..., bo: Optional[Union[int, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., curveType: Optional[Union[int, bool]] = ..., ctp: Optional[Union[int, bool]] = ..., divisions: Optional[Union[int, bool]] = ..., dv: Optional[Union[int, bool]] = ..., inputCurve: Optional[Union[str, bool]] = ..., inc: Optional[Union[str, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., smoothingAngle: Optional[Union[float, bool]] = ..., sma: Optional[Union[float, bool]] = ..., startVert1: Optional[Union[int, bool]] = ..., sv1: Optional[Union[int, bool]] = ..., startVert2: Optional[Union[int, bool]] = ..., sv2: Optional[Union[int, bool]] = ..., taper: Optional[Union[float, bool]] = ..., tp: Optional[Union[float, bool]] = ..., taperCurve_FloatValue: Optional[Union[float, bool]] = ..., cfv: Optional[Union[float, bool]] = ..., taperCurve_Interp: Optional[Union[int, bool]] = ..., ci: Optional[Union[int, bool]] = ..., taperCurve_Position: Optional[Union[float, bool]] = ..., cp: Optional[Union[float, bool]] = ..., twist: Optional[Union[float, bool]] = ..., twt: Optional[Union[float, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Bridges two sets of edges.

    Args:
        bridgeOffset | bo: (create, edit, query) - Add offset to which vertices are connected. Default: 0
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        curveType | ctp: (create, edit, query) - Format: 0 - Linear, 1 - Blend, 2 - Curve Default: TdnpolyBridgeEdge::Linear
        divisions | dv: (create, edit, query) - The number of subdivisions in the bridging faces (resulting in (divisions+1) row of faces). Default: 1
        inputCurve | inc: (create) - This flag specifies the name of the curve to be used as input for the operation.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        smoothingAngle | sma: (create, edit, query) - Angle below which new edges will be smoothed Default: kPi/6.0
        startVert1 | sv1: (create, edit, query) - The start vertex from the first set of edges Default: -1
        startVert2 | sv2: (create, edit, query) - The start vertex from the second set of edges Default: -1
        taper | tp: (create, edit, query) - Taper or Scale along the extrusion path Default: 1.0
        taperCurve_FloatValue | cfv: (create, edit, query) - Value for taperCurve; Curve control for taper along extrusion Using this curve, the taper along extrusion can be changed from a simple linear scaling to custom scaling along the extrusion path.
        taperCurve_Interp | ci: (create, edit, query) - Interpolation type for taperCurve; Curve control for taper along extrusion Using this curve, the taper along extrusion can be changed from a simple linear scaling to custom scaling along the extrusion path.
        taperCurve_Position | cp: (create, edit, query) - Position for taperCurve; Curve control for taper along extrusion Using this curve, the taper along extrusion can be changed from a simple linear scaling to custom scaling along the extrusion path.
        twist | twt: (create, edit, query) - Twist or Rotation along the extrusion path Default: 0.0
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyCacheMonitor(*args, cacheValue: bool = ..., chv: bool = ..., nodeName: Optional[Union[str, bool]] = ..., nm: Optional[Union[str, bool]] = ...) -> Any:
    r"""
    When the cacheInput attribute has a positive value the midModifier node caches the output mesh
    improving performance in computations of downstream nodes.
    When the counter has a zero value the midModifier releases the cached data.

    Args:
        cacheValue | chv: (create) - Flag to indicate whether the node's cache counter should be incremented or decremented. True increments the counter, false decrements the counter.
        nodeName | nm: (create) - Name of the node whose cache counter needs to be changed.
    """
    ...


def polyCanBridgeEdge(*args) -> Any:
    r"""
    Returns true if the specified poly edges can be bridged using polyBridgeEdge.

    Args:
    """
    ...


def polyCBoolOp(*args, classification: Optional[Union[int, bool]] = ..., cls: Optional[Union[int, bool]] = ..., faceAreaThreshold: Optional[Union[float, bool]] = ..., fat: Optional[Union[float, bool]] = ..., operation: Optional[Union[int, bool]] = ..., op: Optional[Union[int, bool]] = ..., preserveColor: bool = ..., pcr: bool = ..., useCarveBooleans: bool = ..., ucb: bool = ..., useThresholds: bool = ..., uth: bool = ..., vertexDistanceThreshold: Optional[Union[float, bool]] = ..., vdt: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., mergeUVSets: Optional[Union[int, bool]] = ..., muv: Optional[Union[int, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., tagIntersection: bool = ..., ti: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command creates a new poly as the result of a boolean
    operation on input polys : union, intersection, difference.
    Only for difference, the order of the selected objects is
    important :
    result = object1 - object2.
    If no objects are specified in the command line, then the
    objects from the active list are used.

    Args:
        classification | cls: (create, edit, query) - Changes how intersections of open and closed manifolds are treated. 1 for "Edge", 2 for "Normal".
        faceAreaThreshold | fat: (create, edit, query) - Area threshold to determine whether faces should be collapsed before boolean. Attribute is ignored unless useThresholds is set to true Default: 0.0001
        operation | op: (create, edit, query) - Boolean operation type. 1=union, 2=difference, 3=intersection. Default type is union. Default: kBoolOpUnion
        preserveColor | pcr: (create, edit, query) - If true, boolean op will compute color for the new mesh. If false, the new mesh won't have any color set. Default: false
        useCarveBooleans | ucb: (create, edit, query) - If true, use the Carve Boolean library
        useThresholds | uth: (create, edit, query) - If true, merge vertices with separations less then vertexDistanceThreshold and collapse faces with areas less then faceAreaThreshold. If false, do not merge vertices or collapse faces Default: false
        vertexDistanceThreshold | vdt: (create, edit, query) - Tolerance to determine whether vertices (and edges) should be merged before boolean operation is applied. Attribute is ignored unless useThresholds is set to true Default: 0.001
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        mergeUVSets | muv: (create, edit, query) - Specify how UV sets will be merged on the output mesh.  0 = "No Merge": Each UV set on each mesh will become a new UV set in the output. 1 = "Merge By Name": UV sets with the same name will be merged. 2 = "Merge By UV Links": UV sets will be merged so that UV linking on the input meshes continues to work.  The default is merge by name.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        tagIntersection | ti: (create, edit, query) - If set the operation creates custom component tags that contain vertices on the intersection.
    """
    ...


def polyCheck(*args, edge: bool = ..., e: bool = ..., face: bool = ..., f: bool = ..., faceOffset: bool = ..., fo: bool = ..., openFile: Optional[Union[str, bool]] = ..., of: Optional[Union[str, bool]] = ...) -> Any:
    r"""
    Dumps a description of internal memory representation of poly objects.
    If no objects are specified in the command line, the
    objects from the active list are used.
    Default behaviour is to print only a summary. Use the flags
    above to get more details on a specific part of the object.

    Args:
        edge | e: (create) - Check edge descriptions. If no flag is set, a complete check is performed.
        face | f: (create) - Check face descriptions. If no flag is set, a complete check is performed.
        faceOffset | fo: (create) - Check face offset descriptions. If no flag is set, a complete check is performed.
        openFile | of: (create) - Opens a file that contains a poly description, as dumped out by the debug commands.
    """
    ...


def polyChipOff(*args, attraction: Optional[Union[float, bool]] = ..., att: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., duplicate: bool = ..., dup: bool = ..., gain: Optional[Union[float, bool]] = ..., ga: Optional[Union[float, bool]] = ..., gravity: Optional[Union[Tuple[float, float, float], bool]] = ..., g: Optional[Union[Tuple[float, float, float], bool]] = ..., gravityX: Optional[Union[float, bool]] = ..., gx: Optional[Union[float, bool]] = ..., gravityY: Optional[Union[float, bool]] = ..., gy: Optional[Union[float, bool]] = ..., gravityZ: Optional[Union[float, bool]] = ..., gz: Optional[Union[float, bool]] = ..., keepFacesTogether: bool = ..., kft: bool = ..., keepFacetTogether: bool = ..., xft: bool = ..., localCenter: Optional[Union[int, bool]] = ..., lc: Optional[Union[int, bool]] = ..., localDirection: Optional[Union[Tuple[float, float, float], bool]] = ..., ld: Optional[Union[Tuple[float, float, float], bool]] = ..., localDirectionX: Optional[Union[float, bool]] = ..., ldx: Optional[Union[float, bool]] = ..., localDirectionY: Optional[Union[float, bool]] = ..., ldy: Optional[Union[float, bool]] = ..., localDirectionZ: Optional[Union[float, bool]] = ..., ldz: Optional[Union[float, bool]] = ..., localRotate: Optional[Union[Tuple[float, float, float], bool]] = ..., lr: Optional[Union[Tuple[float, float, float], bool]] = ..., localRotateX: Optional[Union[float, bool]] = ..., lrx: Optional[Union[float, bool]] = ..., localRotateY: Optional[Union[float, bool]] = ..., lry: Optional[Union[float, bool]] = ..., localRotateZ: Optional[Union[float, bool]] = ..., lrz: Optional[Union[float, bool]] = ..., localScale: Optional[Union[Tuple[float, float, float], bool]] = ..., ls: Optional[Union[Tuple[float, float, float], bool]] = ..., localScaleX: Optional[Union[float, bool]] = ..., lsx: Optional[Union[float, bool]] = ..., localScaleY: Optional[Union[float, bool]] = ..., lsy: Optional[Union[float, bool]] = ..., localScaleZ: Optional[Union[float, bool]] = ..., lsz: Optional[Union[float, bool]] = ..., localTranslate: Optional[Union[Tuple[float, float, float], bool]] = ..., lt: Optional[Union[Tuple[float, float, float], bool]] = ..., localTranslateX: Optional[Union[float, bool]] = ..., ltx: Optional[Union[float, bool]] = ..., localTranslateY: Optional[Union[float, bool]] = ..., lty: Optional[Union[float, bool]] = ..., localTranslateZ: Optional[Union[float, bool]] = ..., ltz: Optional[Union[float, bool]] = ..., magnX: Optional[Union[float, bool]] = ..., mx: Optional[Union[float, bool]] = ..., magnY: Optional[Union[float, bool]] = ..., my: Optional[Union[float, bool]] = ..., magnZ: Optional[Union[float, bool]] = ..., mz: Optional[Union[float, bool]] = ..., magnet: Optional[Union[Tuple[float, float, float], bool]] = ..., m: Optional[Union[Tuple[float, float, float], bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., offset: Optional[Union[float, bool]] = ..., off: Optional[Union[float, bool]] = ..., pivot: Optional[Union[Tuple[float, float, float], bool]] = ..., pvt: Optional[Union[Tuple[float, float, float], bool]] = ..., pivotX: Optional[Union[float, bool]] = ..., pvx: Optional[Union[float, bool]] = ..., pivotY: Optional[Union[float, bool]] = ..., pvy: Optional[Union[float, bool]] = ..., pivotZ: Optional[Union[float, bool]] = ..., pvz: Optional[Union[float, bool]] = ..., random: Optional[Union[float, bool]] = ..., ran: Optional[Union[float, bool]] = ..., scale: Optional[Union[Tuple[float, float, float], bool]] = ..., s: Optional[Union[Tuple[float, float, float], bool]] = ..., scaleX: Optional[Union[float, bool]] = ..., sx: Optional[Union[float, bool]] = ..., scaleY: Optional[Union[float, bool]] = ..., sy: Optional[Union[float, bool]] = ..., scaleZ: Optional[Union[float, bool]] = ..., sz: Optional[Union[float, bool]] = ..., translate: Optional[Union[Tuple[float, float, float], bool]] = ..., t: Optional[Union[Tuple[float, float, float], bool]] = ..., translateX: Optional[Union[float, bool]] = ..., tx: Optional[Union[float, bool]] = ..., translateY: Optional[Union[float, bool]] = ..., ty: Optional[Union[float, bool]] = ..., translateZ: Optional[Union[float, bool]] = ..., tz: Optional[Union[float, bool]] = ..., weight: Optional[Union[float, bool]] = ..., w: Optional[Union[float, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Extract facets. Faces can be extracted separately or together, and
    manipulations can be performed either in world or object space.

    Args:
        attraction | att: (create, edit, query) - Attraction, related to magnet. The range is [-2.0, 2.0]. Default: 0.0
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        duplicate | dup: (create, edit, query) - If "on", facets are duplicated, otherwise original facets are removed. C: Default is "on". Q: When queried, this flag returns an int.
        gain | ga: (create, edit, multiuse, query) - Gain factor per component. Can be painted using Artisan. Default: 1.0
        gravity | g: (create, edit, query) - The gravity vector. Default: 0.0, -1.0, 0.0
        gravityX | gx: (create, edit, query) - Gravity X coord.
        gravityY | gy: (create, edit, query) - Gravity Y coord.
        gravityZ | gz: (create, edit, query) - Gravity Z coord.
        keepFacesTogether | kft: (create, edit, query) - How to extrude edges. If "on", extruded faces produced from the edges being extruded will be kept together. Otherwise they are pulled independently. Default: true
        keepFacetTogether | xft: (create, edit, query) - How to extrude edges. If "on", extruded faces produced from the edges being extruded will be kept together. Otherwise they are pulled independently. Default: true
        localCenter | lc: (create, edit, query) - Local center on the edge : 0=Middle point, 1=Start point, 2=End point. Default: 0
        localDirection | ld: (create, edit, query) - Direction to determine X axis for local space. Default: 1.0, 0.0, 0.0
        localDirectionX | ldx: (create, edit, query) - X coord of the X axis.
        localDirectionY | ldy: (create, edit, query) - Y coord of the X axis.
        localDirectionZ | ldz: (create, edit, query) - Z coord of the X axis.
        localRotate | lr: (create, edit, query) - The local rotations. Default: 0.0, 0.0, 0.0
        localRotateX | lrx: (create, edit, query) - Local rotate X coord. The range is [0, 360].
        localRotateY | lry: (create, edit, query) - Local rotate Y coord. The range is [0, 360].
        localRotateZ | lrz: (create, edit, query) - Local rotate Z coord : Rotation along the normal. The range is [0, 360].
        localScale | ls: (create, edit, query) - Local Scale. Default: 1.0, 1.0, 1.0
        localScaleX | lsx: (create, edit, query) - Scale X coord.
        localScaleY | lsy: (create, edit, query) - Scale Y coord.
        localScaleZ | lsz: (create, edit, query) - Scale Z coord.
        localTranslate | lt: (create, edit, query) - Local translate. Default: 0.0, 0.0, 0.0
        localTranslateX | ltx: (create, edit, query) - Local translation X coord.
        localTranslateY | lty: (create, edit, query) - Local translation Y coord.
        localTranslateZ | ltz: (create, edit, query) - Local translation Z coord : Move along the normal.
        magnX | mx: (create, edit, query) - Magnet X coord.
        magnY | my: (create, edit, query) - Magnet Y coord.
        magnZ | mz: (create, edit, query) - Magnet Z coord.
        magnet | m: (create, edit, query) - The magnet vector. Default: 0.0, 0.0, 0.0
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        offset | off: (create, edit, query) - Local offset. Faces are moved this distance towards the inside of the face. Default: 0.0
        pivot | pvt: (create, edit, query) - The pivot for scaling and rotation. Default: 0.0, 0.0, 0.0
        pivotX | pvx: (create, edit, query) - Pivot X coord.
        pivotY | pvy: (create, edit, query) - Pivot Y coord.
        pivotZ | pvz: (create, edit, query) - Pivot Z coord.
        random | ran: (create, edit, query) - Random value for all parameters. Default: 0.0
        scale | s: (create, edit, query) - Scaling vector. Default: 1.0, 1.0, 1.0
        scaleX | sx: (create, edit, query) - Scale X coord.
        scaleY | sy: (create, edit, query) - Scale Y coord.
        scaleZ | sz: (create, edit, query) - Scale Z coord.
        translate | t: (create, edit, query) - Translation vector. Default: 0.0, 0.0, 0.0
        translateX | tx: (create, edit, query) - Translation X coord.
        translateY | ty: (create, edit, query) - Translation Y coord.
        translateZ | tz: (create, edit, query) - Translation Z coord.
        weight | w: (create, edit, query) - The weight, related to gravity. Default: 0.0
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyCircularize(*args, alignment: Optional[Union[int, bool]] = ..., al: Optional[Union[int, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createCurve: bool = ..., cc: bool = ..., evenlyDistribute: bool = ..., ed: bool = ..., inputCurve: Optional[Union[str, bool]] = ..., inc: Optional[Union[str, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., normalOrientation: Optional[Union[int, bool]] = ..., nor: Optional[Union[int, bool]] = ..., radialOffset: Optional[Union[float, bool]] = ..., ro: Optional[Union[float, bool]] = ..., smoothingAngle: Optional[Union[float, bool]] = ..., sa: Optional[Union[float, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Mirror all the faces of the selected object.

    Args:
        alignment | al: (create, edit, query) - How the circle should be  oriented relative to the surface Default: 0
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createCurve | cc: (create) - If true then the operation can create a curve.
        evenlyDistribute | ed: (create, edit, query) - Should the point be evenly distributed around the circle Default: true
        inputCurve | inc: (create) - This flag specifies the name of the curve to be used as input for the operation.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        normalOrientation | nor: (create, edit, query) - What calculation to use to get circle plane normal Default: 0
        radialOffset | ro: (create, edit, query) - The amount the circle points should be translated along radius Default: 0.0
        smoothingAngle | sa: (create, edit, query) - The angle that decides which resulting faces are hard or soft Default: 30.0
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyCircularizeEdge(*args, alignment: Optional[Union[int, bool]] = ..., al: Optional[Union[int, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createCurve: bool = ..., cc: bool = ..., evenlyDistribute: bool = ..., ed: bool = ..., inputCurve: Optional[Union[str, bool]] = ..., inc: Optional[Union[str, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., normalOrientation: Optional[Union[int, bool]] = ..., nor: Optional[Union[int, bool]] = ..., radialOffset: Optional[Union[float, bool]] = ..., ro: Optional[Union[float, bool]] = ..., smoothingAngle: Optional[Union[float, bool]] = ..., sa: Optional[Union[float, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Mirror all the faces of the selected object.

    Args:
        alignment | al: (create, edit, query) - How the circle should be  oriented relative to the surface Default: 0
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createCurve | cc: (create) - If true then the operation can create a curve.
        evenlyDistribute | ed: (create, edit, query) - Should the point be evenly distributed around the circle Default: true
        inputCurve | inc: (create) - This flag specifies the name of the curve to be used as input for the operation.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        normalOrientation | nor: (create, edit, query) - What calculation to use to get circle plane normal Default: 0
        radialOffset | ro: (create, edit, query) - The amount the circle points should be translated along radius Default: 0.0
        smoothingAngle | sa: (create, edit, query) - The angle that decides which resulting faces are hard or soft Default: 30.0
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyCircularizeFace(*args, alignment: Optional[Union[int, bool]] = ..., al: Optional[Union[int, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createCurve: bool = ..., cc: bool = ..., evenlyDistribute: bool = ..., ed: bool = ..., inputCurve: Optional[Union[str, bool]] = ..., inc: Optional[Union[str, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., normalOrientation: Optional[Union[int, bool]] = ..., nor: Optional[Union[int, bool]] = ..., radialOffset: Optional[Union[float, bool]] = ..., ro: Optional[Union[float, bool]] = ..., smoothingAngle: Optional[Union[float, bool]] = ..., sa: Optional[Union[float, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Mirror all the faces of the selected object.

    Args:
        alignment | al: (create, edit, query) - How the circle should be  oriented relative to the surface Default: 0
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createCurve | cc: (create) - If true then the operation can create a curve.
        evenlyDistribute | ed: (create, edit, query) - Should the point be evenly distributed around the circle Default: true
        inputCurve | inc: (create) - This flag specifies the name of the curve to be used as input for the operation.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        normalOrientation | nor: (create, edit, query) - What calculation to use to get circle plane normal Default: 0
        radialOffset | ro: (create, edit, query) - The amount the circle points should be translated along radius Default: 0.0
        smoothingAngle | sa: (create, edit, query) - The angle that decides which resulting faces are hard or soft Default: 30.0
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyClean(*args, caching: bool = ..., cch: bool = ..., cleanEdges: bool = ..., ce: bool = ..., cleanPartialUVMapping: bool = ..., cpm: bool = ..., cleanUVs: bool = ..., cuv: bool = ..., cleanVertices: bool = ..., cv: bool = ..., constructionHistory: bool = ..., ch: bool = ..., frozen: bool = ..., fzn: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    polyClean will attempt to remove components that are invalid in the description of a poly mesh.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        cleanEdges | ce: (create, edit, query) - If true, the operation will look for and delete edges that are not associated with any face in the mesh.
        cleanPartialUVMapping | cpm: (create, edit, query) - If true, the operation will look for any faces on the mesh that do not have complete UV mapping.  Maya requires that all vertices that make up a mesh face have valid UV data associated with them, or that none of the vertices withing the face have associated UVs.
        cleanUVs | cuv: (create, edit, query) - If true, the operation will look for and delete UVs that are not associated with any face in the mesh.
        cleanVertices | cv: (create, edit, query) - If true, the operation will look for and delete vertices that are not associated with any face in the mesh.
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        frozen | fzn: (create, edit, query) - Toggle frozen state for a particular node to keep current evaluation state and prevent any other indirect changes to it.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def polyClipboard(*args, clear: bool = ..., cl: bool = ..., color: bool = ..., clr: bool = ..., copy: bool = ..., cp: bool = ..., paste: bool = ..., ps: bool = ..., shader: bool = ..., sh: bool = ..., uvCoordinates: bool = ..., uv: bool = ...) -> Any:
    r"""
    The command allows the user to copy and paste certain polygonal
    attributes to a clipboard. These attributes are:
     1) Shader (shading engine) assignment.
     2) Texture coordinate (UV) assignment.
     3) Color value assignment.
    Any combination of attributes can be chosen for the copy or
    paste operation. If the attribute has not been copied
    to the clipboard, then naturally it cannot be pasted from
    the clipboard.
    The copy option will copy the attribute assignments from
    a single source polygonal dag object or polygon component.
    If the source does not have the either UV or color attributes,
    then nothing will be copied to the clipboard.
    The paste option will paste the attribute assignments to
    one or more polygon components or polygonal dag objects.
    If the destination does not have either UV or color attributes,
    then new values will be assigned as needed.
    Additionally, there is the option to clear the clipboard
    contents

    Args:
        clear | cl: (create) - When used, will mean to clear the specified attribute argument(s).
        color | clr: (create) - When used, will be to copy or paste color attributes
        copy | cp: (create) - When used, will mean to copy the specified attribute argument(s).
        paste | ps: (create) - When used, will mean to paste the specified attribute argument(s).
        shader | sh: (create) - When used, will be to copy or paste shader attributes
        uvCoordinates | uv: (create) - When used, will be to copy or paste texture coordinate attributes
    """
    ...


def polyCloseBorder(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Closes open borders of objects. For each border edge given,
    a face is created to fill the hole the edge lies on.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def polyCollapseEdge(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Turns each selected edge into a point.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def polyCollapseFacet(*args, areaThreshold: Optional[Union[float, bool]] = ..., at: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., useAreaThreshold: bool = ..., uat: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Turns each selected facet into a point.

    Args:
        areaThreshold | at: (create, edit, query) - Area threshold to determine whether faces should be collapsed. Attribute is ignored unless useAreaThreshold is set to true. Default: 0.1
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        useAreaThreshold | uat: (create, edit, query) - If true only collapse faces with area less than the area threshold, otherwise collapse all faces regardless of area Default: false
    """
    ...


def polyCollapseTweaks(*args, hasVertexTweaks: bool = ..., hvt: bool = ..., query: bool = ...) -> Any:
    r"""
    A command that updates a mesh's vertex tweaks by applying its tweak data
    (stored on the mesh node) onto its respective vertex data.
    
    This command is only useful in cases where no construction history is associated
    with the shape node.
    
    If a mesh name is not specified as input, a singly selected mesh (if any) will
    have its tweaked vertices baked.

    Args:
        hasVertexTweaks | hvt: (create, query) - Determines whether an individual mesh has vertex tweaks.
    """
    ...


def polyColorBlindData(*args, aboveMaxColorBlue: Optional[Union[float, bool]] = ..., amb: Optional[Union[float, bool]] = ..., aboveMaxColorGreen: Optional[Union[float, bool]] = ..., amg: Optional[Union[float, bool]] = ..., aboveMaxColorRed: Optional[Union[float, bool]] = ..., amr: Optional[Union[float, bool]] = ..., attrName: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., belowMinColorBlue: Optional[Union[float, bool]] = ..., bmb: Optional[Union[float, bool]] = ..., belowMinColorGreen: Optional[Union[float, bool]] = ..., bmg: Optional[Union[float, bool]] = ..., belowMinColorRed: Optional[Union[float, bool]] = ..., bmr: Optional[Union[float, bool]] = ..., clashColorBlue: Optional[Union[float, bool]] = ..., ccb: Optional[Union[float, bool]] = ..., clashColorGreen: Optional[Union[float, bool]] = ..., ccg: Optional[Union[float, bool]] = ..., clashColorRed: Optional[Union[float, bool]] = ..., ccr: Optional[Union[float, bool]] = ..., colorBlue: Optional[Union[float, bool]] = ..., cb: Optional[Union[float, bool]] = ..., colorGreen: Optional[Union[float, bool]] = ..., cg: Optional[Union[float, bool]] = ..., colorRed: Optional[Union[float, bool]] = ..., cr: Optional[Union[float, bool]] = ..., dataType: Optional[Union[str, bool]] = ..., dt: Optional[Union[str, bool]] = ..., enableFalseColor: bool = ..., efc: bool = ..., maxColorBlue: Optional[Union[float, bool]] = ..., mxb: Optional[Union[float, bool]] = ..., maxColorGreen: Optional[Union[float, bool]] = ..., mxg: Optional[Union[float, bool]] = ..., maxColorRed: Optional[Union[float, bool]] = ..., mxr: Optional[Union[float, bool]] = ..., maxValue: Optional[Union[float, bool]] = ..., mxv: Optional[Union[float, bool]] = ..., minColorBlue: Optional[Union[float, bool]] = ..., mnb: Optional[Union[float, bool]] = ..., minColorGreen: Optional[Union[float, bool]] = ..., mng: Optional[Union[float, bool]] = ..., minColorRed: Optional[Union[float, bool]] = ..., mnr: Optional[Union[float, bool]] = ..., minValue: Optional[Union[float, bool]] = ..., mnv: Optional[Union[float, bool]] = ..., mode: Optional[Union[int, bool]] = ..., m: Optional[Union[int, bool]] = ..., noColorBlue: Optional[Union[float, bool]] = ..., ncb: Optional[Union[float, bool]] = ..., noColorGreen: Optional[Union[float, bool]] = ..., ncg: Optional[Union[float, bool]] = ..., noColorRed: Optional[Union[float, bool]] = ..., ncr: Optional[Union[float, bool]] = ..., numIdTypes: Optional[Union[int, bool]] = ..., num: Optional[Union[int, bool]] = ..., queryMode: bool = ..., q: bool = ..., typeId: Optional[Union[int, bool]] = ..., id: Optional[Union[int, bool]] = ..., useMax: bool = ..., umx: bool = ..., useMin: bool = ..., umn: bool = ..., value: Optional[Union[str, bool]] = ..., v: Optional[Union[str, bool]] = ...) -> Any:
    r"""
    This command applies false color to the selected polygonal components
    and objects, depending on whether or not blind data exists for the
    selected components (or, in the case of poly objects, dynamic
    attributes), and, depending on the color mode indicated, what the
    values are. It is possible to color objects based on whether or not
    the data exists, if the data matches a specific value or range of
    values, or grayscale color the data according to what the actual value
    is in relation to the specified min and max. This command also has a
    query mode in which the components and/or objects are returned in a
    string array to allow for selection filtering.

    Args:
        aboveMaxColorBlue | amb: (create, multiuse) - Specifies blue component of color to use for data that is above max
        aboveMaxColorGreen | amg: (create, multiuse) - Specifies green component of color to use for data that is above max
        aboveMaxColorRed | amr: (create, multiuse) - Specifies red component of color to use for data that is above max
        attrName | n: (create, multiuse) - Specifies the name of the data that is being examined by this command.
        belowMinColorBlue | bmb: (create, multiuse) - Specifies blue component of color to use for data that is below min
        belowMinColorGreen | bmg: (create, multiuse) - Specifies green component of color to use for data that is below min
        belowMinColorRed | bmr: (create, multiuse) - Specifies red component of color to use for data that is below min
        clashColorBlue | ccb: (create) - Specifies blue component color to use for data which clashes
        clashColorGreen | ccg: (create) - Specifies green component color to use for data which clashes
        clashColorRed | ccr: (create) - Specifies red component color to use for data which clashes
        colorBlue | cb: (create, multiuse) - Specifies blue component of color to use for given data
        colorGreen | cg: (create, multiuse) - Specifies green component of color to use for given data
        colorRed | cr: (create, multiuse) - Specifies red component of color to use for given data
        dataType | dt: (create, multiuse) - Specifies the type for this id
        enableFalseColor | efc: (create) - Turns false coloring on or off for all poly objects in the scene
        maxColorBlue | mxb: (create, multiuse) - Specifies blue component of color to use for max value for grayscale
        maxColorGreen | mxg: (create, multiuse) - Specifies green component of color to use for max value for grayscale
        maxColorRed | mxr: (create, multiuse) - Specifies red component of color to use for max value for grayscale
        maxValue | mxv: (create, multiuse) - Specifies the max value for grayscale or discrete range data
        minColorBlue | mnb: (create, multiuse) - Specifies blue component of color to use for min value for grayscale
        minColorGreen | mng: (create, multiuse) - Specifies green component of color to use for min value for grayscale
        minColorRed | mnr: (create, multiuse) - Specifies red component of color to use for min value for grayscale
        minValue | mnv: (create, multiuse) - Specifies the min value for grayscale or discrete range data
        mode | m: (create, multiuse) - Specifies the mode:  0 : binary - only components and objects that have the data will be colored 1 : discrete value - a value is specified. Data that matches this value will be colored 2 : discrete range - values that fall within the given range will be colored 3 : unsigned set mode - if ( givenValue & actualValue ) then data will be colored 4 : unsigned not set mode - if ( !(givenValue & actualValue) ) then data will be colored 5 : unsigned equal mode - if ( givenValue == actualValue ) then data will be colored 6 : grayscale mode - a min value, max value, min color, max color, below min color, and     above max color are given. Data is colored according to how it relates to these values. 7 : as color mode - if the blind data consists of 3 doubles, ranged 0-1, the components are colored as the data specifies
        noColorBlue | ncb: (create) - Specifies blue component of color to use for no data assigned
        noColorGreen | ncg: (create) - Specifies green component of color to use for no data assigned
        noColorRed | ncr: (create) - Specifies red component of color to use for no data assigned
        numIdTypes | num: (create, multiuse) - Specifies how many attrs are in this id type
        queryMode | q: (create) - If on, do not color and return selection as string array instead. Any data that would be colored normally (except for 'no color' and out of range colors) is returned
        typeId | id: (create, multiuse) - Specifies the typeId of the BlindData type being created
        useMax | umx: (create, multiuse) - Specifies whether the max should be used for discrete ranges
        useMin | umn: (create, multiuse) - Specifies whether the min should be used for discrete ranges
        value | v: (create, multiuse) - The value of the data
    """
    ...


def polyColorDel(*args, caching: bool = ..., cch: bool = ..., colorSetName: Optional[Union[str, bool]] = ..., cls: Optional[Union[str, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Deletes color from selected components.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        colorSetName | cls: (create, edit, query) - The name of the color set to work on
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def polyColorMod(*args, alphaScale_FloatValue: Optional[Union[float, bool]] = ..., afv: Optional[Union[float, bool]] = ..., alphaScale_Interp: Optional[Union[int, bool]] = ..., ai: Optional[Union[int, bool]] = ..., alphaScale_Position: Optional[Union[float, bool]] = ..., ap: Optional[Union[float, bool]] = ..., baseColorName: Optional[Union[str, bool]] = ..., bcn: Optional[Union[str, bool]] = ..., blueScale_FloatValue: Optional[Union[float, bool]] = ..., bfv: Optional[Union[float, bool]] = ..., blueScale_Interp: Optional[Union[int, bool]] = ..., bi: Optional[Union[int, bool]] = ..., blueScale_Position: Optional[Union[float, bool]] = ..., bp: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., greenScale_FloatValue: Optional[Union[float, bool]] = ..., gfv: Optional[Union[float, bool]] = ..., greenScale_Interp: Optional[Union[int, bool]] = ..., gi: Optional[Union[int, bool]] = ..., greenScale_Position: Optional[Union[float, bool]] = ..., gp: Optional[Union[float, bool]] = ..., huev: Optional[Union[float, bool]] = ..., h: Optional[Union[float, bool]] = ..., intensityScale_FloatValue: Optional[Union[float, bool]] = ..., nfv: Optional[Union[float, bool]] = ..., intensityScale_Interp: Optional[Union[int, bool]] = ..., ni: Optional[Union[int, bool]] = ..., intensityScale_Position: Optional[Union[float, bool]] = ..., np: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., redScale_FloatValue: Optional[Union[float, bool]] = ..., rfv: Optional[Union[float, bool]] = ..., redScale_Interp: Optional[Union[int, bool]] = ..., ri: Optional[Union[int, bool]] = ..., redScale_Position: Optional[Union[float, bool]] = ..., rp: Optional[Union[float, bool]] = ..., satv: Optional[Union[float, bool]] = ..., s: Optional[Union[float, bool]] = ..., value: Optional[Union[float, bool]] = ..., v: Optional[Union[float, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Modifies the attributes of a poly color set.

    Args:
        alphaScale_FloatValue | afv: (create, edit, query) - ?????
        alphaScale_Interp | ai: (create, edit, query) - ????? Default: 0
        alphaScale_Position | ap: (create, edit, query) - ?????
        baseColorName | bcn: (create) - The name of the color set to be modified.
        blueScale_FloatValue | bfv: (create, edit, query) - ?????
        blueScale_Interp | bi: (create, edit, query) - ????? Default: 0
        blueScale_Position | bp: (create, edit, query) - ?????
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        greenScale_FloatValue | gfv: (create, edit, query) - ?????
        greenScale_Interp | gi: (create, edit, query) - ????? Default: 0
        greenScale_Position | gp: (create, edit, query) - ?????
        huev | h: (create, edit, query) - Hue  rotates hue value of the final color. Default: 0.0
        intensityScale_FloatValue | nfv: (create, edit, query) - ?????
        intensityScale_Interp | ni: (create, edit, query) - ????? Default: 0
        intensityScale_Position | np: (create, edit, query) - ?????
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        redScale_FloatValue | rfv: (create, edit, query) - ?????
        redScale_Interp | ri: (create, edit, query) - ????? Default: 0
        redScale_Position | rp: (create, edit, query) - ?????
        satv | s: (create, edit, query) - Sat scales the staturation of the final color. Default: 1.0
        value | v: (create, edit, query) - Value scales the final color value. Default: 1.0
    """
    ...


def polyColorPerVertex(*args, alpha: Optional[Union[float, bool]] = ..., a: Optional[Union[float, bool]] = ..., clamped: bool = ..., cla: bool = ..., colorB: Optional[Union[float, bool]] = ..., b: Optional[Union[float, bool]] = ..., colorDisplayOption: bool = ..., cdo: bool = ..., colorG: Optional[Union[float, bool]] = ..., g: Optional[Union[float, bool]] = ..., colorR: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., colorRGB: Optional[Union[Tuple[float, float, float], bool]] = ..., rgb: Optional[Union[Tuple[float, float, float], bool]] = ..., notUndoable: bool = ..., nun: bool = ..., relative: bool = ..., rel: bool = ..., remove: bool = ..., rem: bool = ..., representation: Optional[Union[int, bool]] = ..., rpt: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Command associates color(rgb and alpha) with vertices on polygonal objects.
    When used with the query flag, it returns the color associated with the
    specified components.

    Args:
        alpha | a: (create, edit, query) - Specifies the alpha channel of color
        clamped | cla: (create, edit, query) - This flag specifies if the color set will truncate any value that is outside 0 to 1 range.
        colorB | b: (create, edit, query) - Specifies the B channel of color
        colorDisplayOption | cdo: (create, edit, query) - Change the display options on the mesh to display the vertex colors.
        colorG | g: (create, edit, query) - Specifies the G channel of color
        colorR | r: (create, edit, query) - Specifies the R channel of color
        colorRGB | rgb: (create, edit, query) - Specifies the RGB channels of color
        notUndoable | nun: (create, edit, query) - Execute the command, but without having the command be undoable. This option will greatly improve performance for large numbers of object. This will make the command not undoable regardless of whether undo has been enabled or not.
        relative | rel: (create, edit, query) - When used, the color values specified are added relative to the current values.
        remove | rem: (create, edit, query) - When used, the color values are removed from the selected or specified objects or components. This option only supports meshes with no construction history, or meshes whose construction history includes a recent polyColorPerVertexNode. For meshes whose construction history includes a polgon operation the polyColorPerVertexNode, consider using the polyColorDel command instead
        representation | rpt: (create, edit, query) - This flag corresponds to the color channels to used, for example A(alpha only), RGB, and RGBA.
    """
    ...


def polyColorSet(*args, allColorSets: bool = ..., acs: bool = ..., clamped: bool = ..., cla: bool = ..., colorSet: Optional[Union[str, bool]] = ..., cs: Optional[Union[str, bool]] = ..., copy: bool = ..., cp: bool = ..., create: bool = ..., cr: bool = ..., currentColorSet: bool = ..., ccs: bool = ..., currentPerInstanceSet: bool = ..., cpi: bool = ..., delete: bool = ..., d: bool = ..., newColorSet: Optional[Union[str, bool]] = ..., nc: Optional[Union[str, bool]] = ..., perInstance: bool = ..., pi: bool = ..., rename: bool = ..., rn: bool = ..., representation: Optional[Union[str, bool]] = ..., rpt: Optional[Union[str, bool]] = ..., shareInstances: bool = ..., si: bool = ..., unshared: bool = ..., us: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Command to do the following to color sets:
    
    
     delete an existing color set. 
     rename an existing color set. 
     create a new empty color set. 
     set the current color set to a pre-existing color set. 
     modify sharing between instances of per-instance color sets. 
     query the current color set. 
     query the names of all color sets. 
     query the name(s) along with representation value(s) or clamped value(s) of all color sets. 
     query the representation value or clamped value of the current color set.

    Args:
        allColorSets | acs: (create, edit, query) - This flag when used in a query will return a list of all of the color set names
        clamped | cla: (create, edit, query) - This flag specifies if the color set will truncate any value that is outside 0 to 1 range.
        colorSet | cs: (create, edit, query) - Specifies the name of the color set that this command needs to work on. This flag has to be specified for this command to do anything meaningful other than query the current color set.
        copy | cp: (create, edit, query) - This flag when used will result in the copying of the color set corresponding to name specified with the colorSet flag to the colorSet corresponding to the name specified with the newcolorSet flag
        create | cr: (create, edit, query) - This flag when used will result in the creation of an empty color set corresponding to the name specified with the colorSet flag. If a color set with that name already exists, then no new color set will be created.
        currentColorSet | ccs: (create, edit, query) - This flag when used will set the current color set that the object needs to work on, to be the color set corresponding to the name specified with the colorSet flag. This does require that a colorSet with the specified name exist. When queried, this returns the current color set.
        currentPerInstanceSet | cpi: (edit, query) - This is a query-only flag for use when the current color set is a per-instance color set family. This returns the member of the set family that corresponds to the currently select instance.
        delete | d: (create, edit, query) - This flag when used will result in the deletion of the color set corresponding to the name specified with the colorSet flag.
        newColorSet | nc: (create, edit, query) - Specifies the name that the color set corresponding to the name specified with the colorSet flag, needs to be renamed to.
        perInstance | pi: (create, edit, query) - This flag can be used in conjunction with the create flag to indicate whether or not the color set is per-instance. When you create a per-instance color set, the set will be applied as shared between all selected instances of the shape unless the unshared flag is used. The perInstance flag can be used in query mode with the currentColorSet or allColorSets flag to indicate that the set family names (i.e. not containing instance identifiers) will be returned by the query. 			In query mode, this flag can accept a value.
        rename | rn: (create, edit, query) - This flag when used will result in the renaming of the color set corresponding to the name specified with the colorSet flag to the name specified using the newColorSet flag.
        representation | rpt: (create, edit, query) - This flag corresponds to the color channels to used, for example A(alpha only), RGB, and RGBA.
        shareInstances | si: (create, edit, query) - This flag is used to modify the sharing of per-instance color sets within a given color set family so that all selected instances share the specified set. In query mode, it returns a list of the instances that share the set specified by the colorSet flag.
        unshared | us: (create, edit, query) - This flag can be used in conjunction with the create and perInstance flags to indicate that the newly created per-instance set should be created with a separate set per instance.
    """
    ...


def polyCompare(*args, colorSetIndices: bool = ..., ic: bool = ..., colorSets: bool = ..., c: bool = ..., edges: bool = ..., e: bool = ..., faceDesc: bool = ..., fd: bool = ..., userNormals: bool = ..., un: bool = ..., uvSetIndices: bool = ..., iuv: bool = ..., uvSets: bool = ..., uv: bool = ..., vertices: bool = ..., v: bool = ...) -> Any:
    r"""
    Compares two Polygonal Geometry objects with a fine control on what to compare.
    If no objects are specified in the command line, then the
    objects from the active list are used.
    Default behaviour is to compare all flags.
    Use MEL script polyCompareTwoObjects.mel to get formatted output from this command.

    Args:
        colorSetIndices | ic: (create) - Compare poly1, poly2 for matching Color Indices.
        colorSets | c: (create) - Compare poly1, poly2 for matching Color Sets.
        edges | e: (create) - Compare poly1, poly2 for matching Edges.
        faceDesc | fd: (create) - Compare poly1, poly2 for matching Face Descriptions. Face descriptions describe the topology of a face, for example number and orientation of edges, number of topology of any holes in the face etc.
        userNormals | un: (create) - Compare poly1, poly2 for matching User Normals.
        uvSetIndices | iuv: (create) - Compare poly1, poly2 for matching UV Indices.
        uvSets | uv: (create) - Compare poly1, poly2 for matching UV Sets.
        vertices | v: (create) - Compare poly1, poly2 for matching Vertices.
    """
    ...


def polyCone(*args, axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createUVs: Optional[Union[int, bool]] = ..., cuv: Optional[Union[int, bool]] = ..., height: Optional[Union[float, bool]] = ..., h: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., roundCap: bool = ..., rcp: bool = ..., subdivisionsAxis: Optional[Union[int, bool]] = ..., sa: Optional[Union[int, bool]] = ..., subdivisionsCap: Optional[Union[int, bool]] = ..., sc: Optional[Union[int, bool]] = ..., subdivisionsHeight: Optional[Union[int, bool]] = ..., sh: Optional[Union[int, bool]] = ..., subdivisionsX: Optional[Union[int, bool]] = ..., sx: Optional[Union[int, bool]] = ..., subdivisionsY: Optional[Union[int, bool]] = ..., sy: Optional[Union[int, bool]] = ..., subdivisionsZ: Optional[Union[int, bool]] = ..., sz: Optional[Union[int, bool]] = ..., texture: bool = ..., tx: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The cone command creates a new polygonal cone.

    Args:
        axis | ax: (create, edit, query) - This flag specifies the primitive axis used to build the cone. Q: When queried, this flag returns a float[3].
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createUVs | cuv: (create, edit, query) - Create UVs or not. 0: No UVs 1: No Normalization 2: Normalize 3: Normalize and Preserve Aspect Ratio Default: 2
        height | h: (create, edit, query) - Height of the cone. Default: 2.0
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        object | o: (create) - Create the result, or just the dependency node (where applicable).
        radius | r: (create, edit, query) - Radius of the cone. Default: 1.0
        roundCap | rcp: (create, edit, query) - To indicate whether we need a round cap Default: false
        subdivisionsAxis | sa: (create, edit, query) - Subdivisions around the axis. Default: 20
        subdivisionsCap | sc: (create, edit, query) - Subdivisions on the bottom cap. Default: 0
        subdivisionsHeight | sh: (create, edit, query) - Subdivisions along the height. Default: 1
        subdivisionsX | sx: (create, edit, query) - This specifies the number of subdivisions in the X direction for the cone. C: Default is 20. Q: When queried, this flag returns an int.
        subdivisionsY | sy: (create, edit, query) - This flag specifies the number of subdivisions in the Y direction for the cone. C: Default is 1. Q: When queried, this flag returns an int.
        subdivisionsZ | sz: (create, edit, query) - This flag specifies the number of subdivisions in the Z direction for the cone. C: Default is 0. Q: When queried, this flag returns an int.
        texture | tx: (create, edit, query) - Apply texture or not. Default: true
    """
    ...


def polyConnectComponents(*args, adjustEdgeFlow: Optional[Union[float, bool]] = ..., aef: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., insertWithEdgeFlow: bool = ..., ief: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Splits polygon edges according to the selected components.
    The selected components are gathered into connected 'paths' that define continuous splits.
    Mixed components (vertices, edges and faces) can be used at once.
    The connection rules are:
    * Edges can connect to other edges in the same face
    or to vertices in the same face (that are not in the edge itself)
    or to faces connected to other edges in the same face.
    * Vertices can connect to edges (as above)
    or to vertices in the same face (that are not joined to the first vertex by an edge)
    or to faces adjacent to a face that uses the vertex (except those that also use the vertex).
    * Faces can connect to vertices or edges (as above)
    or to adjacent faces.

    Args:
        adjustEdgeFlow | aef: (create, edit, query) - The weight value of the edge vertices to be positioned.
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        insertWithEdgeFlow | ief: (create, edit, query) - True to enable edge flow. Otherwise, the edge flow is disabled.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def polyContourProjection(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createNewMap: bool = ..., cm: bool = ..., flipRails: bool = ..., fr: bool = ..., insertBeforeDeformers: bool = ..., ibd: bool = ..., method: Optional[Union[int, bool]] = ..., m: Optional[Union[int, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., offset0: Optional[Union[float, bool]] = ..., o0: Optional[Union[float, bool]] = ..., offset1: Optional[Union[float, bool]] = ..., o1: Optional[Union[float, bool]] = ..., offset2: Optional[Union[float, bool]] = ..., o2: Optional[Union[float, bool]] = ..., offset3: Optional[Union[float, bool]] = ..., o3: Optional[Union[float, bool]] = ..., reduceShear: Optional[Union[float, bool]] = ..., rs: Optional[Union[float, bool]] = ..., smoothness0: Optional[Union[float, bool]] = ..., s0: Optional[Union[float, bool]] = ..., smoothness1: Optional[Union[float, bool]] = ..., s1: Optional[Union[float, bool]] = ..., smoothness2: Optional[Union[float, bool]] = ..., s2: Optional[Union[float, bool]] = ..., smoothness3: Optional[Union[float, bool]] = ..., s3: Optional[Union[float, bool]] = ..., userDefinedCorners: bool = ..., udc: bool = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Performs a contour stretch UV projection onto an object.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createNewMap | cm: (create) - Set to true if a new map should be created
        flipRails | fr: (create, edit, query) - If true, flip which curves are the rails of the birail surface.
        insertBeforeDeformers | ibd: (create) - Set to true if the new node created should inserted before any deformer nodes.
        method | m: (create, edit, query) - Sets which projection method to use. Valid values are 0: Walk Contours 1: NURBS Projection
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        offset0 | o0: (create, edit, query) - Sets the offset on edge 0 of the NURBS surface.
        offset1 | o1: (create, edit, query) - Sets the offset on edge 1 of the NURBS surface.
        offset2 | o2: (create, edit, query) - Sets the offset on edge 2 of the NURBS surface.
        offset3 | o3: (create, edit, query) - Sets the offset on edge 3 of the NURBS surface.
        reduceShear | rs: (create, edit, query) - Sets the 'reduce shear' parameter of the projection.
        smoothness0 | s0: (create, edit, query) - Sets the smoothness of edge 0 of the NURBS surface.
        smoothness1 | s1: (create, edit, query) - Sets the smoothness of edge 1 of the NURBS surface.
        smoothness2 | s2: (create, edit, query) - Sets the smoothness of edge 2 of the NURBS surface.
        smoothness3 | s3: (create, edit, query) - Sets the smoothness of edge 3 of the NURBS surface.
        userDefinedCorners | udc: (create, edit, query) - If true, the four vertices specified by user will be taken as corners to do the projection.
        uvSetName | uvs: (create) - Name of the UV set to be created
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyCopyUV(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createNewMap: bool = ..., cm: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ..., uvSetNameInput: Optional[Union[str, bool]] = ..., uvi: Optional[Union[str, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Copy some UVs from a UV set into another.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createNewMap | cm: (create) - Set to true if a new map should be created
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        uvSetName | uvs: (create) - Name of the UV set to be created
        uvSetNameInput | uvi: (create, edit, query) - Specifies name of the input uv set to read the UV description from. Default is the current UV set.
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyCrease(*args, createHistory: bool = ..., ch: bool = ..., operation: Optional[Union[int, bool]] = ..., op: Optional[Union[int, bool]] = ..., relativeValue: Optional[Union[float, bool]] = ..., rv: Optional[Union[float, bool]] = ..., value: Optional[Union[float, bool]] = ..., v: Optional[Union[float, bool]] = ..., vertexValue: Optional[Union[float, bool]] = ..., vv: Optional[Union[float, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Command to set the crease values on the edges or vertices
    of a poly.  The crease values are used by the smoothing
    algorithm.

    Args:
        createHistory | ch: (create, edit, query) - For objects that have no construction history, this flag can be used to force the creation of construction history for creasing.  By default, history is not created if the object has no history.  Regardless of this flag, history is always created if the object already has history.
        operation | op: (create, edit, query) - Operation to perform.  Valid values are: 0: Crease the specified components. 1: Remove the crease values for the specified components. 2: Remove all crease values from the mesh. Default is 0.
        relativeValue | rv: (create, edit, query) - Specifies a new relative value for all selected vertex and edge components. This flag can not be used at the same time as either the value or vertexValue flags.
        value | v: (create, edit, multiuse, query) - Specifies the crease value for the selected edge components. When specified multiple times, the values are assigned respectively to the specified edges.
        vertexValue | vv: (create, edit, multiuse, query) - Specifies the crease value for the selected vertex components. When specified multiple times, the values are assigned respectively to the specified vertices.
    """
    ...


def polyCreateFacet(*args, constructionHistory: bool = ..., ch: bool = ..., hole: bool = ..., hl: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., point: Optional[Union[List[Union[float, List[float]]], bool]] = ..., p: Optional[Union[List[Union[float, List[float]]], bool]] = ..., subdivision: Optional[Union[int, bool]] = ..., s: Optional[Union[int, bool]] = ..., texture: Optional[Union[int, bool]] = ..., tx: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Create a new polygonal object with the specified face, which will be closed.
    List of arguments must have at least 3 points.

    Args:
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        hole | hl: (create, multiuse) - Add a hole. The following points will define a hole. Holes can be defined either clockwise or counterclockwise.  Note that this flag is not recommended for use in Python.  When specifying facets with the point flag in Python, pass in an empty point "()" when you want to start specifying a hole.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        point | p: (create, multiuse) - Adds a new point to the face. Coordinates of points are given in world reference.  The point flag may also be passed with no arguments.  That indicates that the following points will specify a hole.  Passing the point flag with no arguments is the same as using the "hole" flag, except that it will work in Python.
        subdivision | s: (create, edit, query) - This flag specifies the level of subdivision. Subdivides edges into the given number of edges. C: Default is 1 (no subdivision). Q: When queried, this flag returns an int.
        texture | tx: (create, edit, query) - Specifies how the face is mapped.  0 - None; 1 - Normalize; 2 - Unitize C: Default is 0 (no mapping). Q: When queried, this flag returns an int
    """
    ...


def polyCube(*args, axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createUVs: Optional[Union[int, bool]] = ..., cuv: Optional[Union[int, bool]] = ..., depth: Optional[Union[float, bool]] = ..., d: Optional[Union[float, bool]] = ..., height: Optional[Union[float, bool]] = ..., h: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., subdivisionsDepth: Optional[Union[int, bool]] = ..., sd: Optional[Union[int, bool]] = ..., subdivisionsHeight: Optional[Union[int, bool]] = ..., sh: Optional[Union[int, bool]] = ..., subdivisionsWidth: Optional[Union[int, bool]] = ..., sw: Optional[Union[int, bool]] = ..., subdivisionsX: Optional[Union[int, bool]] = ..., sx: Optional[Union[int, bool]] = ..., subdivisionsY: Optional[Union[int, bool]] = ..., sy: Optional[Union[int, bool]] = ..., subdivisionsZ: Optional[Union[int, bool]] = ..., sz: Optional[Union[int, bool]] = ..., texture: Optional[Union[int, bool]] = ..., tx: Optional[Union[int, bool]] = ..., width: Optional[Union[float, bool]] = ..., w: Optional[Union[float, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The cube command creates a new polygonal cube.

    Args:
        axis | ax: (create, edit, query) - This flag specifies the primitive axis used to build the cube. Q: When queried, this flag returns a float[3].
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createUVs | cuv: (create, edit, query) - Create UVs or not. 0: No UVs 1: No Normalization 2: Normalize Each Face Separately 3: Normalize Collectively 4: Normalize and Preserve Aspect Ratio Default: 3
        depth | d: (create, edit, query) - Depth of the cube. Default: 1.0
        height | h: (create, edit, query) - Height of the cube. Default: 1.0
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        object | o: (create) - Create the result, or just the dependency node (where applicable).
        subdivisionsDepth | sd: (create, edit, query) - Subdivisions along the depth of the cube. Default: 1
        subdivisionsHeight | sh: (create, edit, query) - Subdivisions along the height of the cube. Default: 1
        subdivisionsWidth | sw: (create, edit, query) - Subdivisions along the width of the cube. Default: 1
        subdivisionsX | sx: (create, edit, query) - This specifies the number of subdivisions in the X direction for the cube. C: Default is 1. Q: When queried, this flag returns an int.
        subdivisionsY | sy: (create, edit, query) - This flag specifies the number of subdivisions in the Y direction for the cube. C: Default is 1. Q: When queried, this flag returns an int.
        subdivisionsZ | sz: (create, edit, query) - This flag specifies the number of subdivisions in the Z direction for the cube. C: Default is 1. Q: When queried, this flag returns an int.
        texture | tx: (create, edit, query) - What texture mechanism to be applied 0=No textures; 1=Object; 2=Faces Default: 1
        width | w: (create, edit, query) - Width of the cube. Default: 1.0
    """
    ...


def polyCut(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., cutPlaneCenter: Optional[Union[Tuple[float, float, float], bool]] = ..., pc: Optional[Union[Tuple[float, float, float], bool]] = ..., cutPlaneCenterX: Optional[Union[float, bool]] = ..., pcx: Optional[Union[float, bool]] = ..., cutPlaneCenterY: Optional[Union[float, bool]] = ..., pcy: Optional[Union[float, bool]] = ..., cutPlaneCenterZ: Optional[Union[float, bool]] = ..., pcz: Optional[Union[float, bool]] = ..., cutPlaneHeight: Optional[Union[float, bool]] = ..., ph: Optional[Union[float, bool]] = ..., cutPlaneRotate: Optional[Union[Tuple[float, float, float], bool]] = ..., ro: Optional[Union[Tuple[float, float, float], bool]] = ..., cutPlaneRotateX: Optional[Union[float, bool]] = ..., rx: Optional[Union[float, bool]] = ..., cutPlaneRotateY: Optional[Union[float, bool]] = ..., ry: Optional[Union[float, bool]] = ..., cutPlaneRotateZ: Optional[Union[float, bool]] = ..., rz: Optional[Union[float, bool]] = ..., cutPlaneSize: Optional[Union[Tuple[float, float], bool]] = ..., ps: Optional[Union[Tuple[float, float], bool]] = ..., cutPlaneWidth: Optional[Union[float, bool]] = ..., pw: Optional[Union[float, bool]] = ..., cuttingDirection: Optional[Union[str, bool]] = ..., cd: Optional[Union[str, bool]] = ..., deleteFaces: bool = ..., df: bool = ..., extractFaces: bool = ..., ef: bool = ..., extractOffset: Optional[Union[Tuple[float, float, float], bool]] = ..., eo: Optional[Union[Tuple[float, float, float], bool]] = ..., extractOffsetX: Optional[Union[float, bool]] = ..., eox: Optional[Union[float, bool]] = ..., extractOffsetY: Optional[Union[float, bool]] = ..., eoy: Optional[Union[float, bool]] = ..., extractOffsetZ: Optional[Union[float, bool]] = ..., eoz: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., onObject: bool = ..., oo: bool = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command splits a mesh, or a set of poly faces, along a plane.
    The position and orientation of the plane can be adjusted using the
    appropriate flags listed above.  In addition, the cut operation can
    also delete the faces lying on one side of the cutting plane, or
    extract those faces by an offset amount.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        cutPlaneCenter | pc: (create, edit, query) - The position of the cutting plane. Default: 0.0, 0.0, 0.0
        cutPlaneCenterX | pcx: (create, edit, query) - Cutting plane center X coord.
        cutPlaneCenterY | pcy: (create, edit, query) - Cutting plane center Y coord.
        cutPlaneCenterZ | pcz: (create, edit, query) - Cutting plane center Z coord.
        cutPlaneHeight | ph: (create, edit, query) - The height of the cutting plane
        cutPlaneRotate | ro: (create, edit, query) - The orientation of the cutting plane. Default: 0.0, 0.0, 0.0
        cutPlaneRotateX | rx: (create, edit, query) - cutting plane X rotate angle.
        cutPlaneRotateY | ry: (create, edit, query) - cutting plane Y rotate angle.
        cutPlaneRotateZ | rz: (create, edit, query) - cutting plane Z rotate angle.
        cutPlaneSize | ps: (create, edit, query) - The width and the height of the cutting plane Default: 1.0, 1.0
        cutPlaneWidth | pw: (create, edit, query) - The width of the cutting plane
        cuttingDirection | cd: (create) - This flag specifies the direction of the cutting plane. Valid values are "x", "y", "z" A value of "x" will cut the object along the YZ plane cutting through the center of the bounding box. A value of "y" will cut the object along the ZX plane cutting through the center of the bounding box. A value of "z" will cut the object along the XY plane cutting through the center of the bounding box.
        deleteFaces | df: (create, edit, query) - whether to delete the one-half of the cut-faces of the poly.  If true, they are deleted. Default: false
        extractFaces | ef: (create, edit, query) - whether to extract the cut-faces of the poly into a separate shell.  If true, they are extracted. Default: false
        extractOffset | eo: (create, edit, query) - The displacement offset of the cut faces. Default: 0.5, 0.5, 0.5
        extractOffsetX | eox: (create, edit, query) - The X-displacement offset of the cut faces.
        extractOffsetY | eoy: (create, edit, query) - The Y-displacement offset of the cut faces.
        extractOffsetZ | eoz: (create, edit, query) - The Z-displacement offset of the cut faces.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        onObject | oo: (create, edit, query) - whether to act on the entire polyObject or its selected face components Default: true
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyCylinder(*args, axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createUVs: Optional[Union[int, bool]] = ..., cuv: Optional[Union[int, bool]] = ..., height: Optional[Union[float, bool]] = ..., h: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., roundCap: bool = ..., rcp: bool = ..., subdivisionsAxis: Optional[Union[int, bool]] = ..., sa: Optional[Union[int, bool]] = ..., subdivisionsCaps: Optional[Union[int, bool]] = ..., sc: Optional[Union[int, bool]] = ..., subdivisionsHeight: Optional[Union[int, bool]] = ..., sh: Optional[Union[int, bool]] = ..., subdivisionsX: Optional[Union[int, bool]] = ..., sx: Optional[Union[int, bool]] = ..., subdivisionsY: Optional[Union[int, bool]] = ..., sy: Optional[Union[int, bool]] = ..., subdivisionsZ: Optional[Union[int, bool]] = ..., sz: Optional[Union[int, bool]] = ..., texture: Optional[Union[int, bool]] = ..., tx: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The cylinder command creates a new polygonal cylinder.

    Args:
        axis | ax: (create, edit, query) - This flag specifies the primitive axis used to build the cylinder. Q: When queried, this flag returns a float[3].
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createUVs | cuv: (create, edit, query) - Create UVs or not. 0: No UVs 1: No Normalization 2: Normalize 3: Normalize and Preserve Aspect Ratio Default: 2
        height | h: (create, edit, query) - Height of the cylinder. Default: 2.0
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        object | o: (create) - Create the result, or just the dependency node (where applicable).
        radius | r: (create, edit, query) - Radius of the cylinder. Default: 1.0
        roundCap | rcp: (create, edit, query) - To indicate whether we need a round cap Default: false
        subdivisionsAxis | sa: (create, edit, query) - Subdivisions around the axis. Default: 20
        subdivisionsCaps | sc: (create, edit, query) - Subdivisions on the caps Default: 0
        subdivisionsHeight | sh: (create, edit, query) - Subdivisions along the height. Default: 1
        subdivisionsX | sx: (create, edit, query) - This specifies the number of subdivisions in the X direction for the cylinder. C: Default is 20. Q: When queried, this flag returns an int.
        subdivisionsY | sy: (create, edit, query) - This flag specifies the number of subdivisions in the Y direction for the cylinder. C: Default is 1. Q: When queried, this flag returns an int.
        subdivisionsZ | sz: (create, edit, query) - This flag specifies the number of subdivisions in the Z direction for the cylinder. C: Default is 1. Q: When queried, this flag returns an int.
        texture | tx: (create, edit, query) - What texture mechanism to be applied 0=No textures, 1=Object, 2=Faces Default: 2
    """
    ...


def polyCylindricalProjection(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createNewMap: bool = ..., cm: bool = ..., imageCenter: Optional[Union[Tuple[float, float], bool]] = ..., ic: Optional[Union[Tuple[float, float], bool]] = ..., imageCenterX: Optional[Union[float, bool]] = ..., icx: Optional[Union[float, bool]] = ..., imageCenterY: Optional[Union[float, bool]] = ..., icy: Optional[Union[float, bool]] = ..., imageScale: Optional[Union[Tuple[float, float], bool]] = ..., imageScaleU: Optional[Union[float, bool]] = ..., isu: Optional[Union[float, bool]] = ..., imageScaleV: Optional[Union[float, bool]] = ..., isv: Optional[Union[float, bool]] = ..., insertBeforeDeformers: bool = ..., ibd: bool = ..., keepImageRatio: bool = ..., kir: bool = ..., mapDirection: Optional[Union[str, bool]] = ..., md: Optional[Union[str, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., perInstance: bool = ..., pi: bool = ..., projectionCenter: Optional[Union[Tuple[float, float, float], bool]] = ..., pc: Optional[Union[Tuple[float, float, float], bool]] = ..., projectionCenterX: Optional[Union[float, bool]] = ..., pcx: Optional[Union[float, bool]] = ..., projectionCenterY: Optional[Union[float, bool]] = ..., pcy: Optional[Union[float, bool]] = ..., projectionCenterZ: Optional[Union[float, bool]] = ..., pcz: Optional[Union[float, bool]] = ..., projectionHeight: Optional[Union[float, bool]] = ..., ph: Optional[Union[float, bool]] = ..., projectionHorizontalSweep: Optional[Union[float, bool]] = ..., phs: Optional[Union[float, bool]] = ..., projectionScale: Optional[Union[Tuple[float, float], bool]] = ..., ps: Optional[Union[Tuple[float, float], bool]] = ..., projectionScaleU: Optional[Union[float, bool]] = ..., psu: Optional[Union[float, bool]] = ..., projectionScaleV: Optional[Union[float, bool]] = ..., psv: Optional[Union[float, bool]] = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., rotationAngle: Optional[Union[float, bool]] = ..., ra: Optional[Union[float, bool]] = ..., seamCorrect: bool = ..., sc: bool = ..., smartFit: bool = ..., sf: bool = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    TpolyProjCmdBase is a base class for the command to create a mapping on the selected polygonal faces.
    Projects a cylindrical map onto an object.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createNewMap | cm: (create, query) - This flag when set true will create a new map with a the name passed in, if the map does not already exist.
        imageCenter | ic: (create, edit, query) - The center point of the 2D model layout. Default: 0.5, 0.5
        imageCenterX | icx: (create, edit, query) - Image center X coord.
        imageCenterY | icy: (create, edit, query) - Image center Y coord.
        imageScale | imageScale: (create, edit, query) - Specifies the UV scale : Enlarges or reduces the 2D version of the model in U or V space relative to the 2D centerpoint. Default: 1.0, 1.0
        imageScaleU | isu: (create, edit, query) - Specifies the UV scale : Enlarges or reduces the 2D version of the model in U or V space relative to the 2D centerpoint.
        imageScaleV | isv: (create, edit, query) - The V scale : Enlarges or reduces the 2D version of the model in V space relative to the 2D centerpoint.
        insertBeforeDeformers | ibd: (create) - This flag specifies if the projection node should be inserted before or after deformer nodes already applied to the shape. Inserting the projection after the deformer leads to texture swimming during animation and is most often undesirable. C: Default is on.
        keepImageRatio | kir: (create) - True means keep any image ratio
        mapDirection | md: (create) - This flag specifies the mapping direction. 'x', 'y' and 'z' projects the map along the corresponding axis. 'c' projects along the current camera viewing direction. 'p' does perspective projection if current camera is perspective. 'b' projects along the best plane fitting the objects selected.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        perInstance | pi: (create) - True if the new map is per-instance, otherwise it is shared.
        projectionCenter | pc: (create, edit, query) - The origin point from which the map is projected. Default: 0.0, 0.0, 0.0
        projectionCenterX | pcx: (create, edit, query) - Projection center X coord.
        projectionCenterY | pcy: (create, edit, query) - Projection center Y coord.
        projectionCenterZ | pcz: (create, edit, query) - Projection center Z coord.
        projectionHeight | ph: (create, edit, query) - The height of the map relative to the 3D projection axis
        projectionHorizontalSweep | phs: (create, edit, query) - The angle swept by the 3D projection axis
        projectionScale | ps: (create, edit, query) - The width and the height of the map relative to the 3D projection axis. Default: 180.0, 1.0
        projectionScaleU | psu: (create, edit, query) - The width of the map relative to the 3D projection axis.
        projectionScaleV | psv: (create, edit, query) - The height of the map relative to the 3D projection axis.
        radius | r: (create, edit, query) - Used by the UI : Manipulator. Default: 10.0
        rotationAngle | ra: (create, edit, query) - The for the rotation. When the angle is positive, then the map rotates counterclockwise on the mapped model, whereas when it is negative then the map rotates lockwise on the mapped model. Default: 0.0
        seamCorrect | sc: (create, edit, query) - Used to indicate fixing UV seams. Default: false
        smartFit | sf: (create) - True means use the smart fit algorithm
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyDelEdge(*args, caching: bool = ..., cch: bool = ..., cleanVertices: bool = ..., cv: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Deletes selected edges, and merges neighboring faces.
    If deletion leaves winged vertices, they may be deleted as well.
    Notice : only non border edges can be deleted.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        cleanVertices | cv: (create, edit, query) - If on : delete resulting winged vertices. C: Default is "off". Q: When queried, this flag returns an int.
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def polyDelFacet(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Deletes faces.
    If the result is split into disconnected pieces,
    the pieces (so-called shells) are still
    considered to be one object.
    Notice : The last face cannot be deleted.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def polyDelVertex(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Deletes vertices.
    Joins two edges which have a common vertex.
    The vertices must be connected to exactly two edges (so-called "winged").

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def polyDuplicateAndConnect(*args, removeOriginalFromShaders: bool = ..., ros: bool = ..., renameChildren: bool = ..., rc: bool = ...) -> Any:
    r"""
    This command duplicates the input polygonal object, connects
    up the outMesh attribute of the original polygonal shape to
    the inMesh attribute of the newly created duplicate shape and
    copies over the shader assignments from the original shape
    to the new duplicated shape.
    
    The command will fail if no objects are selected or sent as
    argument or if the object sent as argument is not a polygonal
    object.

    Args:
        removeOriginalFromShaders | ros: (create) - Used to specify if the original object should be removed from the shaders (shadingGroups) that it is a member of. The shader associations will get transferred to the duplicated object, before they are removed from the original. If this flag is specified then the original polygonal object will be drawn in wireframe mode even if all objects are being drawn in shaded mode.
        renameChildren | rc: (create) - rename the children nodes of the hierarchy, to make them unique.
    """
    ...


def polyDuplicateEdge(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., adjustEdgeFlow: Optional[Union[float, bool]] = ..., aef: Optional[Union[float, bool]] = ..., deleteEdge: bool = ..., de: bool = ..., endVertexOffset: Optional[Union[float, bool]] = ..., evo: Optional[Union[float, bool]] = ..., insertWithEdgeFlow: bool = ..., ief: bool = ..., offset: Optional[Union[float, bool]] = ..., of: Optional[Union[float, bool]] = ..., smoothingAngle: Optional[Union[float, bool]] = ..., sma: Optional[Union[float, bool]] = ..., splitType: Optional[Union[int, bool]] = ..., stp: Optional[Union[int, bool]] = ..., startVertexOffset: Optional[Union[float, bool]] = ..., svo: Optional[Union[float, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Duplicates a series of connected edges (edgeLoop)

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        adjustEdgeFlow | aef: (create, edit, query) - The weight value of the edge vertices to be positioned.
        deleteEdge | de: (create, edit, query) - When true, the end edges are deleted so the end triangles are converted to quads.
        endVertexOffset | evo: (create, edit, query) - Weight value controlling the offset of the end vertex of the edgeloop.
        insertWithEdgeFlow | ief: (create, edit, query) - True to enable edge flow. Otherwise, the edge flow is disabled.
        offset | of: (create) - Weight value controlling the relative positioning of the new edges. The range of values is [0.0, 1.0].
        smoothingAngle | sma: (create, edit, query) - Angle below which new edges will be smoothed
        splitType | stp: (create, edit, query) - Format: 0 - Absolute, 1 - Relative, 2 - Multi
        startVertexOffset | svo: (create, edit, query) - Weight value controlling the offset of the start vertex of the edgeloop.
    """
    ...


def polyEditEdgeFlow(*args, adjustEdgeFlow: Optional[Union[float, bool]] = ..., aef: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., edgeFlow: bool = ..., ef: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Edit edges of a polygonal object to respect surface curvature.

    Args:
        adjustEdgeFlow | aef: (create) - The weight value of the edge vertices to be positioned. <0: Concave 0:  Middle point 1:  Surface continuity >1: Convex Default is 1.0
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        edgeFlow | ef: (create) - True to enable edge flow. Otherwise, the edge flow is disabled. Default is true.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def polyEditUV(*args, angle: Optional[Union[float, bool]] = ..., a: Optional[Union[float, bool]] = ..., pivotU: Optional[Union[float, bool]] = ..., pu: Optional[Union[float, bool]] = ..., pivotV: Optional[Union[float, bool]] = ..., pv: Optional[Union[float, bool]] = ..., relative: bool = ..., r: bool = ..., rotateRatio: Optional[Union[float, bool]] = ..., rr: Optional[Union[float, bool]] = ..., rotation: bool = ..., rot: bool = ..., scale: bool = ..., s: bool = ..., scaleU: Optional[Union[float, bool]] = ..., su: Optional[Union[float, bool]] = ..., scaleV: Optional[Union[float, bool]] = ..., sv: Optional[Union[float, bool]] = ..., uValue: Optional[Union[float, bool]] = ..., u: Optional[Union[float, bool]] = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ..., vValue: Optional[Union[float, bool]] = ..., v: Optional[Union[float, bool]] = ..., query: bool = ...) -> Any:
    r"""
    Command edits uvs on polygonal objects. When used with the query flag, it
    returns the uv values associated with the specified components.

    Args:
        angle | a: (create, query) - Specifies the angle value (in degrees) that the uv values are to be rotated by.
        pivotU | pu: (create, query) - Specifies the pivot value, in the u direction, about which the scale or rotate is to be performed.
        pivotV | pv: (create, query) - Specifies the pivot value, in the v direction, about which the scale or rotate is to be performed.
        relative | r: (create, query) - Specifies whether this command is editing the values relative to the currently existing values. Default is true;
        rotateRatio | rr: (create, query) - Specifies the ratio value that the uv values are to be rotated by Default is 1.0
        rotation | rot: (create, query) - Specifies whether this command is editing the values with rotation values
        scale | s: (create, query) - Specifies whether this command is editing the values with scale values
        scaleU | su: (create, query) - Specifies the scale value in the u direction.
        scaleV | sv: (create, query) - Specifies the scale value in the v direction.
        uValue | u: (create, query) - Specifies the value, in the u direction - absolute if relative flag is false..
        uvSetName | uvs: (create, query) - Specifies the name of the uv set to edit uvs on. If not specified will use the current uv set if it exists.
        vValue | v: (create, query) - Specifies the value, in the v direction - absolute if relative flag is false..
    """
    ...


def polyEditUVShell(*args, angle: Optional[Union[float, bool]] = ..., a: Optional[Union[float, bool]] = ..., pivotU: Optional[Union[float, bool]] = ..., pu: Optional[Union[float, bool]] = ..., pivotV: Optional[Union[float, bool]] = ..., pv: Optional[Union[float, bool]] = ..., relative: bool = ..., r: bool = ..., rotateRatio: Optional[Union[float, bool]] = ..., rr: Optional[Union[float, bool]] = ..., rotation: bool = ..., rot: bool = ..., scale: bool = ..., s: bool = ..., scaleU: Optional[Union[float, bool]] = ..., su: Optional[Union[float, bool]] = ..., scaleV: Optional[Union[float, bool]] = ..., sv: Optional[Union[float, bool]] = ..., uValue: Optional[Union[float, bool]] = ..., u: Optional[Union[float, bool]] = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ..., vValue: Optional[Union[float, bool]] = ..., v: Optional[Union[float, bool]] = ..., query: bool = ...) -> Any:
    r"""
    Command edits uv shells on polygonal objects. When used with the query flag, it
    returns the transformation values associated with the specified components.

    Args:
        angle | a: (create, query) - Specifies the angle value (in degrees) that the uv values are to be rotated by.
        pivotU | pu: (create, query) - Specifies the pivot value, in the u direction, about which the scale or rotate is to be performed.
        pivotV | pv: (create, query) - Specifies the pivot value, in the v direction, about which the scale or rotate is to be performed.
        relative | r: (create, query) - Specifies whether this command is editing the values relative to the currently existing values. Default is true;
        rotateRatio | rr: (create, query) - Specifies the ratio value that the uv values are to be rotated by Default is 1.0
        rotation | rot: (create, query) - Specifies whether this command is editing the values with rotation values
        scale | s: (create, query) - Specifies whether this command is editing the values with scale values
        scaleU | su: (create, query) - Specifies the scale value in the u direction.
        scaleV | sv: (create, query) - Specifies the scale value in the v direction.
        uValue | u: (create, query) - Specifies the value, in the u direction - absolute if relative flag is false..
        uvSetName | uvs: (create, query) - Specifies the name of the uv set to edit uvs on. If not specified will use the current uv set if it exists.
        vValue | v: (create, query) - Specifies the value, in the v direction - absolute if relative flag is false..
    """
    ...


def polyEvaluate(*args, accurateEvaluation: bool = ..., ae: bool = ..., activeShells: bool = ..., activeUVShells: bool = ..., aus: bool = ..., area: bool = ..., a: bool = ..., boundingBox: bool = ..., b: bool = ..., boundingBox2d: bool = ..., b2: bool = ..., boundingBoxComponent: bool = ..., bc: bool = ..., boundingBoxComponent2d: bool = ..., bc2: bool = ..., displayStats: bool = ..., ds: bool = ..., edge: bool = ..., e: bool = ..., edgeComponent: bool = ..., ec: bool = ..., face: bool = ..., f: bool = ..., faceArea: bool = ..., fa: bool = ..., faceComponent: bool = ..., fc: bool = ..., format: bool = ..., fmt: bool = ..., shell: bool = ..., s: bool = ..., triangle: bool = ..., t: bool = ..., triangleComponent: bool = ..., tc: bool = ..., uvArea: bool = ..., uva: bool = ..., uvComponent: bool = ..., uvc: bool = ..., uvEdgePairs: bool = ..., uep: bool = ..., uvFaceArea: bool = ..., ufa: bool = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ..., uvShell: bool = ..., us: bool = ..., uvShellIds: bool = ..., usi: bool = ..., uvcoord: bool = ..., uv: bool = ..., uvsInShell: Optional[Union[int, bool]] = ..., uis: Optional[Union[int, bool]] = ..., vertex: bool = ..., v: bool = ..., vertexComponent: bool = ..., vc: bool = ..., worldArea: bool = ..., wa: bool = ..., worldFaceArea: bool = ..., wfa: bool = ...) -> Any:
    r"""
    Returns the required counts on the specified objects.
    If no objects are specified in the command line, then the
    objects from the active list are used.
    
    In MEL, the values are returned in the same order as the flags are set.
    Under Python, there is no concept of argument ordering, so the items are
    returned in a dictionary keyed by the name of the flag.  In Python, if only
    one item is requested, then it will not be returned in a dictionary.
    For user convenience, if no flag is set, then all values are echoed.
    
    All flags (except -fmt/format) are in fact query-flags. For
    user convenience, the -q flag may be ommitted.
    
    Some comments for non-formatted output :
    
    3d bounding boxes are returned as 3 couples of floats,
    2d ones as 2 couples of floats.
    
    if a bounding box is queried and cannot be computed (for example
    the component bounding box when no component is selected, or 2d bounding box for
    and unmapped object) 0 is returned for each array element, so that
    indices in the output array remain consistent.
    
    int values (queried by topological flags) cannot be
    mixed with float values (queried by bounding box flags).
    Thus if no flag is set, only int values are returned.

    Args:
        accurateEvaluation | ae: (create) - used to get accurate results for the bounding box computation For objects with large vertex counts, accurate evaluation takes more time
        activeShells | activeShells: (create) - returns the indices of active shells as an array of int
        activeUVShells | aus: (create) - returns the indices of active UV shells (for the current map if one is not specified) as an array of int
        area | a: (create) - returns the surface area of the object's faces in local space as a float
        boundingBox | b: (create) - returns the object's bounding box in 3d space as 6 floats in MEL: xmin xmax ymin ymax zmin zmax, or as a tuple of three pairs in Python: ((xmin,xmax), (ymin,ymax), (zmin,zmax))
        boundingBox2d | b2: (create) - returns the object's uv bounding box (for the current map if one is not specified) in 2d space as 4 floats in MEL : xmin xmax ymin ymax, or as a tuple of three pairs in Python: ((xmin,xmax), (ymin,ymax), (zmin,zmax))
        boundingBoxComponent | bc: (create) - returns the bounding box of selected components in 3d space as 6 floats in MEL : xmin xmax ymin ymax zmin zmax, or as a tuple of three pairs in Python: ((xmin,xmax), (ymin,ymax), (zmin,zmax))
        boundingBoxComponent2d | bc2: (create) - returns the bounding box of selected/specified components uv coordinates in 2d space as 4 floats in MEL : xmin xmax ymin ymax, or as a tuple of two pairs in Python: ((xmin,xmax), (ymin,ymax))
        displayStats | ds: (create) - toggles the display of poly statistics for the active View. All other flags are ignored if this flag is specified (Obsolete - refer to the headsUpDisplay command)
        edge | e: (create) - returns the number of edges as an int
        edgeComponent | ec: (create) - returns the object's number of selected edges as an int
        face | f: (create) - returns the number of faces as an int
        faceArea | fa: (create) - returns the surface area of selected/specified faces in local space as an array of float
        faceComponent | fc: (create) - returns the object's number of selected faces as an int
        format | fmt: (create) - used to display the results as an explicit sentence
        shell | s: (create) - returns the number of shells (disconnected pieces) as an int
        triangle | t: (create) - returns the number of triangles as an int
        triangleComponent | tc: (create) - returns the number of triangles of selected components as an int
        uvArea | uva: (create) - returns the UV area of the object's faces in 2d space as a float
        uvComponent | uvc: (create) - returns the object's number of selected uv coordinates as an int
        uvEdgePairs | uep: (create) - returns the pairs of UVs that are on the selected/specified edges
        uvFaceArea | ufa: (create) - returns the UV area of selected/specified faces in 2d space as an array of float
        uvSetName | uvs: (create) - used when querying texture vertices to specify the uv set.  If a uv set is not specified then the current map for the object will be used
        uvShell | us: (create) - returns the number of UV shells (for the current map if one is not specified) as an int
        uvShellIds | usi: (create) - returns the UV shell indices for selected/specified faces or UVs as an array of int (for the current map if one is not specified), one shell index per each face/UV.
        uvcoord | uv: (create) - returns the number of uv coordinates (for the current map if one is not specified) as an int
        uvsInShell | uis: (create) - returns all UVs inside specified shell(for the current map if one is not specified), use activeUVShells to get shell indices for current selection, use uvShellIds to get shell indices for specified faces or UVs
        vertex | v: (create) - returns the number of vertices as an int
        vertexComponent | vc: (create) - returns the object's number of selected vertices as an int
        worldArea | wa: (create) - returns the surface area of the object's faces in world space as a float
        worldFaceArea | wfa: (create) - returns the surface area of selected/specified faces in world space as an array of float
    """
    ...


def polyExtrudeEdge(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createCurve: bool = ..., cc: bool = ..., divisions: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., gain: Optional[Union[float, bool]] = ..., ga: Optional[Union[float, bool]] = ..., inputCurve: Optional[Union[str, bool]] = ..., inc: Optional[Union[str, bool]] = ..., keepFacesTogether: bool = ..., kft: bool = ..., localCenter: Optional[Union[int, bool]] = ..., lc: Optional[Union[int, bool]] = ..., localDirection: Optional[Union[Tuple[float, float, float], bool]] = ..., ld: Optional[Union[Tuple[float, float, float], bool]] = ..., localDirectionX: Optional[Union[float, bool]] = ..., ldx: Optional[Union[float, bool]] = ..., localDirectionY: Optional[Union[float, bool]] = ..., ldy: Optional[Union[float, bool]] = ..., localDirectionZ: Optional[Union[float, bool]] = ..., ldz: Optional[Union[float, bool]] = ..., localRotate: Optional[Union[Tuple[float, float, float], bool]] = ..., lr: Optional[Union[Tuple[float, float, float], bool]] = ..., localRotateX: Optional[Union[float, bool]] = ..., lrx: Optional[Union[float, bool]] = ..., localRotateY: Optional[Union[float, bool]] = ..., lry: Optional[Union[float, bool]] = ..., localRotateZ: Optional[Union[float, bool]] = ..., lrz: Optional[Union[float, bool]] = ..., localScale: Optional[Union[Tuple[float, float, float], bool]] = ..., ls: Optional[Union[Tuple[float, float, float], bool]] = ..., localScaleX: Optional[Union[float, bool]] = ..., lsx: Optional[Union[float, bool]] = ..., localScaleY: Optional[Union[float, bool]] = ..., lsy: Optional[Union[float, bool]] = ..., localScaleZ: Optional[Union[float, bool]] = ..., lsz: Optional[Union[float, bool]] = ..., localTranslate: Optional[Union[Tuple[float, float, float], bool]] = ..., lt: Optional[Union[Tuple[float, float, float], bool]] = ..., localTranslateX: Optional[Union[float, bool]] = ..., ltx: Optional[Union[float, bool]] = ..., localTranslateY: Optional[Union[float, bool]] = ..., lty: Optional[Union[float, bool]] = ..., localTranslateZ: Optional[Union[float, bool]] = ..., ltz: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., offset: Optional[Union[float, bool]] = ..., off: Optional[Union[float, bool]] = ..., pivot: Optional[Union[Tuple[float, float, float], bool]] = ..., pvt: Optional[Union[Tuple[float, float, float], bool]] = ..., pivotX: Optional[Union[float, bool]] = ..., pvx: Optional[Union[float, bool]] = ..., pivotY: Optional[Union[float, bool]] = ..., pvy: Optional[Union[float, bool]] = ..., pivotZ: Optional[Union[float, bool]] = ..., pvz: Optional[Union[float, bool]] = ..., random: Optional[Union[float, bool]] = ..., ran: Optional[Union[float, bool]] = ..., rotate: Optional[Union[Tuple[float, float, float], bool]] = ..., ro: Optional[Union[Tuple[float, float, float], bool]] = ..., rotateX: Optional[Union[float, bool]] = ..., rx: Optional[Union[float, bool]] = ..., rotateY: Optional[Union[float, bool]] = ..., ry: Optional[Union[float, bool]] = ..., rotateZ: Optional[Union[float, bool]] = ..., rz: Optional[Union[float, bool]] = ..., scale: Optional[Union[Tuple[float, float, float], bool]] = ..., s: Optional[Union[Tuple[float, float, float], bool]] = ..., scaleX: Optional[Union[float, bool]] = ..., sx: Optional[Union[float, bool]] = ..., scaleY: Optional[Union[float, bool]] = ..., sy: Optional[Union[float, bool]] = ..., scaleZ: Optional[Union[float, bool]] = ..., sz: Optional[Union[float, bool]] = ..., smoothingAngle: Optional[Union[float, bool]] = ..., sma: Optional[Union[float, bool]] = ..., taper: Optional[Union[float, bool]] = ..., tp: Optional[Union[float, bool]] = ..., taperCurve_FloatValue: Optional[Union[float, bool]] = ..., cfv: Optional[Union[float, bool]] = ..., taperCurve_Interp: Optional[Union[int, bool]] = ..., ci: Optional[Union[int, bool]] = ..., taperCurve_Position: Optional[Union[float, bool]] = ..., cp: Optional[Union[float, bool]] = ..., thickness: Optional[Union[float, bool]] = ..., tk: Optional[Union[float, bool]] = ..., translate: Optional[Union[Tuple[float, float, float], bool]] = ..., t: Optional[Union[Tuple[float, float, float], bool]] = ..., translateX: Optional[Union[float, bool]] = ..., tx: Optional[Union[float, bool]] = ..., translateY: Optional[Union[float, bool]] = ..., ty: Optional[Union[float, bool]] = ..., translateZ: Optional[Union[float, bool]] = ..., tz: Optional[Union[float, bool]] = ..., twist: Optional[Union[float, bool]] = ..., twt: Optional[Union[float, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Extrude edges separately or together.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createCurve | cc: (create) - If true then the operation can create a curve.
        divisions | d: (create, edit, query) - How many internal edges are creating when pulling. Default: 1
        gain | ga: (create, edit, multiuse, query) - Gain factor per component. Can be painted using Artisan. Default: 1.0
        inputCurve | inc: (create) - This flag specifies the name of the curve to be used as input for the operation.
        keepFacesTogether | kft: (create, edit, query) - How to extrude edges. If "on", extruded faces produced from the edges being extruded will be kept together. Otherwise they are pulled independently. Default: true
        localCenter | lc: (create, edit, query) - Local center on the edge : 0=Middle point, 1=Start point, 2=End point. Default: 0
        localDirection | ld: (create, edit, query) - Direction to determine X axis for local space. Default: 1.0, 0.0, 0.0
        localDirectionX | ldx: (create, edit, query) - X coord of the X axis.
        localDirectionY | ldy: (create, edit, query) - Y coord of the X axis.
        localDirectionZ | ldz: (create, edit, query) - Z coord of the X axis.
        localRotate | lr: (create, edit, query) - The local rotations. Default: 0.0, 0.0, 0.0
        localRotateX | lrx: (create, edit, query) - Local rotate X coord. The range is [0, 360].
        localRotateY | lry: (create, edit, query) - Local rotate Y coord. The range is [0, 360].
        localRotateZ | lrz: (create, edit, query) - Local rotate Z coord : Rotation along the normal. The range is [0, 360].
        localScale | ls: (create, edit, query) - Local Scale. Default: 1.0, 1.0, 1.0
        localScaleX | lsx: (create, edit, query) - Scale X coord.
        localScaleY | lsy: (create, edit, query) - Scale Y coord.
        localScaleZ | lsz: (create, edit, query) - Scale Z coord.
        localTranslate | lt: (create, edit, query) - Local translate. Default: 0.0, 0.0, 0.0
        localTranslateX | ltx: (create, edit, query) - Local translation X coord.
        localTranslateY | lty: (create, edit, query) - Local translation Y coord.
        localTranslateZ | ltz: (create, edit, query) - Local translation Z coord : Move along the normal.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        offset | off: (create, edit, query) - Edges are moved this distance in the opposite direction of the edge. Default: 0.0
        pivot | pvt: (create, edit, query) - The pivot for scaling and rotation. Default: 0.0, 0.0, 0.0
        pivotX | pvx: (create, edit, query) - Pivot X coord.
        pivotY | pvy: (create, edit, query) - Pivot Y coord.
        pivotZ | pvz: (create, edit, query) - Pivot Z coord.
        random | ran: (create, edit, query) - Random value for all parameters. Default: 0.0
        rotate | ro: (create, edit, query) - Rotation angles around X, Y, Z. Default: 0.0, 0.0, 0.0
        rotateX | rx: (create, edit, query) - Rotation angle around X.
        rotateY | ry: (create, edit, query) - Rotation angle around Y.
        rotateZ | rz: (create, edit, query) - Rotation angle around Z.
        scale | s: (create, edit, query) - Scaling vector. Default: 1.0, 1.0, 1.0
        scaleX | sx: (create, edit, query) - Scale X coord.
        scaleY | sy: (create, edit, query) - Scale Y coord.
        scaleZ | sz: (create, edit, query) - Scale Z coord.
        smoothingAngle | sma: (create, edit, query) - Angle below which new edges will be smoothed Default: kPi/6.0
        taper | tp: (create, edit, query) - Taper or Scale along the extrusion path Default: 1.0
        taperCurve_FloatValue | cfv: (create, edit, query) - ?????
        taperCurve_Interp | ci: (create, edit, query) - ????? Default: 0
        taperCurve_Position | cp: (create, edit, query) - ?????
        thickness | tk: (create, edit, query) - Edges are moved this distance in the direction of the connected face normals. Default: 0.0f
        translate | t: (create, edit, query) - Translation vector. Default: 0.0, 0.0, 0.0
        translateX | tx: (create, edit, query) - Translation X coord.
        translateY | ty: (create, edit, query) - Translation Y coord.
        translateZ | tz: (create, edit, query) - Translation Z coord.
        twist | twt: (create, edit, query) - Twist or Rotation along the extrusion path Default: 0.0
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyExtrudeFacet(*args, attraction: Optional[Union[float, bool]] = ..., att: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createCurve: bool = ..., cc: bool = ..., divisions: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., gain: Optional[Union[float, bool]] = ..., ga: Optional[Union[float, bool]] = ..., gravity: Optional[Union[Tuple[float, float, float], bool]] = ..., g: Optional[Union[Tuple[float, float, float], bool]] = ..., gravityX: Optional[Union[float, bool]] = ..., gx: Optional[Union[float, bool]] = ..., gravityY: Optional[Union[float, bool]] = ..., gy: Optional[Union[float, bool]] = ..., gravityZ: Optional[Union[float, bool]] = ..., gz: Optional[Union[float, bool]] = ..., inputCurve: Optional[Union[str, bool]] = ..., inc: Optional[Union[str, bool]] = ..., keepFacesTogether: bool = ..., kft: bool = ..., keepFacetTogether: bool = ..., xft: bool = ..., localCenter: Optional[Union[int, bool]] = ..., lc: Optional[Union[int, bool]] = ..., localDirection: Optional[Union[Tuple[float, float, float], bool]] = ..., ld: Optional[Union[Tuple[float, float, float], bool]] = ..., localDirectionX: Optional[Union[float, bool]] = ..., ldx: Optional[Union[float, bool]] = ..., localDirectionY: Optional[Union[float, bool]] = ..., ldy: Optional[Union[float, bool]] = ..., localDirectionZ: Optional[Union[float, bool]] = ..., ldz: Optional[Union[float, bool]] = ..., localRotate: Optional[Union[Tuple[float, float, float], bool]] = ..., lr: Optional[Union[Tuple[float, float, float], bool]] = ..., localRotateX: Optional[Union[float, bool]] = ..., lrx: Optional[Union[float, bool]] = ..., localRotateY: Optional[Union[float, bool]] = ..., lry: Optional[Union[float, bool]] = ..., localRotateZ: Optional[Union[float, bool]] = ..., lrz: Optional[Union[float, bool]] = ..., localScale: Optional[Union[Tuple[float, float, float], bool]] = ..., ls: Optional[Union[Tuple[float, float, float], bool]] = ..., localScaleX: Optional[Union[float, bool]] = ..., lsx: Optional[Union[float, bool]] = ..., localScaleY: Optional[Union[float, bool]] = ..., lsy: Optional[Union[float, bool]] = ..., localScaleZ: Optional[Union[float, bool]] = ..., lsz: Optional[Union[float, bool]] = ..., localTranslate: Optional[Union[Tuple[float, float, float], bool]] = ..., lt: Optional[Union[Tuple[float, float, float], bool]] = ..., localTranslateX: Optional[Union[float, bool]] = ..., ltx: Optional[Union[float, bool]] = ..., localTranslateY: Optional[Union[float, bool]] = ..., lty: Optional[Union[float, bool]] = ..., localTranslateZ: Optional[Union[float, bool]] = ..., ltz: Optional[Union[float, bool]] = ..., magnX: Optional[Union[float, bool]] = ..., mx: Optional[Union[float, bool]] = ..., magnY: Optional[Union[float, bool]] = ..., my: Optional[Union[float, bool]] = ..., magnZ: Optional[Union[float, bool]] = ..., mz: Optional[Union[float, bool]] = ..., magnet: Optional[Union[Tuple[float, float, float], bool]] = ..., m: Optional[Union[Tuple[float, float, float], bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., offset: Optional[Union[float, bool]] = ..., off: Optional[Union[float, bool]] = ..., pivot: Optional[Union[Tuple[float, float, float], bool]] = ..., pvt: Optional[Union[Tuple[float, float, float], bool]] = ..., pivotX: Optional[Union[float, bool]] = ..., pvx: Optional[Union[float, bool]] = ..., pivotY: Optional[Union[float, bool]] = ..., pvy: Optional[Union[float, bool]] = ..., pivotZ: Optional[Union[float, bool]] = ..., pvz: Optional[Union[float, bool]] = ..., random: Optional[Union[float, bool]] = ..., ran: Optional[Union[float, bool]] = ..., reverseAllFaces: bool = ..., raf: bool = ..., rotate: Optional[Union[Tuple[float, float, float], bool]] = ..., ro: Optional[Union[Tuple[float, float, float], bool]] = ..., rotateX: Optional[Union[float, bool]] = ..., rx: Optional[Union[float, bool]] = ..., rotateY: Optional[Union[float, bool]] = ..., ry: Optional[Union[float, bool]] = ..., rotateZ: Optional[Union[float, bool]] = ..., rz: Optional[Union[float, bool]] = ..., scale: Optional[Union[Tuple[float, float, float], bool]] = ..., s: Optional[Union[Tuple[float, float, float], bool]] = ..., scaleX: Optional[Union[float, bool]] = ..., sx: Optional[Union[float, bool]] = ..., scaleY: Optional[Union[float, bool]] = ..., sy: Optional[Union[float, bool]] = ..., scaleZ: Optional[Union[float, bool]] = ..., sz: Optional[Union[float, bool]] = ..., smoothingAngle: Optional[Union[float, bool]] = ..., sma: Optional[Union[float, bool]] = ..., taper: Optional[Union[float, bool]] = ..., tp: Optional[Union[float, bool]] = ..., taperCurve_FloatValue: Optional[Union[float, bool]] = ..., cfv: Optional[Union[float, bool]] = ..., taperCurve_Interp: Optional[Union[int, bool]] = ..., ci: Optional[Union[int, bool]] = ..., taperCurve_Position: Optional[Union[float, bool]] = ..., cp: Optional[Union[float, bool]] = ..., thickness: Optional[Union[float, bool]] = ..., tk: Optional[Union[float, bool]] = ..., translate: Optional[Union[Tuple[float, float, float], bool]] = ..., t: Optional[Union[Tuple[float, float, float], bool]] = ..., translateX: Optional[Union[float, bool]] = ..., tx: Optional[Union[float, bool]] = ..., translateY: Optional[Union[float, bool]] = ..., ty: Optional[Union[float, bool]] = ..., translateZ: Optional[Union[float, bool]] = ..., tz: Optional[Union[float, bool]] = ..., twist: Optional[Union[float, bool]] = ..., twt: Optional[Union[float, bool]] = ..., weight: Optional[Union[float, bool]] = ..., w: Optional[Union[float, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Extrude faces. Faces can be extruded separately or together, and
    manipulations can be performed either in world or object space.

    Args:
        attraction | att: (create, edit, query) - Attraction, related to magnet. The range is [-2.0, 2.0]. Default: 0.0
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createCurve | cc: (create) - If true then the operation can create a curve.
        divisions | d: (create, edit, query) - How many divisions should the extrusion be broken-up into. Default: 1
        gain | ga: (create, edit, multiuse, query) - Gain factor per component. Can be painted using Artisan. Default: 1.0
        gravity | g: (create, edit, query) - The gravity vector. Default: 0.0, -1.0, 0.0
        gravityX | gx: (create, edit, query) - Gravity X coord.
        gravityY | gy: (create, edit, query) - Gravity Y coord.
        gravityZ | gz: (create, edit, query) - Gravity Z coord.
        inputCurve | inc: (create) - This flag specifies the name of the curve to be used as input for the operation.
        keepFacesTogether | kft: (create, edit, query) - How to extrude faces. If "on", faces are pulled together (connected ones stay connected), otherwise they are pulled independently. Default: true
        keepFacetTogether | xft: (create, edit, query) - How to extrude edges. If "on", extruded faces produced from the edges being extruded will be kept together. Otherwise they are pulled independently. Default: true
        localCenter | lc: (create, edit, query) - Local center on the edge : 0=Middle point, 1=Start point, 2=End point. Default: 0
        localDirection | ld: (create, edit, query) - Direction to determine X axis for local space. Default: 1.0, 0.0, 0.0
        localDirectionX | ldx: (create, edit, query) - X coord of the X axis.
        localDirectionY | ldy: (create, edit, query) - Y coord of the X axis.
        localDirectionZ | ldz: (create, edit, query) - Z coord of the X axis.
        localRotate | lr: (create, edit, query) - The local rotations. Default: 0.0, 0.0, 0.0
        localRotateX | lrx: (create, edit, query) - Local rotate X coord. The range is [0, 360].
        localRotateY | lry: (create, edit, query) - Local rotate Y coord. The range is [0, 360].
        localRotateZ | lrz: (create, edit, query) - Local rotate Z coord : Rotation along the normal. The range is [0, 360].
        localScale | ls: (create, edit, query) - Local Scale. Default: 1.0, 1.0, 1.0
        localScaleX | lsx: (create, edit, query) - Scale X coord.
        localScaleY | lsy: (create, edit, query) - Scale Y coord.
        localScaleZ | lsz: (create, edit, query) - Scale Z coord.
        localTranslate | lt: (create, edit, query) - Local translate. Default: 0.0, 0.0, 0.0
        localTranslateX | ltx: (create, edit, query) - Local translation X coord.
        localTranslateY | lty: (create, edit, query) - Local translation Y coord.
        localTranslateZ | ltz: (create, edit, query) - Local translation Z coord : Move along the normal.
        magnX | mx: (create, edit, query) - Magnet X coord.
        magnY | my: (create, edit, query) - Magnet Y coord.
        magnZ | mz: (create, edit, query) - Magnet Z coord.
        magnet | m: (create, edit, query) - The magnet vector. Default: 0.0, 0.0, 0.0
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        offset | off: (create, edit, query) - Local offset. Faces are moved this distance towards the inside of the face. Default: 0.0
        pivot | pvt: (create, edit, query) - The pivot for scaling and rotation. Default: 0.0, 0.0, 0.0
        pivotX | pvx: (create, edit, query) - Pivot X coord.
        pivotY | pvy: (create, edit, query) - Pivot Y coord.
        pivotZ | pvz: (create, edit, query) - Pivot Z coord.
        random | ran: (create, edit, query) - Random value for all parameters. Default: 0.0
        reverseAllFaces | raf: (create, edit, query) - If "on", original faces are reversed in case of extruding all faces. Default: true
        rotate | ro: (create, edit, query) - Rotation angles around X, Y, Z. Default: 0.0, 0.0, 0.0
        rotateX | rx: (create, edit, query) - Rotation angle around X.
        rotateY | ry: (create, edit, query) - Rotation angle around Y.
        rotateZ | rz: (create, edit, query) - Rotation angle around Z.
        scale | s: (create, edit, query) - Scaling vector. Default: 1.0, 1.0, 1.0
        scaleX | sx: (create, edit, query) - Scale X coord.
        scaleY | sy: (create, edit, query) - Scale Y coord.
        scaleZ | sz: (create, edit, query) - Scale Z coord.
        smoothingAngle | sma: (create, edit, query) - Angle below which new edges will be smoothed Default: kPi/6.0
        taper | tp: (create, edit, query) - Taper or Scale along the extrusion path Default: 1.0
        taperCurve_FloatValue | cfv: (create, edit, query) - ?????
        taperCurve_Interp | ci: (create, edit, query) - ????? Default: 0
        taperCurve_Position | cp: (create, edit, query) - ?????
        thickness | tk: (create, edit, query) - Faces are moved outwards from their original position to give the object a consistent thickess. Default: 0.0f
        translate | t: (create, edit, query) - Translation vector. Default: 0.0, 0.0, 0.0
        translateX | tx: (create, edit, query) - Translation X coord.
        translateY | ty: (create, edit, query) - Translation Y coord.
        translateZ | tz: (create, edit, query) - Translation Z coord.
        twist | twt: (create, edit, query) - Twist or Rotation along the extrusion path Default: 0.0
        weight | w: (create, edit, query) - The weight, related to gravity. Default: 0.0
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyExtrudeVertex(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., divisions: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., length: Optional[Union[float, bool]] = ..., l: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., width: Optional[Union[float, bool]] = ..., w: Optional[Union[float, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Command that extrudes selected vertices outwards.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        divisions | d: (create, edit, query) - This flag specifies the number of subdivisions. C: Default is 1 Q: When queried, this flag returns an int.
        length | l: (create, edit, query) - This flag specifies the length of the vertex extrusion. C: Default is 0 Q: When queried, this flag returns a float.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        width | w: (create, edit, query) - This flag specifies the width of the vertex extrusion. C: Default is 0 Q: When queried, this flag returns a float.
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyFlipEdge(*args, edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Command to flip the edges shared by 2 adjacent triangles.
    When used with the edit flag, new edges can be added to the
    same node, instead of creating a separate node in the chain.

    Args:
    """
    ...


def polyFlipUV(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createNewMap: bool = ..., cm: bool = ..., cutUV: bool = ..., cut: bool = ..., flipType: Optional[Union[int, bool]] = ..., ft: Optional[Union[int, bool]] = ..., insertBeforeDeformers: bool = ..., ibd: bool = ..., local: bool = ..., l: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., pivotU: Optional[Union[float, bool]] = ..., pu: Optional[Union[float, bool]] = ..., pivotV: Optional[Union[float, bool]] = ..., pv: Optional[Union[float, bool]] = ..., usePivot: bool = ..., up: bool = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Flip (mirror) the UVs (in texture space) of input polyFaces, about either
    the U or V axis..

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createNewMap | cm: (create) - Set to true if a new map should be created
        cutUV | cut: (create, edit, query) - Cut UV edges when flipping some components on a UV shell C: Default is on. Q: When queried, returns an int.
        flipType | ft: (create, edit, query) - Flip along U or V direction.   0 Horizontal   1 Vertical   C: Default is 0. Q: When queried, returns an int.
        insertBeforeDeformers | ibd: (create) - Set to true if the new node created should inserted before any deformer nodes.
        local | l: (create, edit, query) - Flips in the local space of the input faces. C: Default is on. Q: When queried, returns an int.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        pivotU | pu: (create, edit, query) - Specifies the pivot value, in the U direction.
        pivotV | pv: (create, edit, query) - Specifies the pivot value, in the V direction.
        usePivot | up: (create, edit, query) - Flip using pivot or not. C: Default is off. Q: When queried, returns an int.
        uvSetName | uvs: (create) - Name of the UV set to be created
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyForceUV(*args, cameraProjection: bool = ..., cp: bool = ..., createNewMap: bool = ..., cm: bool = ..., flipHorizontal: bool = ..., fh: bool = ..., flipVertical: bool = ..., fv: bool = ..., g: bool = ..., local: bool = ..., l: bool = ..., normalize: Optional[Union[str, bool]] = ..., nor: Optional[Union[str, bool]] = ..., numItems: Optional[Union[int, bool]] = ..., ni: Optional[Union[int, bool]] = ..., preserveAspectRatio: bool = ..., par: bool = ..., unitize: bool = ..., uni: bool = ..., unshare: bool = ..., u: bool = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ...) -> Any:
    r"""
    A set of functionalities can be called through this command.  The input for
    this command is a set of faces.  Based on the arguments passed, the UVs for
    these selected faces can be created.
    
    Project UVs based on the camera: (UV creation)  
            Based on the current view direction/orientation, the UVs are generated and
    assigned to the faces.  Any previously assigned UV information will be lost.
    
    Best Plane Projection:      (UV creation)  
            The UVs are computed based on the plane defined by the user, and is applied
    to the selected faces.  This tool has 2 phases.  In the first phase,
    the faces to be mapped (faces to which UVs are to be created) are selected.
    In the second phase, the points (vertices, CVs) that define the
    projecting plane are selected.  Any previously assigned UV information will
    be lost.
    
    Unitize:      (UV creation)  
            A new set of unitized UVs are generated and assigned to the faces.
            Any previously assigned UV information will be lost.
    
    Unshare: (UV creation)  
            Force the specified UV to be unshared by possibly creating new UVs.  Any previously assigned UV information will be lost.

    Args:
        cameraProjection | cp: (create) - Project the UVs based on the camera position/orientation
        createNewMap | cm: (create) - Create new map if it does not exist.
        flipHorizontal | fh: (create) - OBSOLETE flag.  Use polyFlipUV instead.
        flipVertical | fv: (create) - OBSOLETE flag.  Use polyFlipUV instead.
        g | g: (create) - OBSOLETE flag.
        local | l: (create) - OBSOLETE flag.
        normalize | nor: (create) - OBSOLETE flag.  Use polyNormalizeUV instead.
        numItems | ni: (create) - This flag is only used for the best plane texturing         of polygonal faces.  This flag should be followed by a         selection list. If not specified, the selected objects will         be used (in the order they were selected).          This flag specifies the number of items (leading) in the         selection list that should be used for the mapping.         The trailing items will be used for computing the         plane (See example below).  The best plane texturing         is better suited for using interactively from within its context.         You can type "BestPlaneTexturingTool"         in the command window OR (EditPolygons->Texture->BestPlaneTexturing         from the Menu) to enter its context.
        preserveAspectRatio | par: (create) - OBSOLETE flag.
        unitize | uni: (create) - To unitize the UVs of the selected faces
        unshare | u: (create) - To unshare tye specified UV
        uvSetName | uvs: (create) - Specifies name of the uv set to work on
    """
    ...


def polyGeoSampler(*args, alphaBlend: Optional[Union[str, bool]] = ..., abl: Optional[Union[str, bool]] = ..., averageColor: bool = ..., ac: bool = ..., clampAlphaMax: Optional[Union[float, bool]] = ..., amx: Optional[Union[float, bool]] = ..., clampAlphaMin: Optional[Union[float, bool]] = ..., amn: Optional[Union[float, bool]] = ..., clampRGBMax: Optional[Union[Tuple[float, float, float], bool]] = ..., cmx: Optional[Union[Tuple[float, float, float], bool]] = ..., clampRGBMin: Optional[Union[Tuple[float, float, float], bool]] = ..., cmn: Optional[Union[Tuple[float, float, float], bool]] = ..., colorBlend: Optional[Union[str, bool]] = ..., cbl: Optional[Union[str, bool]] = ..., colorDisplayOption: bool = ..., cdo: bool = ..., computeShadows: bool = ..., cs: bool = ..., displaceGeometry: bool = ..., dg: bool = ..., flatShading: bool = ..., fs: bool = ..., ignoreDoubleSided: bool = ..., ids: bool = ..., lightingOnly: bool = ..., lo: bool = ..., reuseShadows: bool = ..., rs: bool = ..., sampleByFace: bool = ..., bf: bool = ..., scaleFactor: Optional[Union[float, bool]] = ..., sf: Optional[Union[float, bool]] = ..., shareUV: bool = ..., su: bool = ..., useLightShadows: bool = ..., ul: bool = ..., edit: bool = ...) -> Any:
    r"""
    This command performs a render sampling of surface color and transparency
    for each selected vertex or face and stores the sampled data
    as either the color value, or uses the sampled data to displace
    the affected vertices or faces by a sampled data value.
    Transparency is not used for displacement, and displacement
    is performed along vertex normals.
    The sampled data value used can be pre-scaled by a user defined
    amount.
    Additionally, the normals chosen for sampling can be overridden
    using a "flat" shading option. This option basically means
    to always use the normals of the faces when computing
    sampling values. This may be a desired if the user
    wishes to override an edge smoothness factor. Basically
    with the "flat" shading option on, edges are always
    considered to be hard.
    Note that displacement sampling will result
    in the -sampleByFace option to be turned
    off, since a displacement of a vertex
    always affects the faces the vertex
    is connected to.
    Finally, it is possible to force the storage of shared
    colors per vertex, and / or force the usage of unshared
    UV values.
    The computation of the resulting color is as follows:
    
            resulting-RGB = (sampled-RGB * scale-factor);
            if (color blend is none)
                    resulting-RGB = geometry-RGB
            else if (color blend is add)
                    resulting-RGB = geometry-RGB + sampled-RGB;
            else if (color blend is subtract)
                    resulting-RGB = geometry-RGB - sampled-RGB;
            else if (color blend is multiply)
                    resulting-RGB = geometry-RGB * sampled-RGB;
            else if (color blend is divide)
                    resulting-RGB = geometry-RGB / sampled-RGB;
            else if (color blend is average)
                    resulting-RGB = (geometry-RGB * 1/2) + (sampled-RGB * 1/2);
            if (clamp option set)
                    clamp resulting-RGB between minimum-RGB and maximum-RGB,
    
    The analogous computation is done for computing the resulting alpha
    value.
    The command requires that there be a camera selected in your scene in
    order to work properly in -batch or -prompt mode.

    Args:
        alphaBlend | abl: (create, edit) - When specified, indicates the type of alpha blend to be applied. Options are: "none", "overwrite", "add", "subtract", "multiply", "divide", "average". This option only applies when colors are being set. The default if this argument is not specified is "overwrite". The "none" options to not overwrite the existing value.
        averageColor | ac: (create, edit) - When used, will mean to force the storage of shared colors for vertex level sampling. By default vertex level sampling stores unshared colors.
        clampAlphaMax | amx: (create, edit) - When used, will mean to clamp the storage of alpha to a maximum
        clampAlphaMin | amn: (create, edit) - When used, will mean to clamp the storage of alpha to a minimum
        clampRGBMax | cmx: (create, edit) - When used, will mean to clamp the storage of RGB color to a maximum
        clampRGBMin | cmn: (create, edit) - When used, will mean to clamp the storage of RGB color to a minimum
        colorBlend | cbl: (create, edit) - When specified, indicates the type of color blend to be applied. Options are: "none", "overwrite", "add", "subtract", "multiply", "divide", "average". This option only applies when colors are being set. The default if this argument is not specified is "overwrite". The "none" options to not overwrite the existing value.
        colorDisplayOption | cdo: (create, edit) - Change the display options on the mesh to display the vertex colors.
        computeShadows | cs: (create, edit) - When used, shadow maps will be computed, saved, and reused during the sampling process.
        displaceGeometry | dg: (create, edit) - When used, geometry will be displaced along the normals at the sampling positions, as opposed to storing color values. The default is to store colors.
        flatShading | fs: (create, edit) - When used, flat shaded sampling will be computed. The default is smooth shading.
        ignoreDoubleSided | ids: (create, edit) - When specified, the double sided flag will be ignored for prelighting.
        lightingOnly | lo: (create, edit) - When used, incoming illumination will be computed as opposed to surface color an tranparency
        reuseShadows | rs: (create, edit) - When used, if shadow maps were previosly computed and saved, then they will be reused during the sampling process. The computeShadows option must be enabled for this option to apply.
        sampleByFace | bf: (create, edit) - When used, sample will occur at a per face level versus a per vertex level, which is the default behaviour
        scaleFactor | sf: (create, edit) - When used, will scale the sampled value by the specified amount. The default scale factor is 1.0. Negative values are acceptable for displacement, but not for color values.
        shareUV | su: (create, edit) - When used, UVs are shared at a vertex when sampled. By default UVs are forced to be unshared.
        useLightShadows | ul: (create, edit) - When used, will use each lights shadow map options. Otherwise these options will be overrridden when the computeShadows, and/or reusedShadows option is enabled.
    """
    ...


def polyHelix(*args, caching: bool = ..., cch: bool = ..., coils: Optional[Union[float, bool]] = ..., c: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., createUVs: Optional[Union[int, bool]] = ..., cuv: Optional[Union[int, bool]] = ..., direction: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., height: Optional[Union[float, bool]] = ..., h: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., roundCap: bool = ..., rcp: bool = ..., subdivisionsAxis: Optional[Union[int, bool]] = ..., sa: Optional[Union[int, bool]] = ..., subdivisionsCaps: Optional[Union[int, bool]] = ..., sc: Optional[Union[int, bool]] = ..., subdivisionsCoil: Optional[Union[int, bool]] = ..., sco: Optional[Union[int, bool]] = ..., texture: Optional[Union[int, bool]] = ..., tx: Optional[Union[int, bool]] = ..., useOldInitBehaviour: bool = ..., oib: bool = ..., width: Optional[Union[float, bool]] = ..., w: Optional[Union[float, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The polyHelix command creates a new polygonal helix.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        coils | c: (create, edit, query) - Number of coils. Default: 3
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createUVs | cuv: (create, edit, query) - Create UVs or not. 0: No UVs 1: No Normalization 2: Normalize 3: Normalize and Preserve Aspect Ratio Default: 2
        direction | d: (create, edit, query) - What should be the direction of the coil. 0=Clockwise; 1=Counterclockwise Default: 1
        height | h: (create, edit, query) - Height of the helix. Default: 2.0
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        object | o: (create) - Create the result, or just the dependency node (where applicable).
        radius | r: (create, edit, query) - Radius of tube. Default: 0.4
        roundCap | rcp: (create, edit, query) - To indicate whether we need a round cap Default: false
        subdivisionsAxis | sa: (create, edit, query) - Subdivisions around the axis. Default: 8
        subdivisionsCaps | sc: (create, edit, query) - Subdivisions along the thickness caps. Default: 0
        subdivisionsCoil | sco: (create, edit, query) - Subdivisions along the coil. Default: 50
        texture | tx: (create, edit, query) - What texture mechanism to be applied 0=No textures; 1=Object; 2=Faces Default: 2
        useOldInitBehaviour | oib: (create, edit, query) - Create the helix with base on the origin as in Maya V8.0 and below Otherwise create helix centred at origin Default: false
        width | w: (create, edit, query) - Width of the helix. Default: 2.0
    """
    ...


def polyHole(*args, assignHole: bool = ..., ah: bool = ..., createHistory: bool = ..., ch: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Command to set and clear holes on given faces.

    Args:
        assignHole | ah: (create, edit, query) - Assign the selected faces to be hole or unassign the hole faces to be non-hole. By default, the command will assign faces to be hole.
        createHistory | ch: (create, edit, query) - For objects that have no construction history, this flag can be used to force the creation of construction history for hole.  By default, history is not created if the object has no history.  Regardless of this flag, history is always created if the object already has history.
    """
    ...


def polyInfo(*args, edgeToFace: bool = ..., ef: bool = ..., edgeToVertex: bool = ..., ev: bool = ..., faceNormals: bool = ..., fn: bool = ..., faceToEdge: bool = ..., fe: bool = ..., faceToVertex: bool = ..., fv: bool = ..., invalidEdges: bool = ..., ie: bool = ..., invalidVertices: bool = ..., iv: bool = ..., laminaFaces: bool = ..., lf: bool = ..., nonManifoldEdges: bool = ..., nme: bool = ..., nonManifoldUVEdges: bool = ..., nue: bool = ..., nonManifoldUVs: bool = ..., nuv: bool = ..., nonManifoldVertices: bool = ..., nmv: bool = ..., vertexToEdge: bool = ..., ve: bool = ..., vertexToFace: bool = ..., vf: bool = ...) -> Any:
    r"""
    Command queries topological information on polygonal objects and components.
    So, the command will require the following to be specified:
            - selection list to query

    Args:
        edgeToFace | ef: (create) - Returns the faces that share the specified edge. Requires edges to be selected.
        edgeToVertex | ev: (create) - Returns the vertices defining an edge. Requires edges to be selected.
        faceNormals | fn: (create) - Returns face normals of the specified object. If faces are selected the command returns the face normals of selected faces. Else it returns the face normals of all the faces of the object.
        faceToEdge | fe: (create) - Returns the edges defining a face. Requires faces to be selected.
        faceToVertex | fv: (create) - Returns the vertices defining a face. Requires faces to be selected.
        invalidEdges | ie: (create) - Find all edges that are not associated with any face in the mesh.
        invalidVertices | iv: (create) - Find all vertices that are not associated with any face in the mesh.
        laminaFaces | lf: (create) - Find all lamina faces in the specified objects.
        nonManifoldEdges | nme: (create) - Find all non-manifold edges in the specified objects.
        nonManifoldUVEdges | nue: (create) - Find all non-manifold UV edges in the specified objects.
        nonManifoldUVs | nuv: (create) - Find all non-manifold UVs in the specified objects.
        nonManifoldVertices | nmv: (create) - Find all non-manifold vertices in the specified objects.
        vertexToEdge | ve: (create) - Returns the Edges connected to a vertex. Requires vertices to be selected.
        vertexToFace | vf: (create) - Returns the faces that share the specified vertex. Requires vertices to be selected.
    """
    ...


def polyInstallAction(*args, commandName: bool = ..., cn: bool = ..., convertSelection: bool = ..., cs: bool = ..., installConstraint: bool = ..., ic: bool = ..., installDisplay: bool = ..., id: bool = ..., keepInstances: bool = ..., ki: bool = ..., uninstallConstraint: bool = ..., uc: bool = ..., uninstallDisplay: bool = ..., ud: bool = ..., query: bool = ...) -> Any:
    r"""
    Installs/uninstalls several things to help the user to perform the
    specified action :
    
    Pickmask
    Internal selection constraints
    Display attributes

    Args:
        commandName | cn: (query) - return as a string the name of the command previously installed
        convertSelection | cs: (create) - convert all polys selected in object mode into their full matching component selection. For example : if a polyMesh is selected, polyInstallAction -cs polyCloseBorder will select all border edges.
        installConstraint | ic: (create, query) - C: install selection pickmask and internal constraints for actionname Q: returns 1 if any internal constraint is set for current action
        installDisplay | id: (create, query) - C: install display attributes for actionname Q: returns 1 if any display is set for current action
        keepInstances | ki: (create) - Convert components for all selected instances rather than only the first selected instance.
        uninstallConstraint | uc: (create) - uninstall internal constraints previously installed
        uninstallDisplay | ud: (create) - uninstall display attributes previously installed
    """
    ...


def polyLayoutUV(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., flipReversed: bool = ..., fr: bool = ..., layout: Optional[Union[int, bool]] = ..., l: Optional[Union[int, bool]] = ..., layoutMethod: Optional[Union[int, bool]] = ..., lm: Optional[Union[int, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., percentageSpace: Optional[Union[float, bool]] = ..., ps: Optional[Union[float, bool]] = ..., rotateForBestFit: Optional[Union[int, bool]] = ..., rbf: Optional[Union[int, bool]] = ..., scale: Optional[Union[int, bool]] = ..., sc: Optional[Union[int, bool]] = ..., separate: Optional[Union[int, bool]] = ..., se: Optional[Union[int, bool]] = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Move UVs in the texture plane to avoid overlaps.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        flipReversed | fr: (create, edit, query) - If this flag is turned on, the reversed UV pieces are fliped.
        layout | l: (create, edit, query) - How to move the UV pieces, after cuts are applied: 0 No move is applied. 1 Layout the pieces along the U axis. 2 Layout the pieces in a square shape.
        layoutMethod | lm: (create, edit, query) - Which layout method to use: 0 Block Stacking. 1 Shape Stacking.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        percentageSpace | ps: (create, edit, query) - When layout is set to square, this value is a percentage of the texture area which is added around each UV piece. It can be used to ensure each UV piece uses different pixels in the texture. Maximum value is 5 percent.
        rotateForBestFit | rbf: (create, edit, query) - 0 No rotation is applied. 1 Only allow 90 degree rotations. 2 Allow free rotations.
        scale | sc: (create, edit, query) - How to scale the pieces, after move and cuts: 0 No scale is applied. 1 Uniform scale to fit in unit square. 2 Non proportional scale to fit in unit square.
        separate | se: (create, edit, query) - Which UV edges should be cut: 0 No cuts. 1 Cut only along folds. 2 Make all necessary cuts to avoid all intersections.
        uvSetName | uvs: (create) - Name of the UV set to be created
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyListComponentConversion(*args, border: bool = ..., bo: bool = ..., fromEdge: bool = ..., fe: bool = ..., fromFace: bool = ..., ff: bool = ..., fromUV: bool = ..., fuv: bool = ..., fromVertex: bool = ..., fv: bool = ..., fromVertexFace: bool = ..., fvf: bool = ..., internal: bool = ..., toEdge: bool = ..., te: bool = ..., toFace: bool = ..., tf: bool = ..., toUV: bool = ..., tuv: bool = ..., toVertex: bool = ..., tv: bool = ..., toVertexFace: bool = ..., tvf: bool = ..., uvShell: bool = ..., uvs: bool = ..., vertexFaceAllEdges: bool = ..., vfa: bool = ...) -> Any:
    r"""
    This command converts poly components from one or more types
    to another one or more types, and returns the list of the
    conversion. It does not change anything of the current database.

    Args:
        border | bo: (create) - Indicates that the converted components must be on the border of the selection. If it is not provided, the converted components will be the related ones.
        fromEdge | fe: (create) - 
        fromFace | ff: (create) - 
        fromUV | fuv: (create) - 
        fromVertex | fv: (create) - 
        fromVertexFace | fvf: (create) - Indicates the component type to convert from. If none of them is provided, it is assumed to be all of them, including poly objects.
        internal | internal: (create) - Indicates that the converted components must be totally envolved by the source components. E.g. a converted face must have all of its surrounding vertices being given. If it is not provided, the converted components will be the related ones.
        toEdge | te: (create) - 
        toFace | tf: (create) - 
        toUV | tuv: (create) - 
        toVertex | tv: (create) - 
        toVertexFace | tvf: (create) - Indicates the component type to convert to. If none of them is provided, it is assumed to the object.
        uvShell | uvs: (create) - Will return UV components within the same UV shell. Only works with -tuv and -fuv flags.
        vertexFaceAllEdges | vfa: (create) - When converting from face vertices to edges, indicates that all edges with an end at the face vertex should be included. Without this flag, the default behaviour is to only include one edge per face vertex.
    """
    ...


def polyMapCut(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., moveratio: Optional[Union[float, bool]] = ..., mvr: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Cut along edges of the texture mapping. The cut edges become map borders.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        moveratio | mvr: (edit, query) - Cut open ratio related to the neighbor edge length of cut edge.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def polyMapDel(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Deletes texture coordinates (UVs) from selected faces.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def polyMapSew(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Sew border edges in texture space. Selected edges must be map borders.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def polyMapSewMove(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., limitPieceSize: bool = ..., lps: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., numberFaces: Optional[Union[int, bool]] = ..., nf: Optional[Union[int, bool]] = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command can be used to Move and Sew together separate UV pieces
    along geometric edges. UV pieces that correspond to the same geometric
    edge, are merged together by moving the smaller piece to the larger
    one.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        limitPieceSize | lps: (create, edit, query) - When on, this flag specifies that the face number limit described above should be used.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        numberFaces | nf: (create, edit, query) - Maximum number of faces in a UV piece. When trying to combine two UV pieces into a single one, the merge operation is rejected if the smaller piece has more faces than the number specified by this flag. This flag is only used when limitPieceSize is set to on.
        uvSetName | uvs: (create) - Name of the UV set to be created
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyMergeEdge(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., firstEdge: Optional[Union[int, bool]] = ..., fe: Optional[Union[int, bool]] = ..., mergeMode: Optional[Union[int, bool]] = ..., mm: Optional[Union[int, bool]] = ..., mergeTexture: bool = ..., mt: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., secondEdge: Optional[Union[int, bool]] = ..., se: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Sews two border edges together.
    The new edge is located either on the first, last,
    or between both selected edges, depending on the mode.
    
    Both edges must belong to the same object, and orientations must match
    (i.e. normals on corresponding faces must point in the same direction).
    Edge flags are mandatory.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        firstEdge | fe: (create, edit, query) - First edge to merge. Invalid default value to force the value to be set. Default: -1
        mergeMode | mm: (create, edit, query) - Merge mode : 0=first, 1=halfway between both edges, 2=second. Default: 1
        mergeTexture | mt: (create, edit, query) - Boolean which is used to decide if uv coordinates should be merged or not - along with the geometry. Default: false
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        secondEdge | se: (create, edit, query) - Second edge to merge. Invalid default value to force the value to be set. Default: -1
    """
    ...


def polyMergeFacet(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., firstFacet: Optional[Union[int, bool]] = ..., ff: Optional[Union[int, bool]] = ..., mergeMode: Optional[Union[int, bool]] = ..., mm: Optional[Union[int, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., secondFacet: Optional[Union[int, bool]] = ..., sf: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The second face becomes a hole in the first face.
    The new holed face is located either on the first, last,
    or between both selected faces, depending on the mode.
    
    Both faces must belong to the same object.
    Facet flags are mandatory.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        firstFacet | ff: (create, edit, query) - The number of the first (outer) face to merge.
        mergeMode | mm: (create, edit, query) - This flag specifies how faces are merged: 0: moves second face to first one 1: moves both faces to average 2: moves first face to second one 3, 4, 5: same as above, except faces are projected but not centred 6: Nothing moves. C: Default is None (6).
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        secondFacet | sf: (create, edit, query) - The number of the second (hole) face to merge.
    """
    ...


def polyMergeUV(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., distance: Optional[Union[float, bool]] = ..., d: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Merge UVs of an object based on their distance. UVs are merge only
    if they belong to the same 3D vertex.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        distance | d: (create, edit, query) - This flag specifies the maximum distance to merge UVs. C: Default is 0.0. Q: When queried, this flag returns a double.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        uvSetName | uvs: (create) - Name of the UV set to be created
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyMergeVertex(*args, alwaysMergeTwoVertices: bool = ..., am: bool = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., distance: Optional[Union[float, bool]] = ..., d: Optional[Union[float, bool]] = ..., mergeToComponents: Optional[Union[str, bool]] = ..., mtc: Optional[Union[str, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., texture: bool = ..., tx: bool = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Merge vertices within a given threshold.
    Since this allows merging any vertices that lie on the same object it
    is possible for the resulting geometry to be non-manifold.
    
    First, perform comparison of pairs of selected vertices.
    Pairs that lie within given distance of one another are merged,
    along with the edge between them.
    
    Second, any selected vertices which share an edge are merged if
    the distance between them is within the specified distance.
    
    Unlike Merge Edges, Merge Vertices will perform the merge even if the
    edges adjoining the vertices do not have matching orientation (i.e.
    normals of adjacent faces do not point in the same direction). As this
    restriction is not enforced while merging vertices, resulting geometry
    can be non-manifold.
    
    If alwaysMergeTwoVertices is set and there are only two vertices, tolerance
    is ignored and the vertices will be merged.
    
    Resulting mesh may have extra vertices or edges to ensure
    geometry is valid.

    Args:
        alwaysMergeTwoVertices | am: (create, edit, query) - This flag specifies whether to always merge if only two vertices are selected regardless of distance. C: Default is false. Q: When queried, this flag returns a boolean.
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        distance | d: (create, edit, query) - This flag specifies the distance within which vertices will be merged. C: Default is 0.0 (i.e. vertices are coincident). Q: When queried, this flag returns a double.
        mergeToComponents | mtc: (create, edit, query) - Optionally defines the position to merge all of the vertices to.  If set, the distance flag will be ignored, and instead the center point of the set components will be calculated and all vertices will be merged to that location. C: Default is empty string. Q: When queried, this flag returns a string.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        texture | tx: (create, edit, query) - This flag specifies whether the texture is sewn in addition to the 3d edge C: Default is true. Q: When queried, this flag returns a boolean.
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyMirrorFace(*args, axis: Optional[Union[int, bool]] = ..., a: Optional[Union[int, bool]] = ..., axisDirection: Optional[Union[int, bool]] = ..., ad: Optional[Union[int, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., direction: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., mergeMode: Optional[Union[int, bool]] = ..., mm: Optional[Union[int, bool]] = ..., mergeThreshold: Optional[Union[float, bool]] = ..., mt: Optional[Union[float, bool]] = ..., mergeThresholdType: Optional[Union[int, bool]] = ..., mtt: Optional[Union[int, bool]] = ..., mirrorAxis: Optional[Union[int, bool]] = ..., ma: Optional[Union[int, bool]] = ..., mirrorPosition: Optional[Union[float, bool]] = ..., mps: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., pivot: Optional[Union[Tuple[float, float, float], bool]] = ..., p: Optional[Union[Tuple[float, float, float], bool]] = ..., pivotX: Optional[Union[float, bool]] = ..., px: Optional[Union[float, bool]] = ..., pivotY: Optional[Union[float, bool]] = ..., py: Optional[Union[float, bool]] = ..., pivotZ: Optional[Union[float, bool]] = ..., pz: Optional[Union[float, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Mirror all the faces of the selected object.

    Args:
        axis | a: (create, edit, query) - Axis to mirror the object along Default: 0
        axisDirection | ad: (create, edit, query) - Direction to mirror the object along Default: 1
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        direction | d: (create, edit, query) - Direction to mirror the object along Default: 0
        mergeMode | mm: (create, edit, query) - Merge mode to apply Default: 1
        mergeThreshold | mt: (create, edit, query) - Tolerance to determine whether vertices should be merged. Default: 0.001
        mergeThresholdType | mtt: (create, edit, query) - Merge mode to apply Default: 0
        mirrorAxis | ma: (create, edit, query) - Mirror axis type selection Default: 2
        mirrorPosition | mps: (create, edit, query) - Custom mirror axis position Default: 0.0
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        pivot | p: (create, edit, query) - Pivot point of the mirror plane. Default: 0.0, 0.0, 0.0
        pivotX | px: (create, edit, query) - Translation X coord.
        pivotY | py: (create, edit, query) - Translation Y coord.
        pivotZ | pz: (create, edit, query) - Translation Z coord.
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyMoveEdge(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., gain: Optional[Union[float, bool]] = ..., ga: Optional[Union[float, bool]] = ..., localCenter: Optional[Union[int, bool]] = ..., lc: Optional[Union[int, bool]] = ..., localDirection: Optional[Union[Tuple[float, float, float], bool]] = ..., ld: Optional[Union[Tuple[float, float, float], bool]] = ..., localDirectionX: Optional[Union[float, bool]] = ..., ldx: Optional[Union[float, bool]] = ..., localDirectionY: Optional[Union[float, bool]] = ..., ldy: Optional[Union[float, bool]] = ..., localDirectionZ: Optional[Union[float, bool]] = ..., ldz: Optional[Union[float, bool]] = ..., localRotate: Optional[Union[Tuple[float, float, float], bool]] = ..., lr: Optional[Union[Tuple[float, float, float], bool]] = ..., localRotateX: Optional[Union[float, bool]] = ..., lrx: Optional[Union[float, bool]] = ..., localRotateY: Optional[Union[float, bool]] = ..., lry: Optional[Union[float, bool]] = ..., localRotateZ: Optional[Union[float, bool]] = ..., lrz: Optional[Union[float, bool]] = ..., localScale: Optional[Union[Tuple[float, float, float], bool]] = ..., ls: Optional[Union[Tuple[float, float, float], bool]] = ..., localScaleX: Optional[Union[float, bool]] = ..., lsx: Optional[Union[float, bool]] = ..., localScaleY: Optional[Union[float, bool]] = ..., lsy: Optional[Union[float, bool]] = ..., localScaleZ: Optional[Union[float, bool]] = ..., lsz: Optional[Union[float, bool]] = ..., localTranslate: Optional[Union[Tuple[float, float, float], bool]] = ..., lt: Optional[Union[Tuple[float, float, float], bool]] = ..., localTranslateX: Optional[Union[float, bool]] = ..., ltx: Optional[Union[float, bool]] = ..., localTranslateY: Optional[Union[float, bool]] = ..., lty: Optional[Union[float, bool]] = ..., localTranslateZ: Optional[Union[float, bool]] = ..., ltz: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., pivot: Optional[Union[Tuple[float, float, float], bool]] = ..., pvt: Optional[Union[Tuple[float, float, float], bool]] = ..., pivotX: Optional[Union[float, bool]] = ..., pvx: Optional[Union[float, bool]] = ..., pivotY: Optional[Union[float, bool]] = ..., pvy: Optional[Union[float, bool]] = ..., pivotZ: Optional[Union[float, bool]] = ..., pvz: Optional[Union[float, bool]] = ..., random: Optional[Union[float, bool]] = ..., ran: Optional[Union[float, bool]] = ..., rotate: Optional[Union[Tuple[float, float, float], bool]] = ..., ro: Optional[Union[Tuple[float, float, float], bool]] = ..., rotateX: Optional[Union[float, bool]] = ..., rx: Optional[Union[float, bool]] = ..., rotateY: Optional[Union[float, bool]] = ..., ry: Optional[Union[float, bool]] = ..., rotateZ: Optional[Union[float, bool]] = ..., rz: Optional[Union[float, bool]] = ..., scale: Optional[Union[Tuple[float, float, float], bool]] = ..., s: Optional[Union[Tuple[float, float, float], bool]] = ..., scaleX: Optional[Union[float, bool]] = ..., sx: Optional[Union[float, bool]] = ..., scaleY: Optional[Union[float, bool]] = ..., sy: Optional[Union[float, bool]] = ..., scaleZ: Optional[Union[float, bool]] = ..., sz: Optional[Union[float, bool]] = ..., translate: Optional[Union[Tuple[float, float, float], bool]] = ..., t: Optional[Union[Tuple[float, float, float], bool]] = ..., translateX: Optional[Union[float, bool]] = ..., tx: Optional[Union[float, bool]] = ..., translateY: Optional[Union[float, bool]] = ..., ty: Optional[Union[float, bool]] = ..., translateZ: Optional[Union[float, bool]] = ..., tz: Optional[Union[float, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Modifies edges of a polygonal object.
    Translate, move, rotate or scale edges.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        gain | ga: (create, edit, multiuse, query) - Gain factor per component. Can be painted using Artisan. Default: 1.0
        localCenter | lc: (create, edit, query) - Local center on the edge : 0=Middle point, 1=Start point, 2=End point. Default: 0
        localDirection | ld: (create, edit, query) - Direction to determine X axis for local space. Default: 1.0, 0.0, 0.0
        localDirectionX | ldx: (create, edit, query) - X coord of the X axis.
        localDirectionY | ldy: (create, edit, query) - Y coord of the X axis.
        localDirectionZ | ldz: (create, edit, query) - Z coord of the X axis.
        localRotate | lr: (create, edit, query) - The local rotations. Default: 0.0, 0.0, 0.0
        localRotateX | lrx: (create, edit, query) - Local rotate X coord. The range is [0, 360].
        localRotateY | lry: (create, edit, query) - Local rotate Y coord. The range is [0, 360].
        localRotateZ | lrz: (create, edit, query) - Local rotate Z coord : Rotation along the normal. The range is [0, 360].
        localScale | ls: (create, edit, query) - Local Scale. Default: 1.0, 1.0, 1.0
        localScaleX | lsx: (create, edit, query) - Scale X coord.
        localScaleY | lsy: (create, edit, query) - Scale Y coord.
        localScaleZ | lsz: (create, edit, query) - Scale Z coord.
        localTranslate | lt: (create, edit, query) - Local translate. Default: 0.0, 0.0, 0.0
        localTranslateX | ltx: (create, edit, query) - Local translation X coord.
        localTranslateY | lty: (create, edit, query) - Local translation Y coord.
        localTranslateZ | ltz: (create, edit, query) - Local translation Z coord : Move along the normal.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        pivot | pvt: (create, edit, query) - The pivot for scaling and rotation. Default: 0.0, 0.0, 0.0
        pivotX | pvx: (create, edit, query) - Pivot X coord.
        pivotY | pvy: (create, edit, query) - Pivot Y coord.
        pivotZ | pvz: (create, edit, query) - Pivot Z coord.
        random | ran: (create, edit, query) - Random value for all parameters. Default: 0.0
        rotate | ro: (create, edit, query) - Rotation angles around X, Y, Z. Default: 0.0, 0.0, 0.0
        rotateX | rx: (create, edit, query) - Rotation angle around X.
        rotateY | ry: (create, edit, query) - Rotation angle around Y.
        rotateZ | rz: (create, edit, query) - Rotation angle around Z.
        scale | s: (create, edit, query) - Scaling vector. Default: 1.0, 1.0, 1.0
        scaleX | sx: (create, edit, query) - Scale X coord.
        scaleY | sy: (create, edit, query) - Scale Y coord.
        scaleZ | sz: (create, edit, query) - Scale Z coord.
        translate | t: (create, edit, query) - Translation vector. Default: 0.0, 0.0, 0.0
        translateX | tx: (create, edit, query) - Translation X coord.
        translateY | ty: (create, edit, query) - Translation Y coord.
        translateZ | tz: (create, edit, query) - Translation Z coord.
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyMoveFacet(*args, attraction: Optional[Union[float, bool]] = ..., att: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., gain: Optional[Union[float, bool]] = ..., ga: Optional[Union[float, bool]] = ..., gravity: Optional[Union[Tuple[float, float, float], bool]] = ..., g: Optional[Union[Tuple[float, float, float], bool]] = ..., gravityX: Optional[Union[float, bool]] = ..., gx: Optional[Union[float, bool]] = ..., gravityY: Optional[Union[float, bool]] = ..., gy: Optional[Union[float, bool]] = ..., gravityZ: Optional[Union[float, bool]] = ..., gz: Optional[Union[float, bool]] = ..., localCenter: Optional[Union[int, bool]] = ..., lc: Optional[Union[int, bool]] = ..., localDirection: Optional[Union[Tuple[float, float, float], bool]] = ..., ld: Optional[Union[Tuple[float, float, float], bool]] = ..., localDirectionX: Optional[Union[float, bool]] = ..., ldx: Optional[Union[float, bool]] = ..., localDirectionY: Optional[Union[float, bool]] = ..., ldy: Optional[Union[float, bool]] = ..., localDirectionZ: Optional[Union[float, bool]] = ..., ldz: Optional[Union[float, bool]] = ..., localRotate: Optional[Union[Tuple[float, float, float], bool]] = ..., lr: Optional[Union[Tuple[float, float, float], bool]] = ..., localRotateX: Optional[Union[float, bool]] = ..., lrx: Optional[Union[float, bool]] = ..., localRotateY: Optional[Union[float, bool]] = ..., lry: Optional[Union[float, bool]] = ..., localRotateZ: Optional[Union[float, bool]] = ..., lrz: Optional[Union[float, bool]] = ..., localScale: Optional[Union[Tuple[float, float, float], bool]] = ..., ls: Optional[Union[Tuple[float, float, float], bool]] = ..., localScaleX: Optional[Union[float, bool]] = ..., lsx: Optional[Union[float, bool]] = ..., localScaleY: Optional[Union[float, bool]] = ..., lsy: Optional[Union[float, bool]] = ..., localScaleZ: Optional[Union[float, bool]] = ..., lsz: Optional[Union[float, bool]] = ..., localTranslate: Optional[Union[Tuple[float, float, float], bool]] = ..., lt: Optional[Union[Tuple[float, float, float], bool]] = ..., localTranslateX: Optional[Union[float, bool]] = ..., ltx: Optional[Union[float, bool]] = ..., localTranslateY: Optional[Union[float, bool]] = ..., lty: Optional[Union[float, bool]] = ..., localTranslateZ: Optional[Union[float, bool]] = ..., ltz: Optional[Union[float, bool]] = ..., magnX: Optional[Union[float, bool]] = ..., mx: Optional[Union[float, bool]] = ..., magnY: Optional[Union[float, bool]] = ..., my: Optional[Union[float, bool]] = ..., magnZ: Optional[Union[float, bool]] = ..., mz: Optional[Union[float, bool]] = ..., magnet: Optional[Union[Tuple[float, float, float], bool]] = ..., m: Optional[Union[Tuple[float, float, float], bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., offset: Optional[Union[float, bool]] = ..., off: Optional[Union[float, bool]] = ..., pivot: Optional[Union[Tuple[float, float, float], bool]] = ..., pvt: Optional[Union[Tuple[float, float, float], bool]] = ..., pivotX: Optional[Union[float, bool]] = ..., pvx: Optional[Union[float, bool]] = ..., pivotY: Optional[Union[float, bool]] = ..., pvy: Optional[Union[float, bool]] = ..., pivotZ: Optional[Union[float, bool]] = ..., pvz: Optional[Union[float, bool]] = ..., random: Optional[Union[float, bool]] = ..., ran: Optional[Union[float, bool]] = ..., rotate: Optional[Union[Tuple[float, float, float], bool]] = ..., ro: Optional[Union[Tuple[float, float, float], bool]] = ..., rotateX: Optional[Union[float, bool]] = ..., rx: Optional[Union[float, bool]] = ..., rotateY: Optional[Union[float, bool]] = ..., ry: Optional[Union[float, bool]] = ..., rotateZ: Optional[Union[float, bool]] = ..., rz: Optional[Union[float, bool]] = ..., scale: Optional[Union[Tuple[float, float, float], bool]] = ..., s: Optional[Union[Tuple[float, float, float], bool]] = ..., scaleX: Optional[Union[float, bool]] = ..., sx: Optional[Union[float, bool]] = ..., scaleY: Optional[Union[float, bool]] = ..., sy: Optional[Union[float, bool]] = ..., scaleZ: Optional[Union[float, bool]] = ..., sz: Optional[Union[float, bool]] = ..., translate: Optional[Union[Tuple[float, float, float], bool]] = ..., t: Optional[Union[Tuple[float, float, float], bool]] = ..., translateX: Optional[Union[float, bool]] = ..., tx: Optional[Union[float, bool]] = ..., translateY: Optional[Union[float, bool]] = ..., ty: Optional[Union[float, bool]] = ..., translateZ: Optional[Union[float, bool]] = ..., tz: Optional[Union[float, bool]] = ..., weight: Optional[Union[float, bool]] = ..., w: Optional[Union[float, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Modifies facet of a polygonal object.
    Translate, move, rotate or scale facets.

    Args:
        attraction | att: (create, edit, query) - Attraction, related to magnet. The range is [-2.0, 2.0]. Default: 0.0
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        gain | ga: (create, edit, multiuse, query) - Gain factor per component. Can be painted using Artisan. Default: 1.0
        gravity | g: (create, edit, query) - The gravity vector. Default: 0.0, -1.0, 0.0
        gravityX | gx: (create, edit, query) - Gravity X coord.
        gravityY | gy: (create, edit, query) - Gravity Y coord.
        gravityZ | gz: (create, edit, query) - Gravity Z coord.
        localCenter | lc: (create, edit, query) - Local center on the edge : 0=Middle point, 1=Start point, 2=End point. Default: 0
        localDirection | ld: (create, edit, query) - Direction to determine X axis for local space. Default: 1.0, 0.0, 0.0
        localDirectionX | ldx: (create, edit, query) - X coord of the X axis.
        localDirectionY | ldy: (create, edit, query) - Y coord of the X axis.
        localDirectionZ | ldz: (create, edit, query) - Z coord of the X axis.
        localRotate | lr: (create, edit, query) - The local rotations. Default: 0.0, 0.0, 0.0
        localRotateX | lrx: (create, edit, query) - Local rotate X coord. The range is [0, 360].
        localRotateY | lry: (create, edit, query) - Local rotate Y coord. The range is [0, 360].
        localRotateZ | lrz: (create, edit, query) - Local rotate Z coord : Rotation along the normal. The range is [0, 360].
        localScale | ls: (create, edit, query) - Local Scale. Default: 1.0, 1.0, 1.0
        localScaleX | lsx: (create, edit, query) - Scale X coord.
        localScaleY | lsy: (create, edit, query) - Scale Y coord.
        localScaleZ | lsz: (create, edit, query) - Scale Z coord.
        localTranslate | lt: (create, edit, query) - Local translate. Default: 0.0, 0.0, 0.0
        localTranslateX | ltx: (create, edit, query) - Local translation X coord.
        localTranslateY | lty: (create, edit, query) - Local translation Y coord.
        localTranslateZ | ltz: (create, edit, query) - Local translation Z coord : Move along the normal.
        magnX | mx: (create, edit, query) - Magnet X coord.
        magnY | my: (create, edit, query) - Magnet Y coord.
        magnZ | mz: (create, edit, query) - Magnet Z coord.
        magnet | m: (create, edit, query) - The magnet vector. Default: 0.0, 0.0, 0.0
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        offset | off: (create, edit, query) - Local offset. Faces are moved this distance towards the inside of the face. Default: 0.0
        pivot | pvt: (create, edit, query) - The pivot for scaling and rotation. Default: 0.0, 0.0, 0.0
        pivotX | pvx: (create, edit, query) - Pivot X coord.
        pivotY | pvy: (create, edit, query) - Pivot Y coord.
        pivotZ | pvz: (create, edit, query) - Pivot Z coord.
        random | ran: (create, edit, query) - Random value for all parameters. Default: 0.0
        rotate | ro: (create, edit, query) - Rotation angles around X, Y, Z. Default: 0.0, 0.0, 0.0
        rotateX | rx: (create, edit, query) - Rotation angle around X.
        rotateY | ry: (create, edit, query) - Rotation angle around Y.
        rotateZ | rz: (create, edit, query) - Rotation angle around Z.
        scale | s: (create, edit, query) - Scaling vector. Default: 1.0, 1.0, 1.0
        scaleX | sx: (create, edit, query) - Scale X coord.
        scaleY | sy: (create, edit, query) - Scale Y coord.
        scaleZ | sz: (create, edit, query) - Scale Z coord.
        translate | t: (create, edit, query) - Translation vector. Default: 0.0, 0.0, 0.0
        translateX | tx: (create, edit, query) - Translation X coord.
        translateY | ty: (create, edit, query) - Translation Y coord.
        translateZ | tz: (create, edit, query) - Translation Z coord.
        weight | w: (create, edit, query) - The weight, related to gravity. Default: 0.0
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyMoveFacetUV(*args, axisLen: Optional[Union[Tuple[float, float], bool]] = ..., l: Optional[Union[Tuple[float, float], bool]] = ..., axisLenX: Optional[Union[float, bool]] = ..., lx: Optional[Union[float, bool]] = ..., axisLenY: Optional[Union[float, bool]] = ..., ly: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., pivot: Optional[Union[Tuple[float, float], bool]] = ..., pvt: Optional[Union[Tuple[float, float], bool]] = ..., pivotU: Optional[Union[float, bool]] = ..., pvu: Optional[Union[float, bool]] = ..., pivotV: Optional[Union[float, bool]] = ..., pvv: Optional[Union[float, bool]] = ..., random: Optional[Union[float, bool]] = ..., ran: Optional[Union[float, bool]] = ..., rotationAngle: Optional[Union[float, bool]] = ..., ra: Optional[Union[float, bool]] = ..., scale: Optional[Union[Tuple[float, float], bool]] = ..., s: Optional[Union[Tuple[float, float], bool]] = ..., scaleU: Optional[Union[float, bool]] = ..., su: Optional[Union[float, bool]] = ..., scaleV: Optional[Union[float, bool]] = ..., sv: Optional[Union[float, bool]] = ..., translate: Optional[Union[Tuple[float, float], bool]] = ..., t: Optional[Union[Tuple[float, float], bool]] = ..., translateU: Optional[Union[float, bool]] = ..., tu: Optional[Union[float, bool]] = ..., translateV: Optional[Union[float, bool]] = ..., tv: Optional[Union[float, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Modifies the map by moving all UV values associated with
    the selected face(s).
    
    The UV coordinates of the model are manipulated without
    changing the vertices of the 3D object.

    Args:
        axisLen | l: (create, edit, query) - Axis Length vector, used to draw the manip handles. C: Default is 1.0, 1.0 Q: When queried, this flag returns a float[2].
        axisLenX | lx: (create, edit, query) - Axis Length in X, used to draw the manip handles. C: Default is 1.0 Q: When queried, this flag returns a float.
        axisLenY | ly: (create, edit, query) - Axis Length in Y, used to draw the manip handles. C: Default is 1.0 Q: When queried, this flag returns a float.
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        pivot | pvt: (create, edit, query) - This flag specifies the pivot for scaling and rotation. C: Default is 0.0 0.0. Q: When queried, this flag returns a float[2].
        pivotU | pvu: (create, edit, query) - This flag specifies U for the pivot for scaling and rotation. C: Default is 0.0. Q: When queried, this flag returns a float.
        pivotV | pvv: (create, edit, query) - This flag specifies V for the pivot for scaling and rotation. C: Default is 0.0. Q: When queried, this flag returns a float.
        random | ran: (create, edit, query) - This flag specifies the random value for all parameters. C: Default is 0.0. The range is [-10.0, 10.0]. Q: When queried, this flag returns a float.
        rotationAngle | ra: (create, edit, query) - Angle of rotation. C: Default is 0.0. Q: When queried, this flag returns a float.
        scale | s: (create, edit, query) - This flag specifies the scaling vector. C: Default is 1.0 1.0. Q: When queried, this flag returns a float.
        scaleU | su: (create, edit, query) - This flag specifies U for the scaling vector. C: Default is 1.0. Q: When queried, this flag returns a float.
        scaleV | sv: (create, edit, query) - This flag specifies V for the scaling vector. C: Default is 1.0. Q: When queried, this flag returns a float.
        translate | t: (create, edit, query) - This flag specifies the translation vector. C: Default is 0.0 0.0. Q: When queried, this flag returns a float[2].
        translateU | tu: (create, edit, query) - This flag specifies the U translation vector. C: Default is 0.0. Q: When queried, this flag returns a float.
        translateV | tv: (create, edit, query) - This flag specifies the V translation vector. C: Default is 0.0. Q: When queried, this flag returns a float.
    """
    ...


def polyMoveUV(*args, axisLen: Optional[Union[Tuple[float, float], bool]] = ..., l: Optional[Union[Tuple[float, float], bool]] = ..., axisLenX: Optional[Union[float, bool]] = ..., lx: Optional[Union[float, bool]] = ..., axisLenY: Optional[Union[float, bool]] = ..., ly: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., pivot: Optional[Union[Tuple[float, float], bool]] = ..., pvt: Optional[Union[Tuple[float, float], bool]] = ..., pivotU: Optional[Union[float, bool]] = ..., pvu: Optional[Union[float, bool]] = ..., pivotV: Optional[Union[float, bool]] = ..., pvv: Optional[Union[float, bool]] = ..., random: Optional[Union[float, bool]] = ..., ran: Optional[Union[float, bool]] = ..., rotationAngle: Optional[Union[float, bool]] = ..., ra: Optional[Union[float, bool]] = ..., scale: Optional[Union[Tuple[float, float], bool]] = ..., s: Optional[Union[Tuple[float, float], bool]] = ..., scaleU: Optional[Union[float, bool]] = ..., su: Optional[Union[float, bool]] = ..., scaleV: Optional[Union[float, bool]] = ..., sv: Optional[Union[float, bool]] = ..., translate: Optional[Union[Tuple[float, float], bool]] = ..., t: Optional[Union[Tuple[float, float], bool]] = ..., translateU: Optional[Union[float, bool]] = ..., tu: Optional[Union[float, bool]] = ..., translateV: Optional[Union[float, bool]] = ..., tv: Optional[Union[float, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Moves selected UV coordinates in 2D space.
    As the selected UVs are adjusted, the way the image is
    mapped onto the object changes accordingly.
    This command manipulates the UV values without changing
    the 3D geometry of the object.

    Args:
        axisLen | l: (create, edit, query) - AxisLen vector, used to draw the manip handles. Default: 1.0, 1.0
        axisLenX | lx: (create, edit, query) - AxisLen X coord.
        axisLenY | ly: (create, edit, query) - AxisLen Y coord.
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        pivot | pvt: (create, edit, query) - The pivot for scaling and rotation. Default: 0.5, 0.5
        pivotU | pvu: (create, edit, query) - Pivot U coord.
        pivotV | pvv: (create, edit, query) - Pivot V coord.
        random | ran: (create, edit, query) - Random value, added to all parameters. Default: 0.0
        rotationAngle | ra: (create, edit, query) - Angle of rotation. Default: 0.0
        scale | s: (create, edit, query) - Scaling vector. Default: 1.0, 1.0
        scaleU | su: (create, edit, query) - Scaling U coord.
        scaleV | sv: (create, edit, query) - Scaling V coord.
        translate | t: (create, edit, query) - Translation vector. Default: 0.0, 0.0
        translateU | tu: (create, edit, query) - Translation U coord.
        translateV | tv: (create, edit, query) - Translation V coord.
    """
    ...


def polyMoveVertex(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., gain: Optional[Union[float, bool]] = ..., ga: Optional[Union[float, bool]] = ..., localDirection: Optional[Union[Tuple[float, float, float], bool]] = ..., ld: Optional[Union[Tuple[float, float, float], bool]] = ..., localDirectionX: Optional[Union[float, bool]] = ..., ldx: Optional[Union[float, bool]] = ..., localDirectionY: Optional[Union[float, bool]] = ..., ldy: Optional[Union[float, bool]] = ..., localDirectionZ: Optional[Union[float, bool]] = ..., ldz: Optional[Union[float, bool]] = ..., localTranslate: Optional[Union[Tuple[float, float, float], bool]] = ..., lt: Optional[Union[Tuple[float, float, float], bool]] = ..., localTranslateX: Optional[Union[float, bool]] = ..., ltx: Optional[Union[float, bool]] = ..., localTranslateY: Optional[Union[float, bool]] = ..., lty: Optional[Union[float, bool]] = ..., localTranslateZ: Optional[Union[float, bool]] = ..., ltz: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., pivot: Optional[Union[Tuple[float, float, float], bool]] = ..., pvt: Optional[Union[Tuple[float, float, float], bool]] = ..., pivotX: Optional[Union[float, bool]] = ..., pvx: Optional[Union[float, bool]] = ..., pivotY: Optional[Union[float, bool]] = ..., pvy: Optional[Union[float, bool]] = ..., pivotZ: Optional[Union[float, bool]] = ..., pvz: Optional[Union[float, bool]] = ..., random: Optional[Union[float, bool]] = ..., ran: Optional[Union[float, bool]] = ..., rotate: Optional[Union[Tuple[float, float, float], bool]] = ..., ro: Optional[Union[Tuple[float, float, float], bool]] = ..., rotateX: Optional[Union[float, bool]] = ..., rx: Optional[Union[float, bool]] = ..., rotateY: Optional[Union[float, bool]] = ..., ry: Optional[Union[float, bool]] = ..., rotateZ: Optional[Union[float, bool]] = ..., rz: Optional[Union[float, bool]] = ..., scale: Optional[Union[Tuple[float, float, float], bool]] = ..., s: Optional[Union[Tuple[float, float, float], bool]] = ..., scaleX: Optional[Union[float, bool]] = ..., sx: Optional[Union[float, bool]] = ..., scaleY: Optional[Union[float, bool]] = ..., sy: Optional[Union[float, bool]] = ..., scaleZ: Optional[Union[float, bool]] = ..., sz: Optional[Union[float, bool]] = ..., translate: Optional[Union[Tuple[float, float, float], bool]] = ..., t: Optional[Union[Tuple[float, float, float], bool]] = ..., translateX: Optional[Union[float, bool]] = ..., tx: Optional[Union[float, bool]] = ..., translateY: Optional[Union[float, bool]] = ..., ty: Optional[Union[float, bool]] = ..., translateZ: Optional[Union[float, bool]] = ..., tz: Optional[Union[float, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Modifies vertices of a polygonal object.
    Translate, rotate or scale vertices in local or world space.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        gain | ga: (create, edit, multiuse, query) - Gain factor per component. Can be painted using Artisan. Default: 1.0
        localDirection | ld: (create, edit, query) - Direction to determine X axis for local space. Default: 1.0, 0.0, 0.0
        localDirectionX | ldx: (create, edit, query) - X coord of the X axis.
        localDirectionY | ldy: (create, edit, query) - Y coord of the X axis.
        localDirectionZ | ldz: (create, edit, query) - Z coord of the X axis.
        localTranslate | lt: (create, edit, query) - Local translate. Default: 0.0, 0.0, 0.0
        localTranslateX | ltx: (create, edit, query) - Local translation X coord.
        localTranslateY | lty: (create, edit, query) - Local translation Y coord.
        localTranslateZ | ltz: (create, edit, query) - Local translation Z coord : Move along the normal.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        pivot | pvt: (create, edit, query) - The pivot for scaling and rotation. Default: 0.0, 0.0, 0.0
        pivotX | pvx: (create, edit, query) - Pivot X coord.
        pivotY | pvy: (create, edit, query) - Pivot Y coord.
        pivotZ | pvz: (create, edit, query) - Pivot Z coord.
        random | ran: (create, edit, query) - Random value for all parameters. Default: 0.0
        rotate | ro: (create, edit, query) - Rotation angles around X, Y, Z. Default: 0.0, 0.0, 0.0
        rotateX | rx: (create, edit, query) - Rotation angle around X.
        rotateY | ry: (create, edit, query) - Rotation angle around Y.
        rotateZ | rz: (create, edit, query) - Rotation angle around Z.
        scale | s: (create, edit, query) - Scaling vector. Default: 1.0, 1.0, 1.0
        scaleX | sx: (create, edit, query) - Scale X coord.
        scaleY | sy: (create, edit, query) - Scale Y coord.
        scaleZ | sz: (create, edit, query) - Scale Z coord.
        translate | t: (create, edit, query) - Translation vector. Default: 0.0, 0.0, 0.0
        translateX | tx: (create, edit, query) - Translation X coord.
        translateY | ty: (create, edit, query) - Translation Y coord.
        translateZ | tz: (create, edit, query) - Translation Z coord.
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyMultiLayoutUV(*args, flipReversed: bool = ..., fr: bool = ..., gridU: Optional[Union[int, bool]] = ..., gu: Optional[Union[int, bool]] = ..., gridV: Optional[Union[int, bool]] = ..., gv: Optional[Union[int, bool]] = ..., layout: Optional[Union[int, bool]] = ..., l: Optional[Union[int, bool]] = ..., layoutMethod: Optional[Union[int, bool]] = ..., lm: Optional[Union[int, bool]] = ..., offsetU: Optional[Union[float, bool]] = ..., ou: Optional[Union[float, bool]] = ..., offsetV: Optional[Union[float, bool]] = ..., ov: Optional[Union[float, bool]] = ..., percentageSpace: Optional[Union[float, bool]] = ..., ps: Optional[Union[float, bool]] = ..., prescale: Optional[Union[int, bool]] = ..., psc: Optional[Union[int, bool]] = ..., rotateForBestFit: Optional[Union[int, bool]] = ..., rbf: Optional[Union[int, bool]] = ..., scale: Optional[Union[int, bool]] = ..., sc: Optional[Union[int, bool]] = ..., sizeU: Optional[Union[float, bool]] = ..., su: Optional[Union[float, bool]] = ..., sizeV: Optional[Union[float, bool]] = ..., sv: Optional[Union[float, bool]] = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ...) -> Any:
    r"""
    place the UVs of the selected polygonal objects so that they do not overlap.

    Args:
        flipReversed | fr: (create) - If this flag is turned on, the reversed UV pieces are fliped.
        gridU | gu: (create) - The U size of the grids.
        gridV | gv: (create) - The V size of the grids.
        layout | l: (create) - How to move the UV pieces, after cuts are applied: 0 No move is applied. 1 Layout the pieces along the U axis. 2 Layout the pieces in a square shape. 3 Layout the pieces in grids. 4 Layout the pieces in nearest regions.
        layoutMethod | lm: (create) - // -lm/layoutMethod     layoutMethod  integer //      (C, E, Q) Which layout method to use: //              0 Block Stacking. //              1 Shape Stacking.
        offsetU | ou: (create) - Offset the layout in the U direction by the given value.
        offsetV | ov: (create) - Offset the layout in the V direction by the given value.
        percentageSpace | ps: (create) - When layout is set to square, this value is a percentage of the texture area which is added around each UV piece. It can be used to ensure each UV piece uses different pixels in the texture. Maximum value is 5 percent.
        prescale | psc: (create) - Prescale the shell before laying it out. 0 No scale is applied. 1 Object space scaling applied. 2 World space scaling applied.
        rotateForBestFit | rbf: (create) - How to rotate the pieces, before move: 0 No rotation is applied. 1 Only allow 90 degree rotations. 2 Allow free rotations.
        scale | sc: (create) - How to scale the pieces, after move: 0 No scale is applied. 1 Uniform scale to fit in unit square. 2 Non proportional scale to fit in unit square.
        sizeU | su: (create) - Scale the layout in the U direction by the given value.
        sizeV | sv: (create) - Scale the layout in the V direction by the given value.
        uvSetName | uvs: (create) - Specifies the name of the uv set to edit uvs on. If not specified will use the current uv set if it exists.
    """
    ...


def polyNormal(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., normalMode: Optional[Union[int, bool]] = ..., nm: Optional[Union[int, bool]] = ..., userNormalMode: bool = ..., unm: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Control the normals of an object. This command works on faces
    or polygonal objects.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        normalMode | nm: (create, edit, query) - Normal mode     : 0=reverse, 1=propagate, 2=conform, 3=reverseAndCut, 4=reverseAndPropagate Default: 0
        userNormalMode | unm: (create, edit, query) - Determines if user normals needs to be reversed as well. Default: true
    """
    ...


def polyNormalizeUV(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createNewMap: bool = ..., cm: bool = ..., insertBeforeDeformers: bool = ..., ibd: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., centerOnTile: bool = ..., cot: bool = ..., normalizeDirection: Optional[Union[int, bool]] = ..., nd: Optional[Union[int, bool]] = ..., normalizeType: Optional[Union[int, bool]] = ..., nt: Optional[Union[int, bool]] = ..., preserveAspectRatio: bool = ..., pa: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Normalizes the UVs of input polyFaces. The existing UVs of the faces
    are normalized between 0 and 1.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createNewMap | cm: (create) - Set to true if a new map should be created
        insertBeforeDeformers | ibd: (create) - Set to true if the new node created should inserted before any deformer nodes.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        uvSetName | uvs: (create) - Name of the UV set to be created
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
        centerOnTile | cot: (create, edit, query) - If true, will center UV's on the UV tile they are most over. If false, will center UV's in the 0-1 region.
        normalizeDirection | nd: (create, edit, query) - Scale along U or V or both.   0 UV   1 U   2 V   C:  Default is 0. Q:  When queried, returns an int.
        normalizeType | nt: (create, edit, query) - Options for normalize.   0 Separate   1 Collective   C:  Default is 1. Q:  When queried, returns an int.
        preserveAspectRatio | pa: (create, edit, query) - Scale uniform along u and v. C: Default is on. Q: When queried, returns an int.
    """
    ...


def polyNormalPerVertex(*args, allLocked: bool = ..., al: bool = ..., deformable: bool = ..., freezeNormal: bool = ..., fn: bool = ..., normalX: Optional[Union[float, bool]] = ..., x: Optional[Union[float, bool]] = ..., normalXYZ: Optional[Union[Tuple[float, float, float], bool]] = ..., xyz: Optional[Union[Tuple[float, float, float], bool]] = ..., normalY: Optional[Union[float, bool]] = ..., y: Optional[Union[float, bool]] = ..., normalZ: Optional[Union[float, bool]] = ..., z: Optional[Union[float, bool]] = ..., relative: bool = ..., rel: bool = ..., unFreezeNormal: bool = ..., ufn: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Command associates normal(x, y, z) with vertices on polygonal objects.
    When used with the query flag, it returns the normal associated with the
    specified components. However, when queried, the command returns all
    normals (all vtx-face combinations) on the vertex, regardless of whether
    they are shared or not.

    Args:
        allLocked | al: (create, edit, query) - Queries if all normals on the selected vertices are locked (frozen) or not
        deformable | deformable: (create, edit, query) - DEFAULT  true OBSOLETE flag. This flag will be removed in the next release.
        freezeNormal | fn: (create, edit, query) - Specifies that the normal values be frozen (locked) at the current value.
        normalX | x: (create, edit, query) - Specifies the x value normal
        normalXYZ | xyz: (create, edit, multiuse, query) - Specifies the xyz values normal If this flag is used singly, the specified normal xyz values are used for all selected components. If the flag is used multiple times, the number of uses must match the number of selected components, and each use specifies the normal of one component.
        normalY | y: (create, edit, query) - Specifies the y value normal
        normalZ | z: (create, edit, query) - Specifies the z value normal
        relative | rel: (create, edit, query) - When used, the normal values specified are added relative to the current value.
        unFreezeNormal | ufn: (create, edit, query) - Specifies that the normal values that were frozen at the current value be un-frozen (un-locked).
    """
    ...


def polyOptions(*args, activeObjects: bool = ..., ao: bool = ..., allEdges: bool = ..., ae: bool = ..., backCullVertex: bool = ..., bcv: bool = ..., backCulling: bool = ..., bc: bool = ..., colorMaterialChannel: Optional[Union[str, bool]] = ..., cm: Optional[Union[str, bool]] = ..., colorShadedDisplay: bool = ..., cs: bool = ..., displayAlphaAsGreyScale: bool = ..., dal: bool = ..., displayBlueChannel: bool = ..., dbc: bool = ..., displayBorder: bool = ..., db: bool = ..., displayCenter: bool = ..., dc: bool = ..., displayColorAsGreyScale: bool = ..., dcl: bool = ..., displayCreaseEdge: bool = ..., dce: bool = ..., displayCreaseVertex: bool = ..., dcv: bool = ..., displayGeometry: bool = ..., dg: bool = ..., displayGreenChannel: bool = ..., dgc: bool = ..., displayInvisibleFaces: bool = ..., dif: bool = ..., displayItemNumbers: Optional[Union[Tuple[bool, bool, bool, bool], bool]] = ..., din: Optional[Union[Tuple[bool, bool, bool, bool], bool]] = ..., displayMapBorder: bool = ..., dmb: bool = ..., displayMetadata: Optional[Union[Tuple[bool, bool, bool], bool]] = ..., dmt: Optional[Union[Tuple[bool, bool, bool], bool]] = ..., displayNormal: bool = ..., dn: bool = ..., displayRedChannel: bool = ..., drc: bool = ..., displaySubdComps: bool = ..., dsc: bool = ..., displayTangent: bool = ..., dtn: bool = ..., displayTriangle: bool = ..., dt: bool = ..., displayUVTopology: bool = ..., uvt: bool = ..., displayUVs: bool = ..., duv: bool = ..., displayVertex: bool = ..., dv: bool = ..., displayWarp: bool = ..., dw: bool = ..., facet: bool = ..., f: bool = ..., fullBack: bool = ..., fb: bool = ..., gl: bool = ..., hardBack: bool = ..., hb: bool = ..., hardEdge: bool = ..., he: bool = ..., hardEdgeColor: bool = ..., hec: bool = ..., materialBlend: Optional[Union[str, bool]] = ..., mb: Optional[Union[str, bool]] = ..., newPolymesh: bool = ..., np: bool = ..., point: bool = ..., pt: bool = ..., pointFacet: bool = ..., pf: bool = ..., relative: bool = ..., r: bool = ..., reuseTriangles: bool = ..., rt: bool = ..., sizeBorder: Optional[Union[float, bool]] = ..., sb: Optional[Union[float, bool]] = ..., sizeNormal: Optional[Union[float, bool]] = ..., sn: Optional[Union[float, bool]] = ..., sizeUV: Optional[Union[float, bool]] = ..., suv: Optional[Union[float, bool]] = ..., sizeVertex: Optional[Union[float, bool]] = ..., sv: Optional[Union[float, bool]] = ..., smoothDrawType: Optional[Union[int, bool]] = ..., sdt: Optional[Union[int, bool]] = ..., softEdge: bool = ..., se: bool = ..., vertexNormalMethod: Optional[Union[int, bool]] = ..., vnm: Optional[Union[int, bool]] = ..., wireBackCulling: bool = ..., wbc: bool = ..., query: bool = ...) -> Any:
    r"""
    Changes the global display polygonal attributes.

    Args:
        activeObjects | ao: (create, query) - Apply user choices for all active objects.
        allEdges | ae: (create, query) - Display all edges in solid line.
        backCullVertex | bcv: (create, query) - BackCull vertices.
        backCulling | bc: (create, query) - Display with no back culling.
        colorMaterialChannel | cm: (create, query) - If colorShadedDisplay is true, then determines which material channel to display color per vertex in. The options are:  "none" : disable material shading "ambient" : ambient material channel "ambientDiffuse" :  ambient and diffuse material channel "diffuse" :  diffuse material channel "specular" :  specular material channel "emission" :  emission material channel
        colorShadedDisplay | cs: (create, query) - Use color per vertex display in shaded mode.
        displayAlphaAsGreyScale | dal: (create, query) - Display alpha as greyscale.
        displayBlueChannel | dbc: (create, query) - Display Blue channel.
        displayBorder | db: (create, query) - Highlight border edge.
        displayCenter | dc: (create, query) - Display facet centers.
        displayColorAsGreyScale | dcl: (create, query) - Display color channels as greyscale.
        displayCreaseEdge | dce: (create, query) - Highlight creased edges
        displayCreaseVertex | dcv: (create, query) - Highlight creased vertices
        displayGeometry | dg: (create, query) - Display geometry.
        displayGreenChannel | dgc: (create, query) - Display Green channel.
        displayInvisibleFaces | dif: (create, query) - Highlight invisible faces
        displayItemNumbers | din: (create, query) - Displays item numbers (vertices edges facets uvs)
        displayMapBorder | dmb: (create, query) - Highlight map border edge.
        displayMetadata | dmt: (create, query) - Displays component metadata (vertices edges facets vertexFaces)
        displayNormal | dn: (create, query) - Display normals.
        displayRedChannel | drc: (create, query) - Display Red channel.
        displaySubdComps | dsc: (create, query) - Display subdivided components when in Smooth Mesh Preview mode.
        displayTangent | dtn: (create, query) - Display tangent.
        displayTriangle | dt: (create, query) - Display triangulation.
        displayUVTopology | uvt: (create, query) - Option on UV display to display UVs topologically.
        displayUVs | duv: (create, query) - Display UVs.
        displayVertex | dv: (create, query) - Display vertices.
        displayWarp | dw: (create, query) - Highlight warped facets.
        facet | f: (create, query) - For use with -dn flag. Set the normal display style to facet display.
        fullBack | fb: (create, query) - Display with full back culling.
        gl | gl: (create, query) - Apply user choices for all objects.
        hardBack | hb: (create, query) - Backculled hard edges only for backculled faces.
        hardEdge | he: (create, query) - Display only hard edges.
        hardEdgeColor | hec: (create, query) - Display hard edges as separate color.
        materialBlend | mb: (create, query) - The options are: "overwrite" "add" "subtract" "multiply" "divide" "average" "modulate2x"
        newPolymesh | np: (create, query) - Set component display state of new polymesh objects.
        point | pt: (create, query) - For use with -dn flag. Set the normal display style to vertex display.
        pointFacet | pf: (create, query) - For use with -dn flag. Set the normal display style to vertex and face display.
        relative | r: (create, query) - When this flag is used with flags dealing with size, the value (size) is a multiplication factor : i.e for flags : -sizeNormal, -sizeBorder. When this flag is used with flags dealing with a boolean value, the boolean value is toggled : i.e for flags : displayVertex, displayCenter, displayTriangle, displayBorder, backCullVertex, displayWarp, displayItemNumbers.
        reuseTriangles | rt: (create, query) - Avoid regenerating triangles, by reusing the old triangles upstream in the construction history.  The construction history is searched upstream and downstream for other mesh nodes, and the given boolean value is set on those mesh nodes.  Note, that this command does not set the value on the given mesh node.  That has to be done using the setAttr command. This option would affect only the interactive 3d viewport. The batch-rendering would use the properly computed triangles. This is useful only for interactive performance such as skinning playback, when the display mode is shaded (or wireframe with triangles displayed)  Using this option for wireframe display mode is not recomended.
        sizeBorder | sb: (create, query) - Set the size of the polygonal border edges.
        sizeNormal | sn: (create, query) - Set the size of the polygonal normals.
        sizeUV | suv: (create, query) - Set the size of the polygonal UV.
        sizeVertex | sv: (create, query) - Set the size of the polygonal vertex.
        smoothDrawType | sdt: (create, query) - This setting only works with the newPolymesh flag. Sets a new default attribute value for the smoothDrawType attribute on a polymesh object. Options are: 0: Catmull-Clark 1: Linear 2: OpenSubdiv Catmull-Clark Uniform 3: OpenSubdiv Catmull-Clark Adaptive
        softEdge | se: (create, query) - Display soft edges in dotted lines.
        vertexNormalMethod | vnm: (create, query) - This setting only works with the newPolymesh flag. Sets a new default attribute value for the vertexNormalMethod attribute on a polymesh object. Options are: 0: Unweighted 1: Angle Weighted 2: Area Weighted 3: Angle And Area Weighted
        wireBackCulling | wbc: (create, query) - Backculled faces are in wireframe.
    """
    ...


def polyOptUvs(*args, applyToShell: bool = ..., areaWeight: Optional[Union[float, bool]] = ..., aw: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., globalBlend: Optional[Union[float, bool]] = ..., gb: Optional[Union[float, bool]] = ..., globalMethodBlend: Optional[Union[float, bool]] = ..., gmb: Optional[Union[float, bool]] = ..., iterations: Optional[Union[int, bool]] = ..., i: Optional[Union[int, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., optimizeAxis: Optional[Union[int, bool]] = ..., oa: Optional[Union[int, bool]] = ..., pinSelected: bool = ..., ps: bool = ..., pinUvBorder: bool = ..., pub: bool = ..., scale: Optional[Union[float, bool]] = ..., s: Optional[Union[float, bool]] = ..., stoppingThreshold: Optional[Union[float, bool]] = ..., ss: Optional[Union[float, bool]] = ..., useScale: bool = ..., us: bool = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Optimizes selected UVs.

    Args:
        applyToShell | applyToShell: (create) - Specifies where the whole object or just shells that are selected or pinned should be affected.
        areaWeight | aw: (create) - Surface driven importance. 0 treat all faces equal. 1 gives more importance to large ones.
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        globalBlend | gb: (create) - This allows the user to blend between a local optimization method (globalBlend = 0.0) and a global optimization method (globalBlend = 1.0). The local optimization method looks at the ratio between the triangles on the object and the triangles in UV space.  It has a side affect that it can sometimes introduce tapering problems.  The global optimization is much slower, but takes into consideration the entire object when optimizing uv placement.
        globalMethodBlend | gmb: (create) - The global optimization method uses two functions to compute a minimization.  The first function controls edge stretch by using edges lengths between xyz and uv.  The second function penalizes the first function by preventing configurations where triangles would overlap.  For every surface there is a mix between these two functions that will give the appropriate response. Values closer to 1.0 give more weight to the edge length function. Values closer to 0.0 give more weight to surface area.  The default value of '0.5' is a even mix between these two values.
        iterations | i: (create) - Maximum number of iterations for each connected UV piece.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        optimizeAxis | oa: (create) - Degree of freedom for optimization: 0=Optimize freely, 1=Move vertically only, 2=Move horzontally only
        pinSelected | ps: (create) - Specifies that the selected components should be pinned instead of the unselected components.
        pinUvBorder | pub: (create) - Specifies that the UV border should be pinned when doing the solve. By default only unselected components are pinned.
        scale | s: (create) - Ratio between 2d and 3d space.
        stoppingThreshold | ss: (create) - Minimum distorsion improvement between two steps in %.
        useScale | us: (create) - Adjust the scale or not.
        uvSetName | uvs: (create) - Name of the UV set to be created
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyOutput(*args, allValues: bool = ..., a: bool = ..., color: bool = ..., c: bool = ..., colorDesc: bool = ..., cd: bool = ..., edge: bool = ..., e: bool = ..., edgeFace: bool = ..., ef: bool = ..., face: bool = ..., f: bool = ..., faceNorm: bool = ..., fn: bool = ..., force: bool = ..., fo: bool = ..., group: bool = ..., g: bool = ..., noOutput: bool = ..., no: bool = ..., normDesc: bool = ..., nd: bool = ..., outputFile: Optional[Union[str, bool]] = ..., of: Optional[Union[str, bool]] = ..., triangle: bool = ..., t: bool = ..., uvDesc: bool = ..., uvd: bool = ..., uvValue: bool = ..., uv: bool = ..., vert: bool = ..., v: bool = ..., vertEdge: bool = ..., ve: bool = ..., vertNorm: bool = ..., vn: bool = ...) -> Any:
    r"""
    Dumps a description of internal memory representation of poly objects.
    If no objects are specified in the command line, then the
    objects from the active list are used.
    If information on the geometry in the history of a poly shape is desired,
    then the plug of interest needs to be specified in the command line.
    Default behaviour is to print only a summary. Use the flags
    above to get more details on a specific part of the object.

    Args:
        allValues | a: (create) - Shortcut for setting all the flags above
        color | c: (create) - Prints the color per vertex. In case of multiple sets, all sets are printed.
        colorDesc | cd: (create) - Print the color per vertex description. Each integer is an entry in the color array.
        edge | e: (create) - Print the edge description.
        edgeFace | ef: (create) - Prints the edge to face adjascency list. Only available if the information is already computed on the object.
        face | f: (create) - Print the faces description
        faceNorm | fn: (create) - Prints the normals per face. Only available if the information is already computed on the object.
        force | fo: (create) - Force evaluation of missing pieces before printing.
        group | g: (create) - Print the groups of the object.
        noOutput | no: (create) - Dont output any data.  Would be useful if you want to just evaluate the data, for testing purposes.
        normDesc | nd: (create) - Prints the normals per vertex description. Each integer is an entry in the vertNorm array. Only available if the information is already computed on the object.
        outputFile | of: (create) - Location of the output file.
        triangle | t: (create) - Prints the triangles per face. Only available if the information is already computed on the object.
        uvDesc | uvd: (create) - Print the UV description. Each integer is an entry in the uvValue array.
        uvValue | uv: (create) - Prints the UV positions. In case of multiple UV sets, all sets are printed.
        vert | v: (create) - Prints the vertex positions.
        vertEdge | ve: (create) - Prints the vertex to edge adjascency list. Only available if the information is already computed on the object.
        vertNorm | vn: (create) - Prints the normals per vertex. Only available if the information is already computed on the object.
    """
    ...


def polyPinUV(*args, createHistory: bool = ..., ch: bool = ..., operation: Optional[Union[int, bool]] = ..., op: Optional[Union[int, bool]] = ..., unpinned: bool = ..., unp: bool = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ..., value: Optional[Union[float, bool]] = ..., v: Optional[Union[float, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command is used to pin and unpin UVs. A "pinned" UV is one which should not be modified.
    
    
    Each UV has an associated pin weight, that defaults to 0.0 meaning that the UV is not pinned. If pin weight is set to 1.0 then it becomes fully pinned and UV tools should not modify that UV.
    If the pin weight is set to a value between 0.0 and 1.0 then UV tools should weight their changes to that UV accordingly.
    
    
    UV pinning is not enforced by the shape node: it is up to each tool to decide whether it will obey the pin weights.

    Args:
        createHistory | ch: (create, edit, query) - For objects that have no construction history, this flag can be used to force the creation of construction history for pinning.  By default, history is not created if the object has no history.  Regardless of this flag, history is always created if the object already has history.
        operation | op: (create, edit, query) - Operation to perform.  Valid values are: 0: Set pin weights on the selected UVs. 1: Set pin weights to zero for the selected UVs. 2: Remove pin weights from the entire mesh. 3: Invert pin weights of the entire mesh. Default is 0.
        unpinned | unp: (edit, query) - List all selected UVs which are not pinned.
        uvSetName | uvs: (create, edit, query) - Specifies the name of the UV set to edit UVs on. If not specified the current UV set will be used if it exists.
        value | v: (create, edit, multiuse, query) - Specifies the pin value for the selected UV components. When specified multiple times, the values are assigned respectively to the specified UVs.
    """
    ...


def polyPipe(*args, axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createUVs: bool = ..., cuv: bool = ..., height: Optional[Union[float, bool]] = ..., h: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., roundCap: bool = ..., rcp: bool = ..., subdivisionsAxis: Optional[Union[int, bool]] = ..., sa: Optional[Union[int, bool]] = ..., subdivisionsCaps: Optional[Union[int, bool]] = ..., sc: Optional[Union[int, bool]] = ..., subdivisionsHeight: Optional[Union[int, bool]] = ..., sh: Optional[Union[int, bool]] = ..., texture: bool = ..., tx: bool = ..., thickness: Optional[Union[float, bool]] = ..., t: Optional[Union[float, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The polyPipe command creates a new polygonal pipe.

    Args:
        axis | ax: (create, edit, query) - This flag specifies the primitive axis used to build the pipe. Q: When queried, this flag returns a float[3].
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createUVs | cuv: (create, edit, query) - Create UVs or not. Default: true
        height | h: (create, edit, query) - Height of the pipe. Default: 2.0
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        object | o: (create) - Create the result, or just the dependency node (where applicable).
        radius | r: (create, edit, query) - Radius of the pipe. Default: 1.0
        roundCap | rcp: (create, edit, query) - To indicate whether we need a round cap Default: false
        subdivisionsAxis | sa: (create, edit, query) - Subdivisions around the axis. Default: 20
        subdivisionsCaps | sc: (create, edit, query) - Subdivisions along the thickness caps. Default: 1
        subdivisionsHeight | sh: (create, edit, query) - Subdivisions along the height. Default: 1
        texture | tx: (create, edit, query) - Apply texture or not. this is an old attribute. This is unsupported and would be removed in a future release. Default: true
        thickness | t: (create, edit, query) - Thickness of the pipe. Default: 0.5
    """
    ...


def polyPlanarProjection(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createNewMap: bool = ..., cm: bool = ..., imageCenter: Optional[Union[Tuple[float, float], bool]] = ..., ic: Optional[Union[Tuple[float, float], bool]] = ..., imageCenterX: Optional[Union[float, bool]] = ..., icx: Optional[Union[float, bool]] = ..., imageCenterY: Optional[Union[float, bool]] = ..., icy: Optional[Union[float, bool]] = ..., imageScale: Optional[Union[Tuple[float, float], bool]] = ..., imageScaleU: Optional[Union[float, bool]] = ..., isu: Optional[Union[float, bool]] = ..., imageScaleV: Optional[Union[float, bool]] = ..., isv: Optional[Union[float, bool]] = ..., insertBeforeDeformers: bool = ..., ibd: bool = ..., keepImageRatio: bool = ..., kir: bool = ..., mapDirection: Optional[Union[str, bool]] = ..., md: Optional[Union[str, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., perInstance: bool = ..., pi: bool = ..., projectionCenter: Optional[Union[Tuple[float, float, float], bool]] = ..., pc: Optional[Union[Tuple[float, float, float], bool]] = ..., projectionCenterX: Optional[Union[float, bool]] = ..., pcx: Optional[Union[float, bool]] = ..., projectionCenterY: Optional[Union[float, bool]] = ..., pcy: Optional[Union[float, bool]] = ..., projectionCenterZ: Optional[Union[float, bool]] = ..., pcz: Optional[Union[float, bool]] = ..., projectionHeight: Optional[Union[float, bool]] = ..., ph: Optional[Union[float, bool]] = ..., projectionScale: Optional[Union[Tuple[float, float], bool]] = ..., ps: Optional[Union[Tuple[float, float], bool]] = ..., rotate: Optional[Union[Tuple[float, float, float], bool]] = ..., ro: Optional[Union[Tuple[float, float, float], bool]] = ..., rotateX: Optional[Union[float, bool]] = ..., rx: Optional[Union[float, bool]] = ..., rotateY: Optional[Union[float, bool]] = ..., ry: Optional[Union[float, bool]] = ..., rotateZ: Optional[Union[float, bool]] = ..., rz: Optional[Union[float, bool]] = ..., rotationAngle: Optional[Union[float, bool]] = ..., ra: Optional[Union[float, bool]] = ..., smartFit: bool = ..., sf: bool = ..., worldSpace: bool = ..., ws: bool = ..., projectionHorizontalSweep: Optional[Union[float, bool]] = ..., phs: Optional[Union[float, bool]] = ..., seamCorrect: bool = ..., sc: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    TpolyProjCmdBase is a base class for the command to create a mapping on the selected polygonal faces.
    Projects a map onto an object, using an orthogonal projection. The
    piece of the map defined from isu, isv, icx, icy area, is placed at
    pcx, pcy, pcz location.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createNewMap | cm: (create, query) - This flag when set true will create a new map with a the name passed in, if the map does not already exist.
        imageCenter | ic: (create, edit, query) - The center point of the 2D model layout. Default: 0.5, 0.5
        imageCenterX | icx: (create, edit, query) - Image center X coord.
        imageCenterY | icy: (create, edit, query) - Image center Y coord.
        imageScale | imageScale: (create, edit, query) - Specifies the UV scale : Enlarges or reduces the 2D version of the model in U or V space relative to the 2D centerpoint. Default: 1.0, 1.0
        imageScaleU | isu: (create, edit, query) - The the U scale : Enlarges or reduces the 2D version of the model in U space relative to the 2D centerpoint.
        imageScaleV | isv: (create, edit, query) - The V scale : Enlarges or reduces the 2D version of the model in V space relative to the 2D centerpoint.
        insertBeforeDeformers | ibd: (create) - This flag specifies if the projection node should be inserted before or after deformer nodes already applied to the shape. Inserting the projection after the deformer leads to texture swimming during animation and is most often undesirable. C: Default is on.
        keepImageRatio | kir: (create) - True means keep any image ratio
        mapDirection | md: (create) - This flag specifies the mapping direction. 'x', 'y' and 'z' projects the map along the corresponding axis. 'c' projects along the current camera viewing direction. 'p' does perspective projection if current camera is perspective. 'b' projects along the best plane fitting the objects selected.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        perInstance | pi: (create) - True if the new map is per-instance, otherwise it is shared.
        projectionCenter | pc: (create, edit, query) - The point on the object that will be the center of the projection. Default: 0.0, 0.0, 0.0
        projectionCenterX | pcx: (create, edit, query) - Projection center X coord.
        projectionCenterY | pcy: (create, edit, query) - Projection center Y coord.
        projectionCenterZ | pcz: (create, edit, query) - Projection center Z coord.
        projectionHeight | ph: (create, edit, query) - The height of the map relative to the 3D projection axis.
        projectionScale | ps: (create, edit, query) - The width and the height of the map relative to the 3D projection axis. Default: 1.0, 1.0
        rotate | ro: (create, edit, query) - The mapping rotate angles. Default: 0.0, 0.0, 0.0
        rotateX | rx: (create, edit, query) - X mapping rotate angle.
        rotateY | ry: (create, edit, query) - Y mapping rotate angle.
        rotateZ | rz: (create, edit, query) - Z mapping rotate angle.
        rotationAngle | ra: (create, edit, query) - The angle for the rotation. When the angle is positive, then the map rotates counterclockwise on the mapped model; if negative, the map rotates clockwise. Default: 0.0
        smartFit | sf: (create) - True means use the smart fit algorithm
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
        projectionHorizontalSweep | phs: (create, edit, query) - The angle swept horizontally by the projection.  The range is [0, 360].
        seamCorrect | sc: (create, edit, query) - This flag specifies to perform a seam correction on the mapped faces.
    """
    ...


def polyPlane(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., createUVs: Optional[Union[int, bool]] = ..., cuv: Optional[Union[int, bool]] = ..., height: Optional[Union[float, bool]] = ..., h: Optional[Union[float, bool]] = ..., subdivisionsHeight: Optional[Union[int, bool]] = ..., sh: Optional[Union[int, bool]] = ..., subdivisionsWidth: Optional[Union[int, bool]] = ..., sw: Optional[Union[int, bool]] = ..., subdivisionsX: Optional[Union[int, bool]] = ..., sx: Optional[Union[int, bool]] = ..., subdivisionsY: Optional[Union[int, bool]] = ..., sy: Optional[Union[int, bool]] = ..., texture: Optional[Union[int, bool]] = ..., tx: Optional[Union[int, bool]] = ..., width: Optional[Union[float, bool]] = ..., w: Optional[Union[float, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Create a new polygonal plane.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        object | o: (create) - Create the result, or just the dependency node (where applicable).
        axis | ax: (create, edit, query) - This flag specifies the primitive axis used to build the plane.
        createUVs | cuv: (create, edit, query) - Create UVs or not. 0: No UVs 1: No Normalization 2: Normalize and Preserve Aspect Ratio Default: 1
        height | h: (create, edit, query) - Height of the plane. Default: 1.0
        subdivisionsHeight | sh: (create, edit, query) - Subdivisions along the height of the sphere.
        subdivisionsWidth | sw: (create, edit, query) - Subdivisions along the width of the plane. Default: 10
        subdivisionsX | sx: (create, edit, query) - This specifies the number of subdivisions in the X direction for the plane. Default is 5.
        subdivisionsY | sy: (create, edit, query) - This flag specifies the number of subdivisions in the Y direction for the plane. Default is 5.
        texture | tx: (create, edit, query) - What texture mechanism to be applied. 0=No textures; 1=stretch to fit; 2=preserve aspect ratio Default: 1
        width | w: (create, edit, query) - Width of the plane. Default: 1.0
    """
    ...


def polyPlatonicSolid(*args, axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createUVs: Optional[Union[int, bool]] = ..., cuv: Optional[Union[int, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., sideLength: Optional[Union[float, bool]] = ..., l: Optional[Union[float, bool]] = ..., solidType: Optional[Union[int, bool]] = ..., st: Optional[Union[int, bool]] = ..., texture: Optional[Union[int, bool]] = ..., tx: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The polyPlatonicSolid command creates a new polygonal platonic solid.

    Args:
        axis | ax: (create, edit, query) - This flag specifies the primitive axis used to build the platonic solid. Q: When queried, this flag returns a float[3].
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createUVs | cuv: (create) - This flag alows a specific UV mechanism to be selected, while creating. The valid values are 0, 1,  2 ,3 or 4. 0 implies that no UVs will be generated (No texture to be applied).  1 implies UVs should be created for the object as a whole without any normalization.  The solid will be unwrapped and then the texture will be applied  without any distortion.  In the unwrapped solid, the shared edges will have shared UVs.  2 implies UVs are created separately for each of the faces of the solid.  3 implies the UVs should be normalized. This will normalize the  U and V direction separately, thereby resulting in distortion of textures.  4 implies UVs are created so that the texture will not be distorted when applied.  The texture lying outside the UV range will be truncated (since that cannot be  squeezed in, without distorting the texture.    For better understanding of these options, you may have to open the      texture view window  C: Default is 4
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        object | o: (create) - Create the result, or just the dependency node (where applicable).
        radius | r: (create, edit, query) - This flag specifies the radius of the platonic solid. C: Default is 1.0. Q: When queried, this flag returns a float.
        sideLength | l: (create, edit, query) - This flag specifies the side length of platonic solid. C: Default is 1.0. Q: When queried, this flag returns a float.
        solidType | st: (create) - This flag allows a specific platonic solid to be selected for creation of mesh, The valid values are 0, 1, 2 and 3. 0 implies dodecahedron to be created. 1 implies icosahedron to be created. 2 implies octahedron to be created. 3 implies tertrahedron to be created.  C: Default is 0
        texture | tx: (create) - This flag is obsolete and will be removed in the next release. The -cuv/createUVs flag should be used instead.
    """
    ...


def polyPoke(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., localTranslate: Optional[Union[Tuple[float, float, float], bool]] = ..., lt: Optional[Union[Tuple[float, float, float], bool]] = ..., localTranslateX: Optional[Union[float, bool]] = ..., ltx: Optional[Union[float, bool]] = ..., localTranslateY: Optional[Union[float, bool]] = ..., lty: Optional[Union[float, bool]] = ..., localTranslateZ: Optional[Union[float, bool]] = ..., ltz: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., translate: Optional[Union[Tuple[float, float, float], bool]] = ..., t: Optional[Union[Tuple[float, float, float], bool]] = ..., translateX: Optional[Union[float, bool]] = ..., tx: Optional[Union[float, bool]] = ..., translateY: Optional[Union[float, bool]] = ..., ty: Optional[Union[float, bool]] = ..., translateZ: Optional[Union[float, bool]] = ..., tz: Optional[Union[float, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Introduces a new vertex in the middle of the selected face,
    and connects it to the rest of the vertices of the face.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        localTranslate | lt: (create) - Translate the new vertex in the local face coordinate.
        localTranslateX | ltx: (create) - Translate the new vertex in the local face coordinate along X.
        localTranslateY | lty: (create) - Translate the new vertex in the local face coordinate along Y.
        localTranslateZ | ltz: (create) - Translate the new vertex in the local face coordinate along Z.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        translate | t: (create) - Translate the new vertex in the world space.
        translateX | tx: (create) - Translate the new vertex in the world space along X.
        translateY | ty: (create) - Translate the new vertex in the world space along Y.
        translateZ | tz: (create) - Translate the new vertex in the world space along Z.
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyPrimitive(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., createUVs: Optional[Union[int, bool]] = ..., cuv: Optional[Union[int, bool]] = ..., polyType: Optional[Union[int, bool]] = ..., pt: Optional[Union[int, bool]] = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., sideLength: Optional[Union[float, bool]] = ..., l: Optional[Union[float, bool]] = ..., texture: Optional[Union[int, bool]] = ..., tx: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Create a polygon primative

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        object | o: (create) - Create the result, or just the dependency node (where applicable).
        axis | ax: (create, edit, query) - This flag specifies the primitive axis used to build the primitive polygon. Q: When queried, this flag returns a float[3].
        createUVs | cuv: (create, edit, query) - Create UVs or not. 0: No UVs 1: No Normalization 2: Normalize Each Face Separately 3: Normalize Collectively 4: Normalize and Preserve Aspect Ratio
        polyType | pt: (create) - This flag allows a specific primitive poly to be selected for creation of mesh, The valid values is 0 0 implies soccer ball to be created. C: Default is 0
        radius | r: (create, edit, query) - This flag specifies the radius of the primitive polygon. C: Default is 1.0. Q: When queried, this flag returns a float.
        sideLength | l: (create, edit, query) - This flag specifies the side length of primitive polygon. C: Default is 1.0. Q: When queried, this flag returns a float.
        texture | tx: (create, edit, query) - What texture mechanism to be applied 0=No textures, 1=Object, 2=Faces
    """
    ...


def polyPrism(*args, axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createUVs: Optional[Union[int, bool]] = ..., cuv: Optional[Union[int, bool]] = ..., length: Optional[Union[float, bool]] = ..., l: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., numberOfSides: Optional[Union[int, bool]] = ..., ns: Optional[Union[int, bool]] = ..., numderOfSides: Optional[Union[int, bool]] = ..., nsi: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., sideLength: Optional[Union[float, bool]] = ..., w: Optional[Union[float, bool]] = ..., subdivisionsCaps: Optional[Union[int, bool]] = ..., sc: Optional[Union[int, bool]] = ..., subdivisionsHeight: Optional[Union[int, bool]] = ..., sh: Optional[Union[int, bool]] = ..., texture: Optional[Union[int, bool]] = ..., tx: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The prism command creates a new polygonal prism.

    Args:
        axis | ax: (create, edit, query) - This flag specifies the primitive axis used to build the prism. Q: When queried, this flag returns a float[3].
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createUVs | cuv: (create) - This flag alows a specific UV mechanism to be selected, while creating the primitive. The valid values are 0, 1,  2 or 3. 0 implies that no UVs will be generated (No texture to be applied).  1 implies UVs should be created for the object as a whole without any normalization.  The primitive will be unwrapped and then the texture will be applied  without any distortion.  In the unwrapped primitive, the shared edges will have shared UVs.  2 implies the UVs should be normalized. This will normalize the  U and V direction separately, thereby resulting in distortion of textures.  3 implies UVs are created so that the texture will not be distorted when applied.  The texture lying outside the UV range will be truncated (since that cannot be  squeezed in, without distorting the texture.    For better understanding of these options, you may have to open the      texture view window  C: Default is 2.
        length | l: (create, edit, query) - This flag specifies the length of the prism. C: Default is 2.0. Q: When queried, this flag returns a float.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        numberOfSides | ns: (create, edit, query) - This specifies the number of sides for the prism. C: Default is 3. Q: When queried, this flag returns an int.
        numderOfSides | nsi: (create, edit, query) - This specifies the number of sides for the prism. C: Default is 3. Q: When queried, this flag returns an int.
        object | o: (create) - Create the result, or just the dependency node (where applicable).
        sideLength | w: (create, edit, query) - This flag specifies the edge length of the prism. C: Default is 2.0. Q: When queried, this flag returns a float.
        subdivisionsCaps | sc: (create, edit, query) - This flag specifies the subdivisions on the caps for the prism. C: Default is 2. Q: When queried, this flag returns an int.
        subdivisionsHeight | sh: (create, edit, query) - This specifies the subdivisions along the height for the prism. C: Default is 1. Q: When queried, this flag returns an int.
        texture | tx: (create) - This flag is obsolete and will be removed in the next release. The -cuv/createUVs flag should be used instead.
    """
    ...


def polyProjectCurve(*args, addUnderTransform: bool = ..., aut: bool = ..., caching: bool = ..., cch: bool = ..., direction: Optional[Union[Tuple[float, float, float], bool]] = ..., d: Optional[Union[Tuple[float, float, float], bool]] = ..., directionX: Optional[Union[float, bool]] = ..., dx: Optional[Union[float, bool]] = ..., directionY: Optional[Union[float, bool]] = ..., dy: Optional[Union[float, bool]] = ..., directionZ: Optional[Union[float, bool]] = ..., dz: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The polyProjectCurve command creates curves by projecting a selected
    curve onto a selected poly mesh.  The direction of projection will be
    the current view direction unless the direction vector is specified
    with the -direction/-d flag.

    Args:
        addUnderTransform | aut: (create) - True if the resulting curve should be added under the source transform
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        direction | d: (create, edit, query) - Direction of projection.
        directionX | dx: (create, edit, query) - X direction of projection.
        directionY | dy: (create, edit, query) - Y direction of projection.
        directionZ | dz: (create, edit, query) - Z direction of projection.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        tolerance | tol: (create, edit, query) - Tolerance to fit to.
    """
    ...


def polyProjection(*args, constructionHistory: bool = ..., ch: bool = ..., createNewMap: bool = ..., cm: bool = ..., imageCenterX: Optional[Union[float, bool]] = ..., icx: Optional[Union[float, bool]] = ..., imageCenterY: Optional[Union[float, bool]] = ..., icy: Optional[Union[float, bool]] = ..., imageScaleU: Optional[Union[float, bool]] = ..., isu: Optional[Union[float, bool]] = ..., imageScaleV: Optional[Union[float, bool]] = ..., isv: Optional[Union[float, bool]] = ..., insertBeforeDeformers: bool = ..., ibd: bool = ..., keepImageRatio: bool = ..., kir: bool = ..., mapDirection: Optional[Union[str, bool]] = ..., md: Optional[Union[str, bool]] = ..., projectionCenterX: Optional[Union[float, bool]] = ..., pcx: Optional[Union[float, bool]] = ..., projectionCenterY: Optional[Union[float, bool]] = ..., pcy: Optional[Union[float, bool]] = ..., projectionCenterZ: Optional[Union[float, bool]] = ..., pcz: Optional[Union[float, bool]] = ..., projectionScaleU: Optional[Union[float, bool]] = ..., psu: Optional[Union[float, bool]] = ..., projectionScaleV: Optional[Union[float, bool]] = ..., psv: Optional[Union[float, bool]] = ..., rotateX: Optional[Union[float, bool]] = ..., rx: Optional[Union[float, bool]] = ..., rotateY: Optional[Union[float, bool]] = ..., ry: Optional[Union[float, bool]] = ..., rotateZ: Optional[Union[float, bool]] = ..., rz: Optional[Union[float, bool]] = ..., rotationAngle: Optional[Union[float, bool]] = ..., ra: Optional[Union[float, bool]] = ..., seamCorrect: bool = ..., sc: bool = ..., smartFit: bool = ..., sf: bool = ..., type: Optional[Union[str, bool]] = ..., t: Optional[Union[str, bool]] = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ...) -> Any:
    r"""
    Creates a mapping on the selected polygonal faces.  When construction
            history is created, the name of the new node is returned.  In other cases,
            the command returns nothing.

    Args:
        constructionHistory | ch: (create) - Turn the construction history on or off (where applicable).
        createNewMap | cm: (create) - Create new map if it does not exist.
        imageCenterX | icx: (create) - Specifies the X (U) translation of the projected UVs.         Default is 0.5.
        imageCenterY | icy: (create) - Specifies the Y (V) translation of the projected UVs.         Default is 0.5.
        imageScaleU | isu: (create) - Specifies the U scale factor of the projected UVs.         Default is 1.
        imageScaleV | isv: (create) - Specifies the V scale factor of the projected UVs.         Default is 1.
        insertBeforeDeformers | ibd: (create) - Specifies if the projection node should be inserted         before or after deformer nodes already applied to the shape.         Inserting the projection after the deformer leads to texture         swimming during animation and is most often undesirable.         Default is on.
        keepImageRatio | kir: (create) - Specifies if the xy scaling in the planar projection has to be         uniform.  By setting this flag, the texture aspect ratio is         preserved.  This flag is ignored for cylindrical and spherical         projections.
        mapDirection | md: (create) - Specifies the direction of the projection.  By specifying this flag, the         projection placement values (pcx, pcy, pcz, rx, ry, rz, psu, psv) are         internally computed.  If both this flag and the projection values are         specified, the projection values are ignored.         Valid Values are :                 X                       Projects along the X Axis                 Y                       Projects along the Y Axis                 Z                       Projects along the Z Axis                 bestPlane       Projects on the best plane fitting the object                 camera          Projects along the viewing direction                 perspective Creates perspective projection if current camera is perspective         Default is bestPlane.
        projectionCenterX | pcx: (create) - Specifies the X coordinate of the center of the projection manipulator.
        projectionCenterY | pcy: (create) - Specifies the Y coordinate of the center of the projection manipulator.
        projectionCenterZ | pcz: (create) - Specifies the Z coordinate of the center of the projection manipulator.
        projectionScaleU | psu: (create) - Specifies the U scale component of the projection manipulator.
        projectionScaleV | psv: (create) - Specifies the V scale component of the projection manipulator.
        rotateX | rx: (create) - Specifies the X-axis rotation of the projection manipulator.
        rotateY | ry: (create) - Specifies the Y-axis rotation of the projection manipulator.
        rotateZ | rz: (create) - Specifies the Z-axis rotation of the projection manipulator.
        rotationAngle | ra: (create) - Specifies the rotation of the projected UVs in the UV space.         Default is 0.
        seamCorrect | sc: (create) - Specifies if seam correction has to be done for spherical         and cylindrical projections.  This flag is ignored, if the         planar projection is specified.
        smartFit | sf: (create) - Specifies if the projection manipulator has to be placed         fitting the object.  Used for cylindrical and spherical         projections.  For smart fitting the planar projection, the         mapDirection flag has to be used, since there are several         options for smart fitting a planar projection.
        type | t: (create) - Specify the type of mapping to be performed.         Valid values for the STRING are          "planar"          "cylindrical"          "spherical"         Default is planar.
        uvSetName | uvs: (create) - Specifies name of the uv set to work on.
    """
    ...


def polyPyramid(*args, axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createUVs: Optional[Union[int, bool]] = ..., cuv: Optional[Union[int, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., numberOfSides: Optional[Union[int, bool]] = ..., ns: Optional[Union[int, bool]] = ..., numderOfSides: Optional[Union[int, bool]] = ..., nsi: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., sideLength: Optional[Union[float, bool]] = ..., w: Optional[Union[float, bool]] = ..., subdivisionsCaps: Optional[Union[int, bool]] = ..., sc: Optional[Union[int, bool]] = ..., subdivisionsHeight: Optional[Union[int, bool]] = ..., sh: Optional[Union[int, bool]] = ..., texture: bool = ..., tx: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The pyramid command creates a new polygonal pyramid.

    Args:
        axis | ax: (create, edit, query) - This flag specifies the primitive axis used to build the pyramid. Q: When queried, this flag returns a float[3].
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createUVs | cuv: (create, edit, query) - Create UVs or not. 0: No UVs 1: No Normalization 2: Normalize 3: Normalize and Preserve Aspect Ratio Default: 2
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        numberOfSides | ns: (create, edit, query) - Number of sides of Pyramid. Default: 4
        numderOfSides | nsi: (create, edit, query) - Number of sides of Pyramid. Default: 4
        object | o: (create) - Create the result, or just the dependency node (where applicable).
        sideLength | w: (create, edit, query) - Side length of the Pyramid. Default: 1.0
        subdivisionsCaps | sc: (create, edit, query) - Subdivisions on bottom cap Default: 0
        subdivisionsHeight | sh: (create, edit, query) - Subdivisions along the height. Default: 1
        texture | tx: (create, edit, query) - Apply texture or not. Default: true
    """
    ...


def polyQuad(*args, angle: Optional[Union[float, bool]] = ..., a: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., keepGroupBorder: bool = ..., kgb: bool = ..., keepHardEdges: bool = ..., khe: bool = ..., keepTextureBorders: bool = ..., ktb: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Merges selected triangles of a polygonal object into four-sided
    faces.

    Args:
        angle | a: (create, edit, query) - Angle threshold above which two triangles are not merged. C: Default is 30 degrees. The range is [0.0, 180.0]. Q: When queried, this flag returns a float.
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        keepGroupBorder | kgb: (create, edit, query) - Keep facet group border : If "on", the borders of selected faces are maintained, otherwise the borders of selected facets may be modified. C: Default is "on". Q: When queried, this flag returns an int.
        keepHardEdges | khe: (create, edit, query) - Keep hard edges : If "on", the hard edges of selected faces are maintained, otherwise they may be deleted between two triangles. C: Default is "on". Q: When queried, this flag returns an int.
        keepTextureBorders | ktb: (create, edit, query) - Keep texture border : If "on", the borders of texture maps are maintained, otherwise the boreders of texture maps may be modified. C: Default is "on". Q: When queried, this flag returns an int.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyQueryBlindData(*args, associationType: Optional[Union[str, bool]] = ..., at: Optional[Union[str, bool]] = ..., binaryData: Optional[Union[str, bool]] = ..., bnd: Optional[Union[str, bool]] = ..., booleanData: bool = ..., bd: bool = ..., doubleData: Optional[Union[float, bool]] = ..., dbd: Optional[Union[float, bool]] = ..., intData: Optional[Union[int, bool]] = ..., ind: Optional[Union[int, bool]] = ..., longDataName: Optional[Union[str, bool]] = ..., ldn: Optional[Union[str, bool]] = ..., maxValue: Optional[Union[float, bool]] = ..., max: Optional[Union[float, bool]] = ..., minValue: Optional[Union[float, bool]] = ..., min: Optional[Union[float, bool]] = ..., shortDataName: Optional[Union[str, bool]] = ..., sdn: Optional[Union[str, bool]] = ..., showComp: bool = ..., sc: bool = ..., stringData: Optional[Union[str, bool]] = ..., sd: Optional[Union[str, bool]] = ..., subString: Optional[Union[str, bool]] = ..., ss: Optional[Union[str, bool]] = ..., typeId: Optional[Union[int, bool]] = ..., id: Optional[Union[int, bool]] = ...) -> Any:
    r"""
    Command query's blindData associated with particular polygonal components.
    So, the command will require the following to be specified:
            - selection list to query
    Optional are the:
            - typeId
            - associationType
            - longDataName or shortDataName of data being queried.
            - The actual data being specified.
            - showComponent flag
    Note that for object level blind data, the showComponent flag will be ignored.
    If no components are selected, the assocation flag will be ignored and
    object level data will be queried.

    Args:
        associationType | at: (create) - Specifies the dataTypes that are part of BlindData node being queried. Allowable associations are "object" for any object, and "vertex" "edge" and "face" for mesh objects.
        binaryData | bnd: (create) - Specifies the binary string value to search for
        booleanData | bd: (create) - Specifies the string value to search for
        doubleData | dbd: (create) - Specifies the double/float value to search for
        intData | ind: (create) - Specifies the integer value to search for
        longDataName | ldn: (create, multiuse) - Specifies the long name of the data that is being queried by this command.
        maxValue | max: (create) - Specifies the maximum value to search for.  This option will query float, double, and integer types of blind data.
        minValue | min: (create) - Specifies the minimum value to search for.  This option will query float, double and integer types of blind data.
        shortDataName | sdn: (create, multiuse) - Specifies the short name of the data that is being queried by this command.
        showComp | sc: (create) - The showComponent option controls whether the object.[component].attribute name is output preceeding the actual value.  If the showComponent option is used then the restriction of only returning 1 type of blind data (i.e. one of integer, float, double... is removed, as the return for all are strings. If the association is object and not component, then this option will still cause all the attribute names to be printed
        stringData | sd: (create) - Specifies the string value to search for
        subString | ss: (create) - Specifies the substring that should be checked against a STRING type blind data.  If the sub string is found query is successful.  Will not look at non String type blind data elements.
        typeId | id: (create) - Specifies the typeId of the BlindData type being queried.  If the typeId is not specified, then all of the components that match the query will be output.  The typeId of the elements found will be output if the ShowComponents option is used.  Will be in the format "object.component.attribute::typeId". If the typeId is specifed then the "::typeId" portion will not be output with the ShowComponents option.
    """
    ...


def polyReduce(*args, caching: bool = ..., cch: bool = ..., cachingReduce: bool = ..., cr: bool = ..., colorWeights: Optional[Union[float, bool]] = ..., cwt: Optional[Union[float, bool]] = ..., compactness: Optional[Union[float, bool]] = ..., com: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., geomWeights: Optional[Union[float, bool]] = ..., gwt: Optional[Union[float, bool]] = ..., invertVertexWeights: bool = ..., iwt: bool = ..., keepBorder: bool = ..., kb: bool = ..., keepBorderWeight: Optional[Union[float, bool]] = ..., kbw: Optional[Union[float, bool]] = ..., keepColorBorder: bool = ..., kcb: bool = ..., keepColorBorderWeight: Optional[Union[float, bool]] = ..., kcw: Optional[Union[float, bool]] = ..., keepCreaseEdge: bool = ..., kce: bool = ..., keepCreaseEdgeWeight: Optional[Union[float, bool]] = ..., cew: Optional[Union[float, bool]] = ..., keepFaceGroupBorder: bool = ..., kfb: bool = ..., keepFaceGroupBorderWeight: Optional[Union[float, bool]] = ..., kfw: Optional[Union[float, bool]] = ..., keepHardEdge: bool = ..., khe: bool = ..., keepHardEdgeWeight: Optional[Union[float, bool]] = ..., khw: Optional[Union[float, bool]] = ..., keepMapBorder: bool = ..., kmb: bool = ..., keepMapBorderWeight: Optional[Union[float, bool]] = ..., kmw: Optional[Union[float, bool]] = ..., keepOriginalVertices: bool = ..., kev: bool = ..., keepQuadsWeight: Optional[Union[float, bool]] = ..., kqw: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., percentage: Optional[Union[float, bool]] = ..., p: Optional[Union[float, bool]] = ..., preserveLocation: bool = ..., pl: bool = ..., preserveTopology: bool = ..., top: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., sharpness: Optional[Union[float, bool]] = ..., shp: Optional[Union[float, bool]] = ..., symmetryPlaneW: Optional[Union[float, bool]] = ..., sw: Optional[Union[float, bool]] = ..., symmetryPlaneX: Optional[Union[float, bool]] = ..., sx: Optional[Union[float, bool]] = ..., symmetryPlaneY: Optional[Union[float, bool]] = ..., sy: Optional[Union[float, bool]] = ..., symmetryPlaneZ: Optional[Union[float, bool]] = ..., sz: Optional[Union[float, bool]] = ..., symmetryTolerance: Optional[Union[float, bool]] = ..., stl: Optional[Union[float, bool]] = ..., termination: Optional[Union[int, bool]] = ..., trm: Optional[Union[int, bool]] = ..., triangleCount: Optional[Union[int, bool]] = ..., tct: Optional[Union[int, bool]] = ..., triangulate: bool = ..., t: bool = ..., useVirtualSymmetry: Optional[Union[int, bool]] = ..., uvs: Optional[Union[int, bool]] = ..., uvWeights: Optional[Union[float, bool]] = ..., uwt: Optional[Union[float, bool]] = ..., version: Optional[Union[int, bool]] = ..., ver: Optional[Union[int, bool]] = ..., vertexCount: Optional[Union[int, bool]] = ..., vct: Optional[Union[int, bool]] = ..., vertexMapName: Optional[Union[str, bool]] = ..., vmp: Optional[Union[str, bool]] = ..., vertexWeightCoefficient: Optional[Union[float, bool]] = ..., vwc: Optional[Union[float, bool]] = ..., weightCoefficient: Optional[Union[float, bool]] = ..., wc: Optional[Union[float, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Simplify a polygonal object by reducing geometry while preserving the
    overall shape of the mesh.
    
    The algorithm for polyReduce was changed in 2014 to use a new algorithm derived
    from Softimage. However, the command still defaults to using the old algorithm
    for backwards compatibility.  Therefore, we recommend setting the version flag
    to 1 for best results as the new algorithm is better at preserving geometry
    features.  Additionally, some flags only apply to a specific algorithm and
    this is documented for each flag.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        cachingReduce | cr: (create, edit, query) - Cache intermediate reductions for speed at the expense of memory. It is recommended that caching be enabled when using the new algorithm. (-version 1)  However, caching is not recommended when using then old algorithm because it can cause stability issues. C: Default is false. Q: When queried, this flag returns a boolean.
        colorWeights | cwt: (create, edit, query) - This flag only applies when using the old algorithm and is provided for backwards compatibility. How much consideration vertex color is given in the reduction algorithm. A higher weight means the reduction will try harder to preserve vertex coloring. C: Default is 0. Q: When queried, this flag returns a float.
        compactness | com: (create, edit, query) - This flag only applies when using the old algorithm and is provided for backwards compatibility. Tolerance for compactness for the generated triangles A value of 0 will accept all triangles during decimation A value close to 0 will attempt to eliminate triangles that have collinear edges (zero area triangles) A value closer to 1 will attempt to eliminate triangles that are not strictly equilateral (of equal lengths) The closer to 1.0, the more expensive the computation Q: When queried, this flag returns a float.
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        geomWeights | gwt: (create, edit, query) - This flag only applies when using the old algorithm and is provided for backwards compatibility. How much consideration vertex positions are given in the reduction algorithm.  A higher weight means the reduction will try harder to preserve geometry. C: Default is 1. Q: When queried, this flag returns a float.
        invertVertexWeights | iwt: (create, edit, query) - This flag controls how weight map values are interpreted. If true, a vertex weight of 1.0 means a vertex is unlikely to be reduced. If false, a vertex weight of 0.0 means a vertex is unlikely to be reduced. This flag only applies when using the new algorithm. (-version 1) C: Default is true. Q: When queried, this flag returns a boolean.
        keepBorder | kb: (create, edit, query) - If true, reduction will try to retain geometric borders and the border of the selection. C: Default is true. Q: When queried, this flag returns a boolean.
        keepBorderWeight | kbw: (create, edit, query) - If keepBorder is on, this flag specifies the weight to assign to borders.  Setting this value to 0 will disable border preservation and a value of 1 will exactly preserve all border vertices which is useful for matching adjacent meshes.  This flag only applies when using the new algorithm. (-version 1) C: Default is 0.5. Q: When queried, this flag returns a float.
        keepColorBorder | kcb: (create, edit, query) - If true, reduction will try to retain color borders.  These are determined according to color Ids.  This flag only applies when using the new algorithm. (-version 1) C: Default is true. Q: When queried, this flag returns a boolean.
        keepColorBorderWeight | kcw: (create, edit, query) - If keepColorBorder is on, this flag specifies the weight to assign to color borders.  Setting this value to 0 will disable color border preservation and a value of 1 will exactly preserve all color borders.  This flag only applies when using the new algorithm. (-version 1) C: Default is 0.5. Q: When queried, this flag returns a float.
        keepCreaseEdge | kce: (create, edit, query) - If true, reduction will try to retain crease edges. C: Default is true.  This flag only applies when using the new algorithm. (-version 1) C: Default is true. Q: When queried, this flag returns a boolean.
        keepCreaseEdgeWeight | cew: (create, edit, query) - If keepCreaseEdge is on, this flag specifies the weight to assign to crease edges.  Setting this value to 0 will disable crease edge preservation and a value of 1 will exactly preserve all crease edges. This flag only applies when using the new algorithm. (-version 1) C: Default is 0.5. Q: When queried, this flag returns a float.
        keepFaceGroupBorder | kfb: (create, edit, query) - If true, reduction will try to retain borders of face groups, which are mostly used to define material assignments.  This flag only applies when using the new algorithm. (-version 1) C: Default is true. Q: When queried, this flag returns a boolean.
        keepFaceGroupBorderWeight | kfw: (create, edit, query) - If keepFaceGroupBorder is on, this flag specifies the weight to assign to material borders.  Setting this value to 0 will disable group border preservation and a value of 1 will exactly preserve all group borders.  This flag only applies when using the new algorithm. (-version 1) C: Default is 0.5. Q: When queried, this flag returns a float.
        keepHardEdge | khe: (create, edit, query) - If true, reduction will try to retain hard edges. C: Default is true. Q: When queried, this flag returns a boolean.
        keepHardEdgeWeight | khw: (create, edit, query) - If keepHardEdge is on, this flag specifies the weight to assign to hard edges.  Setting this value to 0 will disable hard edge preservation and a value of 1 will exactly preserve all hard edges. This flag only applies when using the new algorithm. (-version 1) C: Default is 0.5. Q: When queried, this flag returns a float.
        keepMapBorder | kmb: (create, edit, query) - If true, reduction will try to retain UV borders.  A UV border is present if the faces on either side of the edge do not share UV Ids. C: Default is true. Q: When queried, this flag returns a boolean.
        keepMapBorderWeight | kmw: (create, edit, query) - If keepMapBorder is on, this flag specifies the weight to assign to UV map borders.  Setting this value to 0 will disable UV map border preservation and a value of 1 will exactly preserve all UV borders. This flag only applies when using the new algorithm. (-version 1) C: Default is 0.5. Q: When queried, this flag returns a float.
        keepOriginalVertices | kev: (create, edit, query) - This flag only applies when using the old algorithm and is provided for backwards compatibility. If true, vertices will try to retain their original positions and will not be repositioned for optimal shape. NOTE: In the newer algorithm vertices always retain their exact original positions. (though the Ids will change) C: Default is false. Q: When queried, this flag returns a boolean.
        keepQuadsWeight | kqw: (create, edit, query) - This flag controls how much consideration is given to oreserving quad faces during reduction.  A higher weight means the reduction will try harder to keep quad faces and avoid creation of triangles. If the version flag is set to 1 (-version 1) and the keepQuadsWeight flag is set to 1.0 then a special quad reduction algorithm is used that does a better job of preserving quads. Howver, this special quad reduction algorithm does not support symmetry so those flags will be ignored when the keepQuadsWeight flag is set to 1.0. C: Default is 0. Q: When queried, this flag returns a float.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        percentage | p: (create, edit, query) - This flag specifies how many vertices to remove during reduction as a percentage of the original mesh.  This flag only applies if the termination flag is set to 0 or when using the old algorithm. C: Default is 0. 100 will remove every possible vertex, 0 will remove none. Q: When queried, this flag returns a float.
        preserveLocation | pl: (create) - This flag guarantees that if the original geometry is preserved, the new geometry will have the same location. C: Default is false.
        preserveTopology | top: (create, edit, query) - this flag guarantees that the topological type will be preserved during reduction.  In particular, if the input is manifold then the output will be manifold.  This option also prevents holes in the mesh from being closed off. This flag only applies when using the new algorithm. (-version 1) C: Default is true. Q: When queried, this flag returns a boolean.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace) (not available in all commands). NOTE: This flag is intended for use by the "Reduce" menu item. If 'polyReduce -rpo 0' is executed from the command line, Shader information will not be copied from the original mesh to the result.
        sharpness | shp: (create, edit, query) - Sharpness controls the balance between preserving small, sharp details versus larger shapes.  At low values, details that are small relative to the general shape of the object are more likely to be collapsed.  At high values, they are more likely to be kept.  This flag only applies when using the new algorithm. (-version 1) C: Default is 0. Q: When queried, this flag returns a float.
        symmetryPlaneW | sw: (create, edit, query) - W value of the symmetry plane.  This flag only applies when using the new algorithm (-version 1) and the useVirtualSymmetry flag is set to 2. C: Default is 0. Q: When queried, this flag returns a float.
        symmetryPlaneX | sx: (create, edit, query) - X value of the symmetry plane.  This flag only applies when using the new algorithm (-version 1) and the useVirtualSymmetry flag is set to 2. C: Default is 0. Q: When queried, this flag returns a float.
        symmetryPlaneY | sy: (create, edit, query) - Y value of the symmetry plane.  This flag only applies when using the new algorithm (-version 1) and the useVirtualSymmetry flag is set to 2. C: Default is 0. Q: When queried, this flag returns a float.
        symmetryPlaneZ | sz: (create, edit, query) - Z value of the symmetry plane.  This flag only applies when using the new algorithm (-version 1) and the useVirtualSymmetry flag is set to 2. C: Default is 0. Q: When queried, this flag returns a float.
        symmetryTolerance | stl: (create, edit, query) - Tolerance to use when applying symmetry. For each vertex of the mesh, we find its exact symmetric point, then we look for the closest vertex to the exact symmetry up to the tolerance distance.  Higher values risk finding more spurious symmetries, lower values might miss symmetries. The value is distance in object space.  This flag only applies when using the new algorithm (-version 1) and the useVirtualSymmetry flag is not set to 0. C: Default is 0. Q: When queried, this flag returns a float.
        termination | trm: (create, edit, query) - This flag specifies the termination condition to use when reducing the mesh.  This flag only applies to the new algorithm. (-version 1) 0 Percentage 1 Vertex count 2 Triangle count C: Default is 0. Q: When queried, this flag returns an integer.
        triangleCount | tct: (create, edit, query) - This flag specifies a target number of triangles to retain after reduction. Note that other factors such as quad and feature preservation may take precendence and cause the actual number of triangles to be different. This flag only applies when using the new algorithm (-version 1) and the termination flag is set to 2. C: Default is 0. Q: When queried, this flag returns an integer.
        triangulate | t: (create, edit, query) - This flag only applies when using the old algorithm and is provided for backwards compatibility. This attribute specifies if the geometry or the selected faces has to be triangulated, before performing reduction. C: Default is true. Q: When queried, this flag returns a boolean.
        useVirtualSymmetry | uvs: (create, edit, query) - This flag controls whether symmetry is preserved during the reduction. This flag only applies when using the new algorithm (-version 1) and the keepQuadsWeight flag is less than 1.0. 0 No symmetry preservation 1 Automatic. Try to find suitable symmetry during reduction. 2 Plane.  Specify a symmetry plane to use during reduction. C: Default is 0. Q: When queried, this flag returns an integer.
        uvWeights | uwt: (create, edit, query) - This flag only applies when using the old algorithm and is provided for backwards compatibility. How much consideration uv positions are given in the reduction algorithm. A higher weight means the reduction will try harder to preserve uv positions. C: Default is 0. Q: When queried, this flag returns a float.
        version | ver: (create, edit, query) - Version of the poly reduce algorithm to use. 0 Old algorithm used in Maya 2013 and prior for backwards compatibility 1 New algorithm derived from Softimage and used in Maya 2014 and later The default is 0 for backwards compatibility but for best results it is recommended that the new algorithm is used as it is better at preserving mesh details. Some flags only apply to a specific algorithm and this is documented for each flag. C: Default is 0 for backwards compatibility. Q: When queried, this flag returns an integer.
        vertexCount | vct: (create, edit, query) - This flag specifies a target number of vertices to retain after reduction. Note that other factors such as quad and feature preservation may take precendence and cause the actual number of vertices to be different. This flag only applies when using the new algorithm (-version 1) and the termination flag is set to 1. C: Default is 0. Q: When queried, this flag returns an integer.
        vertexMapName | vmp: (create, query) - Name of a color set to be added to the output mesh that stores a mapping from vertices in the output mesh to vertices in the input mesh.  The color set is RGB.  The original vertex Id that maps to an output vertex is of a vertex is 65536*r + g where r and g are the red and green channel at a vertex. The blue channel is always zero.  Each vertex in the output mesh has a shared color. This flag only applies when using the new algorithm. (-version 1) Q: When queried, this flag returns a string.
        vertexWeightCoefficient | vwc: (create, edit, query) - This flag specifies a constant value to multiply to each weight map value. A value of zero turns off the weight map.  This flag only applies when using the new algorithm. (-version 1) C: Default is 1. Q: When queried, this flag returns a float.
        weightCoefficient | wc: (create, edit, query) - This flag only applies when using the old algorithm and is provided for backwards compatibility. The weight of each vertex is multiplied with this coefficient when the reduction is performed.  This value does not have to be edited, normally.  It gives finer control over the weighted reduction. This attribute is replaced by vertexWeightCoefficient in the new algorithm when the version flag is set to 1. C: Default is 10000. Q: When queried, this flag returns a float.
    """
    ...


def polyRemesh(*args, caching: bool = ..., cch: bool = ..., collapseThreshold: Optional[Union[float, bool]] = ..., cot: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., interpolationType: Optional[Union[int, bool]] = ..., ipt: Optional[Union[int, bool]] = ..., maxEdgeLength: Optional[Union[float, bool]] = ..., mel: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., smoothStrength: Optional[Union[float, bool]] = ..., smt: Optional[Union[float, bool]] = ..., tessellateBorders: bool = ..., tsb: bool = ..., useRelativeValues: bool = ..., urv: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Triangulates, then remeshes the given mesh through edge splitting and collapsing.
    Edges longer than the specified max edge length are split, and edges shorter
    than the collapse threshold are collapsed.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        collapseThreshold | cot: (create, edit, query) - A percentage of the maxEdgeLength. Edges shorter than this percentage will be reduced to a single vertex.
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        interpolationType | ipt: (create, edit, query) - Algorithm used for interpolating new vertices
        maxEdgeLength | mel: (create, edit, query) - Triangle edges longer than this value will be split into two edges.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        smoothStrength | smt: (create, edit, query) - Amount of smoothing applied to the vertices after remeshing.
        tessellateBorders | tsb: (create, edit, query) - Specifies if the borders of the selected region are allowed to be remeshed.
        useRelativeValues | urv: (create, edit, query) - Specifies if the refine threshold value is relative to the average edge length of the input mesh.
    """
    ...


def polyRetopo(*args, edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Retopologize a polygonial surface.

    Args:
    """
    ...


def polySelect(*args, add: bool = ..., addFirst: bool = ..., af: bool = ..., asSelectString: bool = ..., ass: bool = ..., deselect: bool = ..., d: bool = ..., edgeBorder: Optional[Union[int, bool]] = ..., eb: Optional[Union[int, bool]] = ..., edgeBorderPath: Optional[Union[Tuple[int, int], bool]] = ..., ebp: Optional[Union[Tuple[int, int], bool]] = ..., edgeBorderPattern: Optional[Union[Tuple[int, int], bool]] = ..., bpt: Optional[Union[Tuple[int, int], bool]] = ..., edgeLoop: Optional[Union[int, bool]] = ..., el: Optional[Union[int, bool]] = ..., edgeLoopOrBorder: Optional[Union[int, bool]] = ..., elb: Optional[Union[int, bool]] = ..., edgeLoopOrBorderPattern: Optional[Union[Tuple[int, int], bool]] = ..., lbp: Optional[Union[Tuple[int, int], bool]] = ..., edgeLoopPath: Optional[Union[Tuple[int, int], bool]] = ..., elp: Optional[Union[Tuple[int, int], bool]] = ..., edgeLoopPattern: Optional[Union[Tuple[int, int], bool]] = ..., lpt: Optional[Union[Tuple[int, int], bool]] = ..., edgeRing: Optional[Union[int, bool]] = ..., er: Optional[Union[int, bool]] = ..., edgeRingPath: Optional[Union[Tuple[int, int], bool]] = ..., erp: Optional[Union[Tuple[int, int], bool]] = ..., edgeRingPattern: Optional[Union[Tuple[int, int], bool]] = ..., rpt: Optional[Union[Tuple[int, int], bool]] = ..., edgeUVLoopOrBorder: Optional[Union[int, bool]] = ..., euv: Optional[Union[int, bool]] = ..., everyN: Optional[Union[int, bool]] = ..., en: Optional[Union[int, bool]] = ..., extendToShell: Optional[Union[int, bool]] = ..., ets: Optional[Union[int, bool]] = ..., noSelection: bool = ..., ns: bool = ..., replace: bool = ..., r: bool = ..., shortestEdgePath: Optional[Union[Tuple[int, int], bool]] = ..., sep: Optional[Union[Tuple[int, int], bool]] = ..., shortestEdgePathUV: Optional[Union[Tuple[int, int], bool]] = ..., spu: Optional[Union[Tuple[int, int], bool]] = ..., shortestFacePath: Optional[Union[Tuple[int, int], bool]] = ..., sfp: Optional[Union[Tuple[int, int], bool]] = ..., toggle: bool = ..., tgl: bool = ..., query: bool = ...) -> Any:
    r"""
    This command makes different types of poly component selections.  The return value
    is an integer array containing the id's of the components in the selection in order.
    If a given type of selection loops back on itself then this is indicated by the start id
    appearing twice, once at the start and once at the end.

    Args:
        add | add: (create, query) - Indicates that the specified items should be added to the active list without removing existing items from the active list.
        addFirst | af: (create, query) - Indicates that the specified items should be added to the front of the active list without removing existing items from the active list.
        asSelectString | ass: (create, query) - Changes the return type from an integer array to a string array which can be used as a selection string.
        deselect | d: (create, query) - Indicates that the specified items should be removed from the active list if they are on the active list.
        edgeBorder | eb: (create, multiuse, query) - Select all conected border edges starting at the given edge.       In query mode, this flag needs a value.
        edgeBorderPath | ebp: (create, multiuse, query) - Given two edges on the same border, this will select the edges on the border in the path between them.       In query mode, this flag needs a value.
        edgeBorderPattern | bpt: (create, multiuse, query) - Given two edges on the same border, this will check how many edges there are between the given edges and then continue that pattern of selection around the border.       In query mode, this flag needs a value.
        edgeLoop | el: (create, multiuse, query) - Select an edge loop starting at the given edge.       In query mode, this flag needs a value.
        edgeLoopOrBorder | elb: (create, multiuse, query) - Select an edge loop or all conected border edges, depending on whether the edge is on a border or not, starting at the given edge.       In query mode, this flag needs a value.
        edgeLoopOrBorderPattern | lbp: (create, multiuse, query) - Given two edges either on the same edge loop or on the same edge border, this will check how many edges there are between the given edges and then continue that pattern of selection around the edge loop or edge border.       In query mode, this flag needs a value.
        edgeLoopPath | elp: (create, multiuse, query) - Given two edges that are on the same edge loop, this will select the shortest path between them on the loop.       In query mode, this flag needs a value.
        edgeLoopPattern | lpt: (create, multiuse, query) - Given two edges on the same edge loop, this will check how many edges there are between the given edges and then continue that pattern of selection around the edge loop.       In query mode, this flag needs a value.
        edgeRing | er: (create, multiuse, query) - Select an edge ring starting at the given edge.       In query mode, this flag needs a value.
        edgeRingPath | erp: (create, multiuse, query) - Given two edges that are on the same edge ring, this will select the shortest path between them on the ring.       In query mode, this flag needs a value.
        edgeRingPattern | rpt: (create, multiuse, query) - Given two edges on the same edge ring, this will check how many edges there are between the given edges and then continue that pattern of selection around the edge ring.       In query mode, this flag needs a value.
        edgeUVLoopOrBorder | euv: (create, multiuse, query) - Select an edge loop or border, terminating at UV borders.       In query mode, this flag needs a value.
        everyN | en: (create) - Number of elements to stride over. If less than 1 then use 1, meaning every element. 2 means every second one, etc.
        extendToShell | ets: (create, multiuse, query) - Select the poly shell given a face id.       In query mode, this flag needs a value.
        noSelection | ns: (create, query) - If this flag is used then the selection is not changed at all.
        replace | r: (create, query) - Indicates that the specified items should replace the existing items on the active list.
        shortestEdgePath | sep: (create, multiuse, query) - Given two vertices, this will select the shortest path between them in the 3d object space.       In query mode, this flag needs a value.
        shortestEdgePathUV | spu: (create, multiuse, query) - Given two UVs, this will select the shortest path between them in the 2d texture space.       In query mode, this flag needs a value.
        shortestFacePath | sfp: (create, multiuse, query) - Given two faces, this will select the shortest path between them in the 3d object space.       In query mode, this flag needs a value.
        toggle | tgl: (create, query) - Indicates that those items on the given list which are on the active list should be removed from the active list and those items on the given list which are not on the active list should be added to the active list.
    """
    ...


def polySelectConstraint(*args, angle: Optional[Union[int, bool]] = ..., a: Optional[Union[int, bool]] = ..., anglePropagation: bool = ..., ap: bool = ..., angleTolerance: Optional[Union[float, bool]] = ..., at: Optional[Union[float, bool]] = ..., anglebound: Optional[Union[Tuple[float, float], bool]] = ..., ab: Optional[Union[Tuple[float, float], bool]] = ..., border: bool = ..., bo: bool = ..., borderPropagation: bool = ..., bp: bool = ..., convexity: Optional[Union[int, bool]] = ..., c: Optional[Union[int, bool]] = ..., crease: bool = ..., cr: bool = ..., disable: bool = ..., dis: bool = ..., dist: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., distaxis: Optional[Union[Tuple[float, float, float], bool]] = ..., da: Optional[Union[Tuple[float, float, float], bool]] = ..., distbound: Optional[Union[Tuple[float, float], bool]] = ..., db: Optional[Union[Tuple[float, float], bool]] = ..., distpoint: Optional[Union[Tuple[float, float, float], bool]] = ..., dp: Optional[Union[Tuple[float, float, float], bool]] = ..., edgeDistance: Optional[Union[int, bool]] = ..., ed: Optional[Union[int, bool]] = ..., geometricarea: Optional[Union[int, bool]] = ..., ga: Optional[Union[int, bool]] = ..., geometricareabound: Optional[Union[Tuple[float, float], bool]] = ..., gab: Optional[Union[Tuple[float, float], bool]] = ..., holes: Optional[Union[int, bool]] = ..., h: Optional[Union[int, bool]] = ..., length: Optional[Union[int, bool]] = ..., l: Optional[Union[int, bool]] = ..., lengthbound: Optional[Union[Tuple[float, float], bool]] = ..., lb: Optional[Union[Tuple[float, float], bool]] = ..., loopPropagation: bool = ..., lp: bool = ..., max2dAngle: Optional[Union[float, bool]] = ..., m2a: Optional[Union[float, bool]] = ..., max3dAngle: Optional[Union[float, bool]] = ..., m3a: Optional[Union[float, bool]] = ..., mode: Optional[Union[int, bool]] = ..., m: Optional[Union[int, bool]] = ..., nonmanifold: Optional[Union[int, bool]] = ..., nm: Optional[Union[int, bool]] = ..., oppositeEdges: bool = ..., oe: bool = ..., order: Optional[Union[int, bool]] = ..., orderbound: Optional[Union[Tuple[int, int], bool]] = ..., orb: Optional[Union[Tuple[int, int], bool]] = ..., orient: Optional[Union[int, bool]] = ..., o: Optional[Union[int, bool]] = ..., orientaxis: Optional[Union[Tuple[float, float, float], bool]] = ..., oa: Optional[Union[Tuple[float, float, float], bool]] = ..., orientbound: Optional[Union[Tuple[float, float], bool]] = ..., ob: Optional[Union[Tuple[float, float], bool]] = ..., planarity: Optional[Union[int, bool]] = ..., p: Optional[Union[int, bool]] = ..., propagate: Optional[Union[int, bool]] = ..., pp: Optional[Union[int, bool]] = ..., random: Optional[Union[int, bool]] = ..., r: Optional[Union[int, bool]] = ..., randomratio: Optional[Union[float, bool]] = ..., rr: Optional[Union[float, bool]] = ..., returnSelection: bool = ..., rs: bool = ..., ringPropagation: bool = ..., rp: bool = ..., shell: bool = ..., sh: bool = ..., size: Optional[Union[int, bool]] = ..., sz: Optional[Union[int, bool]] = ..., smoothness: Optional[Union[int, bool]] = ..., sm: Optional[Union[int, bool]] = ..., stateString: bool = ..., sts: bool = ..., textured: Optional[Union[int, bool]] = ..., tx: Optional[Union[int, bool]] = ..., texturedarea: Optional[Union[int, bool]] = ..., ta: Optional[Union[int, bool]] = ..., texturedareabound: Optional[Union[Tuple[float, float], bool]] = ..., tab: Optional[Union[Tuple[float, float], bool]] = ..., textureshared: Optional[Union[int, bool]] = ..., ts: Optional[Union[int, bool]] = ..., topology: Optional[Union[int, bool]] = ..., tp: Optional[Union[int, bool]] = ..., type: Optional[Union[int, bool]] = ..., t: Optional[Union[int, bool]] = ..., uvBorderSelection: bool = ..., ubs: bool = ..., uvConstraint: bool = ..., uvc: bool = ..., uvEdgeLoopPropagation: bool = ..., ulp: bool = ..., uvEdgeRingPropagation: bool = ..., urp: bool = ..., uvFaceOrientation: Optional[Union[int, bool]] = ..., ufo: Optional[Union[int, bool]] = ..., uvShell: bool = ..., uv: bool = ..., visibility: Optional[Union[int, bool]] = ..., v: Optional[Union[int, bool]] = ..., visibilityangle: Optional[Union[float, bool]] = ..., va: Optional[Union[float, bool]] = ..., visibilitypoint: Optional[Union[Tuple[float, float, float], bool]] = ..., vp: Optional[Union[Tuple[float, float, float], bool]] = ..., where: Optional[Union[int, bool]] = ..., w: Optional[Union[int, bool]] = ..., wholeSensitive: bool = ..., ws: bool = ..., query: bool = ...) -> Any:
    r"""
    Changes the global polygonal selection constraints.

    Args:
        angle | a: (create, query) - 0(off) 1(on).
        anglePropagation | ap: (create, query) - If true, selection will be extended to all connected components whose normal is close to any of the normals of the original selection (see angleTolerance)
        angleTolerance | at: (create, query) - When angle propagation is turned on, this controls what is the maximum difference of the normal vectors where the selection propagates.
        anglebound | ab: (create, query) - min and max angles.  The given value should be in the current units that Maya is using.  See the examples for how to check the current unit. For vertices :    angle between the 2 edges owning the vertex. For edges :        angle between the 2 faces owning the edge.
        border | bo: (create, query) - Use "-uvConstraint true" to edit/query UV view constraint. If true, selection will be extended to all connected border components so that the whole "loop" is selected. It also removes all nonborder components from the existing selection (compatibility mode)
        borderPropagation | bp: (create, query) - If true, selection will be extended to all connected border components so that the whole "loop" is selected.
        convexity | c: (create, query) - 0(off) 1(concave) 2(convex).
        crease | cr: (create, query) - If true, selection will be extended to all connected creased components.
        disable | dis: (create) - Toggles off all constraints for all component types, but leaves the other constraint parameters.  This flag may be used together with other ones toggling some constraints on : if so, all constraints are disabled first (no matter the position of the -disable flag in the command line) then the specified ones are activated.
        dist | d: (create, query) - 0(off) 1(to point) 2(to axis) 3(to plane).
        distaxis | da: (create, query) - axis. (Normal to the plane in case of distance to plane).
        distbound | db: (create, query) - min and max distances.
        distpoint | dp: (create, query) - point. (Axis/plane origin in case of distance to axis/plane).
        edgeDistance | ed: (create) - Maximum distance (number of edges) to extend the edge selection for "Contiguous Edges" propagate mode. 0 means to ignore the distance constraint.
        geometricarea | ga: (create, query) - 0(off) 1(on).
        geometricareabound | gab: (create, query) - min and max areas.
        holes | h: (create, query) - 0(off) 1(holed) 2(non holed).
        length | l: (create, query) - 0(off) 1(on).
        lengthbound | lb: (create, query) - min and max lengths.
        loopPropagation | lp: (create, query) - If true, edge selection will be extended to a loop.
        max2dAngle | m2a: (create) - Maximum angle between two consecutive edges in the 2d tangent plane for "Contiguous Edges" propagate mode.
        max3dAngle | m3a: (create) - Maximum angle between two consecutive edges in 3d space for "Contiguous Edges" propagate mode.
        mode | m: (create, query) - 0(Off) 1(Next) 2(Current and Next) 3(All and Next). Off :             no constraints are used at all. Next :             constraints will be used to filter next selections. Current and Next :    constraints will be aplied on current selection and then used to filter next selections. All and Next :        all items satisfying constraints are selected.
        nonmanifold | nm: (create, query) - 0(off) 1(on)
        oppositeEdges | oe: (create) - Use the opposite edges
        order | order: (create, query) - 0(off) 1(on).
        orderbound | orb: (create, query) - min and max orders. number of owning edges.
        orient | o: (create, query) - 0(off) 1(orientation) 2(direction).
        orientaxis | oa: (create, query) - axis.
        orientbound | ob: (create, query) - min and max angles.  The given value should be in the current units that Maya is using.  See the examples for how to check the current unit.
        planarity | p: (create, query) - 0(off) 1(non planar) 2(planar).
        propagate | pp: (create, query) - 0(Off) 1(More) 2(Less) 3(Border) 4(Contiguous Edges) 5(Grow Along Loop) 6(Shrink Along Loop). More :        will add current selection border to current selection. Less :        will remove current selection border from current selection. Border :    will keep only current selection border. Contiguous Edges :    Add edges aligned with the current edges selected. The direction and number of edges selected is controlled by the -m2a, -m3a, and -ed flags. Grow Along Loop:    Will grow current selection along loop, support face, edge, vertex and UV. Shrink Along Loop:    Will shrink current selection along loop, support face, edge, vertex and UV.
        random | r: (create, query) - 0(off) 1(on).
        randomratio | rr: (create, query) - ratio [0,1].
        returnSelection | rs: (create) - If true, current selection will not be modified, instead the new selection will be returned as result.
        ringPropagation | rp: (create, query) - If true, edge selection will be extended to a ring.
        shell | sh: (create, query) - If true, selection will be extended to all connected components so that the whole piece of object is selected.
        size | sz: (create, query) - 0(off) 1(triangles) 2(quads) 3(nsided).
        smoothness | sm: (create, query) - 0(off) 1(hard) 2(smooth).
        stateString | sts: (query) - Query only flag. Returns the MEL command that would restore all the current settings.
        textured | tx: (create, query) - 0(off) 1(mapped) 2(unmapped).
        texturedarea | ta: (create, query) - 0(off) 1(Area specified is unsigned) 2(Area specified is signed).
        texturedareabound | tab: (create, query) - min and max areas.
        textureshared | ts: (create, query) - 0(off) 1(on). This option will select any UVs on the currentMap which are shared by more than one vertex
        topology | tp: (create, query) - 0(off) 1(non triangulatable) 2(lamina) 3(non triangulatable and lamina)
        type | t: (create, query) - 0x0000(none) 0x0001(vertex) 0x8000(edge) 0x0008(face) 0x0010(texture coordinates)
        uvBorderSelection | ubs: (create, query) - This flag only works on UV view If true, selection will be extended to all UV border components It also removes all components not on UV border from the existing selection
        uvConstraint | uvc: (create) - If true, applicable constraint flags will work on UV view.       In query mode, this flag can accept a value.
        uvEdgeLoopPropagation | ulp: (create, query) - Use "-uvConstraint true" to edit/query UV view constraint. If true, UV edge selection will be extended to a loop.
        uvEdgeRingPropagation | urp: (create, query) - This flag only works on UV view If true, UV edge selection will be extended to a ring.
        uvFaceOrientation | ufo: (create, query) - This flag only works on UV view 0(Off) 1(Front Face) 2(Back Face).
        uvShell | uv: (create, query) - If true, selection will be extended to all connected components in UV space
        visibility | v: (create, query) - 0(off) 1(on).
        visibilityangle | va: (create, query) - angle [0,360].
        visibilitypoint | vp: (create, query) - point.
        where | w: (create, query) - 0(off) 1(on border) 2(inside).
        wholeSensitive | ws: (create, query) - Tells how to select faces : either  by picking anywhere inside the face (if true)  or by picking on the face center marker (if false).
    """
    ...


def polySelectConstraintMonitor(*args, changeCommand: Optional[Union[Tuple[str, str], bool]] = ..., cc: Optional[Union[Tuple[str, str], bool]] = ..., create: bool = ..., c: bool = ..., delete: bool = ..., d: bool = ...) -> Any:
    r"""
    Manage the window to display/edit the polygonal selection constraint
    parameters

    Args:
        changeCommand | cc: (create) - Specifies the mel callback to refresh the window. First argument is the callback, second is the window name.
        create | c: (create) - Specifies the Monitor should be created
        delete | d: (create) - Specifies that the Monitor should be removed
    """
    ...


def polySeparate(*args, caching: bool = ..., cch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., removeShells: bool = ..., rs: bool = ..., separateSpecificShell: Optional[Union[int, bool]] = ..., sss: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command creates new objects from the given poly.
    A new object will be created for each section of the mesh
    that is distinct (no edges connect it to the rest of the mesh).
    This command can only separate one object at a time.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        removeShells | rs: (create) - Remove the shells after creation.
        separateSpecificShell | sss: (create, multiuse) - List of shell ids to be separated.
    """
    ...


def polySetToFaceNormal(*args, setUserNormal: bool = ..., su: bool = ...) -> Any:
    r"""
    This command takes selected polygonal vertices or vertex-faces and changes
    their normals. If the option  userNormal  is used, the new normal
    values will be the face normals arround the vertices/vertex-faces. Otherwise
    the new normal values will be default values according to the internal
    calculation.

    Args:
        setUserNormal | su: (create) - when this flag is presented, user normals will be created on each vertex face and the values will be the face normal value. Otherwise the normal values will be the internal computing results. Default is false.
    """
    ...


def polySewEdge(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., texture: bool = ..., tx: bool = ..., tolerance: Optional[Union[float, bool]] = ..., t: Optional[Union[float, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Merge border edges within a given threshold.
    
    Perform pair-wise comparison of selected edges. Pairs whose
    corresponding vertices meet threshold conditions and whose
    orientations are aligned (i.e. their respective normals point
    in the same direction) are merged, as are the vertices (in
    other words, vertices are shared).
    Resulting mesh may have extra vertices or edges to ensure
    geometry is valid.
    Edges must be on the same object to be merged.
    Default : share only vertices lying exactly at the same place.
    (polySewEdge -t 0.0)

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        texture | tx: (create, edit, query) - If true : texture is sewn as well as the 3d edge. C: Default is true. Q: When queried, this flag returns an int.
        tolerance | t: (create, edit, query) - The tolerance to sew edges (edge distance) C: Default is 0.0. Q: When queried, this flag returns a float.
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polySlideEdge(*args, absolute: bool = ..., a: bool = ..., direction: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., edgeDirection: Optional[Union[float, bool]] = ..., ed: Optional[Union[float, bool]] = ..., symmetry: bool = ..., sym: bool = ...) -> Any:
    r"""
    Moves an edge loop selection along the edges connected to the sides of
    its vertices.

    Args:
        absolute | a: (create) - This flag specifies whether or not the command uses absolute mode If in absolute then all vertices will move the same distance (the specified percentage of the smallest edge) C: Default is off
        direction | d: (create) - This flag specifies the direction of the slide edge movement 0: is left direction (relative) 1: is right direction (relative) 2: is normal direction (relative) C: Default is 0
        edgeDirection | ed: (create) - This flag specifies the relative percentage to move along the edges on either side of the vertices along the edge loop C: Default is 0.0
        symmetry | sym: (create) - This flag specifies whether or not the command will do a symmetrical slide. Only takes effect when symmetry is enabled. C: Default is off
    """
    ...


def polySmooth(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., continuity: Optional[Union[float, bool]] = ..., c: Optional[Union[float, bool]] = ..., degree: Optional[Union[int, bool]] = ..., deg: Optional[Union[int, bool]] = ..., divisions: Optional[Union[int, bool]] = ..., dv: Optional[Union[int, bool]] = ..., divisionsPerEdge: Optional[Union[int, bool]] = ..., dpe: Optional[Union[int, bool]] = ..., keepBorder: bool = ..., kb: bool = ..., keepHardEdge: bool = ..., khe: bool = ..., keepMapBorders: Optional[Union[int, bool]] = ..., kmb: Optional[Union[int, bool]] = ..., keepSelectionBorder: bool = ..., ksb: bool = ..., keepTesselation: bool = ..., xkt: bool = ..., keepTessellation: bool = ..., kt: bool = ..., method: Optional[Union[int, bool]] = ..., mth: Optional[Union[int, bool]] = ..., osdCreaseMethod: Optional[Union[int, bool]] = ..., ocr: Optional[Union[int, bool]] = ..., osdFvarBoundary: Optional[Union[int, bool]] = ..., ofb: Optional[Union[int, bool]] = ..., osdFvarPropagateCorners: bool = ..., ofc: bool = ..., osdSmoothTriangles: bool = ..., ost: bool = ..., osdVertBoundary: Optional[Union[int, bool]] = ..., ovb: Optional[Union[int, bool]] = ..., propagateEdgeHardness: bool = ..., peh: bool = ..., pushStrength: Optional[Union[float, bool]] = ..., ps: Optional[Union[float, bool]] = ..., roundness: Optional[Union[float, bool]] = ..., ro: Optional[Union[float, bool]] = ..., smoothUVs: bool = ..., suv: bool = ..., subdivisionLevels: Optional[Union[int, bool]] = ..., sl: Optional[Union[int, bool]] = ..., subdivisionType: Optional[Union[int, bool]] = ..., sdt: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Smooth a polygonal object. This command works on polygonal objects
    or faces.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        continuity | c: (create, edit, query) - This flag specifies the smoothness parameter. The minimum value of 0.0 specifies that the faces should only be subdivided. Maximum value of 1.0 smooths the faces as much as possible. C: Default is 1.0 Q: When queried, this flag returns a float.
        degree | deg: (create) - Degree of the resulting limit surface
        divisions | dv: (create, edit, query) - This flag specifies the number of recursive smoothing steps. C: Default is 1. Q: When queried, this flag returns an int.
        divisionsPerEdge | dpe: (create) - Number of subdivisions along one edge for each step.
        keepBorder | kb: (create, edit, query) - If on, the border of the object will not move during smoothing operation. C: Default is "on". Q: When queried, this flag returns an int.
        keepHardEdge | khe: (create, edit, query) - If true, vertices on hard edges will not be modified. C: Default is false. Q: When queried, this flag returns a boolean.
        keepMapBorders | kmb: (create) - Treatment of UV map borders 0 - all map border edges will be smoothed 1 - map borders that are also geometry borders will be smoothed 2 - no map borders will be smoothed
        keepSelectionBorder | ksb: (create, edit, query) - If true, vertices on border of the selection will not be modified. C: Default is false. Q: When queried, this flag returns a boolean.
        keepTesselation | xkt: (create) - If true: the object will be smoothed consistently from frame to frame. This is best when the object is being deformed or animated . If false: non-starlike faces will be triangulated before being smoothed.  This avoids self-overlapping faces, but could lead to a change in topology (number of vertices/faces) from frame to frame, during an animated deformation.
        keepTessellation | kt: (create) - If true: the object will be smoothed consistently from frame to frame. This is best when the object is being deformed or animated . If false: non-starlike faces will be triangulated before being smoothed.  This avoids self-overlapping faces, but could lead to a change in topology (number of vertices/faces) from frame to frame, during an animated deformation.
        method | mth: (create) - Type of smoothing algorithm to use 0 - exponential - traditional smoothing 1 - linear - number of faces per edge grows linearly
        osdCreaseMethod | ocr: (create, edit, query) - Controls how boundary edges and vertices are interpolated.
        osdFvarBoundary | ofb: (create, edit, query) - Controls how boundaries are treated for face-varying data (UVs and Vertex Colors).
        osdFvarPropagateCorners | ofc: (create, edit, query) - 
        osdSmoothTriangles | ost: (create, edit, query) - Apply a special subdivision rule be applied to all triangular faces that was empirically determined to make triangles subdivide more smoothly.
        osdVertBoundary | ovb: (create, edit, query) - Controls how boundary edges and vertices are interpolated.
        propagateEdgeHardness | peh: (create, edit, query) - If true, edges which are a result of smoothed edges will be given the same value for their edge hardness.  New subdivided edges will always be smooth. C: Default is false. Q: When queried, this flag returns a boolean.
        pushStrength | ps: (create) - COMMENT 0.0 is approximation, 1.0 is interpolation scheme
        roundness | ro: (create) - When 1.0, push vectors are renormalized to keep length constant
        smoothUVs | suv: (create) - If true: UVs as well as geometry will be smoothed
        subdivisionLevels | sl: (create) - Number of times the subdivide and smooth operation is run.
        subdivisionType | sdt: (create, edit, query) - The subdivision method used for smoothing. C: Default is 0. 0: Maya Catmull-Clark 1: OpenSubdiv Catmull-Clark
    """
    ...


def polySoftEdge(*args, angle: Optional[Union[float, bool]] = ..., a: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Selectively makes edges soft or hard.
    
    An edge will be made hard if the angle between two owning
    faces is sharper (larger) than the smoothing angle.
    An edge wil be made soft if the angle between two owning
    facets is flatter (smaller) than the smoothing angle.

    Args:
        angle | a: (create, edit, query) - Smoothing angle. C: Default is 30 degrees. Q: When queried, this flag returns a float.
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polySphere(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., createUVs: Optional[Union[int, bool]] = ..., cuv: Optional[Union[int, bool]] = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., subdivisionsAxis: Optional[Union[int, bool]] = ..., sa: Optional[Union[int, bool]] = ..., subdivisionsHeight: Optional[Union[int, bool]] = ..., sh: Optional[Union[int, bool]] = ..., subdivisionsX: Optional[Union[int, bool]] = ..., sx: Optional[Union[int, bool]] = ..., subdivisionsY: Optional[Union[int, bool]] = ..., sy: Optional[Union[int, bool]] = ..., texture: Optional[Union[int, bool]] = ..., tx: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The sphere command creates a new polygonal sphere.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        object | o: (create) - Create the result, or just the dependency node (where applicable).
        axis | ax: (create, edit, query) - This flag specifies the primitive axis used to build the sphere. Q: When queried, this flag returns a float[3].
        createUVs | cuv: (create) - This flag alows a specific UV mechanism to be selected, while creating the sphere. The valid values are 0, 1, or 2. 0 implies that no UVs will be generated (No texture to be applied).  1 implies UVs are created with pinched at poles  2 implies UVs are created with sawtooth at poles    For better understanding of these options, you may have to open the      texture view window  C: Default is 2
        radius | r: (create, edit, query) - This flag specifies the radius of the sphere. C: Default is 0.5. Q: When queried, this flag returns a float.
        subdivisionsAxis | sa: (create, edit, query) - Subdivisions around the axis.
        subdivisionsHeight | sh: (create, edit, query) - Subdivisions along the height of the sphere.
        subdivisionsX | sx: (create, edit, query) - This specifies the number of subdivisions in the X direction for the sphere. C: Default is 20. Q: When queried, this flag returns an int.
        subdivisionsY | sy: (create, edit, query) - This flag specifies the number of subdivisions in the Y direction for the sphere. C: Default is 20. Q: When queried, this flag returns an int.
        texture | tx: (create) - This flag is obsolete and will be removed in the next release. The -cuv/createUVs flag should be used instead.
    """
    ...


def polySphericalProjection(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createNewMap: bool = ..., cm: bool = ..., insertBeforeDeformers: bool = ..., ibd: bool = ..., keepImageRatio: bool = ..., kir: bool = ..., mapDirection: Optional[Union[str, bool]] = ..., md: Optional[Union[str, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., perInstance: bool = ..., pi: bool = ..., smartFit: bool = ..., sf: bool = ..., worldSpace: bool = ..., ws: bool = ..., imageCenter: Optional[Union[Tuple[float, float], bool]] = ..., ic: Optional[Union[Tuple[float, float], bool]] = ..., imageCenterX: Optional[Union[float, bool]] = ..., icx: Optional[Union[float, bool]] = ..., imageCenterY: Optional[Union[float, bool]] = ..., icy: Optional[Union[float, bool]] = ..., imageScale: Optional[Union[Tuple[float, float], bool]] = ..., imageScaleU: Optional[Union[float, bool]] = ..., isu: Optional[Union[float, bool]] = ..., imageScaleV: Optional[Union[float, bool]] = ..., isv: Optional[Union[float, bool]] = ..., projectionCenter: Optional[Union[Tuple[float, float, float], bool]] = ..., pc: Optional[Union[Tuple[float, float, float], bool]] = ..., projectionCenterX: Optional[Union[float, bool]] = ..., pcx: Optional[Union[float, bool]] = ..., projectionCenterY: Optional[Union[float, bool]] = ..., pcy: Optional[Union[float, bool]] = ..., projectionCenterZ: Optional[Union[float, bool]] = ..., pcz: Optional[Union[float, bool]] = ..., projectionHorizontalSweep: Optional[Union[float, bool]] = ..., phs: Optional[Union[float, bool]] = ..., projectionScale: Optional[Union[Tuple[float, float], bool]] = ..., ps: Optional[Union[Tuple[float, float], bool]] = ..., projectionScaleU: Optional[Union[float, bool]] = ..., psu: Optional[Union[float, bool]] = ..., projectionScaleV: Optional[Union[float, bool]] = ..., psv: Optional[Union[float, bool]] = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., rotate: Optional[Union[Tuple[float, float, float], bool]] = ..., ro: Optional[Union[Tuple[float, float, float], bool]] = ..., rotateX: Optional[Union[float, bool]] = ..., rx: Optional[Union[float, bool]] = ..., rotateY: Optional[Union[float, bool]] = ..., ry: Optional[Union[float, bool]] = ..., rotateZ: Optional[Union[float, bool]] = ..., rz: Optional[Union[float, bool]] = ..., rotationAngle: Optional[Union[float, bool]] = ..., ra: Optional[Union[float, bool]] = ..., seamCorrect: bool = ..., sc: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    TpolyProjCmdBase is a base class for the command to create a mapping on the selected polygonal faces.
    Projects a spherical map onto an object.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createNewMap | cm: (create, query) - This flag when set true will create a new map with a the name passed in, if the map does not already exist.
        insertBeforeDeformers | ibd: (create) - This flag specifies if the projection node should be inserted before or after deformer nodes already applied to the shape. Inserting the projection after the deformer leads to texture swimming during animation and is most often undesirable. C: Default is on.
        keepImageRatio | kir: (create) - True means keep any image ratio
        mapDirection | md: (create) - This flag specifies the mapping direction. 'x', 'y' and 'z' projects the map along the corresponding axis. 'c' projects along the current camera viewing direction. 'p' does perspective projection if current camera is perspective. 'b' projects along the best plane fitting the objects selected.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        perInstance | pi: (create) - True if the new map is per-instance, otherwise it is shared.
        smartFit | sf: (create) - True means use the smart fit algorithm
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
        imageCenter | ic: (create, edit, query) - This flag specifies the center point of the 2D model layout. C: Default is 0.5 0.5. Q: When queried, this flag returns a float[2].
        imageCenterX | icx: (create, edit, query) - This flag specifies X for the center point of the 2D model layout. C: Default is 0.5. Q: When queried, this flag returns a float.
        imageCenterY | icy: (create, edit, query) - This flag specifies Y for the center point of the 2D model layout. C: Default is 0.5. Q: When queried, this flag returns a float.
        imageScale | imageScale: (create, edit, query) - This flag specifies the UV scale : Enlarges or reduces the 2D version of the model in U or V space relative to the 2D centerpoint. C: Default is 1.0 1.0. Q: When queried, this flag returns a float[2].
        imageScaleU | isu: (create, edit, query) - This flag specifies the U scale : Enlarges or reduces the 2D version of the model in U space relative to the 2D centerpoint. C: Default is 1.0. Q: When queried, this flag returns a float.
        imageScaleV | isv: (create, edit, query) - This flag specifies the V scale : Enlarges or reduces the 2D version of the model in V space relative to the 2D centerpoint. C: Default is 1.0. Q: When queried, this flag returns a float.
        projectionCenter | pc: (create, edit, query) - This flag specifies the origin point from which the map is projected. C: Default is 0.0 0.0 0.0. Q: When queried, this flag returns a float[3].
        projectionCenterX | pcx: (create, edit, query) - This flag specifies X for the origin point from which the map is projected. C: Default is 0.0. Q: When queried, this flag returns a float.
        projectionCenterY | pcy: (create, edit, query) - This flag specifies Y for the origin point from which the map is projected. C: Default is 0.0. Q: When queried, this flag returns a float.
        projectionCenterZ | pcz: (create, edit, query) - This flag specifies Z for the origin point from which the map is projected. C: Default is 0.0. Q: When queried, this flag returns a float.
        projectionHorizontalSweep | phs: (create, edit, query) - The angle swept horizontally by the projection.  The range is [0, 360].
        projectionScale | ps: (create, edit, query) - This flag specifies the width and the height of the map relative to the 3D projection axis. C: Default is 180.0 90.0. Q: When queried, this flag returns a float[2].
        projectionScaleU | psu: (create, edit, query) - This flag specifies the width of the map relative to the 3D projection axis : the scale aperture. The range is [0, 360]. C: Default is 180.0. Q: When queried, this flag returns a float.
        projectionScaleV | psv: (create, edit, query) - This flag specifies the height of the map relative to the 3D projection axis : the scale height. C: Default is 90.0. Q: When queried, this flag returns a float.
        radius | r: (create, edit, query) - Used by the UI : Manipulator.
        rotate | ro: (create, edit, query) - This flag specifies the mapping rotate angles. C: Default is 0.0 0.0 0.0. Q: When queried, this flag returns a float[3].
        rotateX | rx: (create, edit, query) - This flag specifies X mapping rotate angle. C: Default is 0.0. Q: When queried, this flag returns a float[3].
        rotateY | ry: (create, edit, query) - This flag specifies Y mapping rotate angle. C: Default is 0.0. Q: When queried, this flag returns a float.
        rotateZ | rz: (create, edit, query) - This flag specifies Z mapping rotate angle. C: Default is 0.0. Q: When queried, this flag returns a float.
        rotationAngle | ra: (create, edit, query) - This flag specifies the rotation angle in the mapping space. When the angle is positive, then the map rotates counterclockwise on the mapped model, whereas when it is negative then the map rotates clockwise on the mapped model. C: Default is 10.0. Q: When queried, this flag returns a float.
        seamCorrect | sc: (create, edit, query) - This flag specifies to perform a seam correction on the mapped faces.
    """
    ...


def polySplit(*args, constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., adjustEdgeFlow: Optional[Union[float, bool]] = ..., aef: Optional[Union[float, bool]] = ..., detachEdges: bool = ..., de: bool = ..., edgepoint: Optional[Union[Tuple[int, float], bool]] = ..., ep: Optional[Union[Tuple[int, float], bool]] = ..., facepoint: Optional[Union[Tuple[int, float, float, float], bool]] = ..., fp: Optional[Union[Tuple[int, float, float, float], bool]] = ..., insertWithEdgeFlow: bool = ..., ief: bool = ..., insertpoint: Optional[Union[Tuple[int, float, List[float]], bool]] = ..., ip: Optional[Union[Tuple[int, float, List[float]], bool]] = ..., projectedCurve: Optional[Union[str, bool]] = ..., pc: Optional[Union[str, bool]] = ..., projectedCurveTolerance: Optional[Union[float, bool]] = ..., pct: Optional[Union[float, bool]] = ..., smoothingangle: Optional[Union[float, bool]] = ..., sma: Optional[Union[float, bool]] = ..., subdivision: Optional[Union[int, bool]] = ..., s: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Split facets/edges of a polygonal object.
    
    The first and last arguments must be edges. Intermediate points
    may lie on either a shared face or an edge which neighbors the previous point.

    Args:
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        adjustEdgeFlow | aef: (create, edit, query) - The weight value of the edge vertices to be positioned.
        detachEdges | de: (create) - Value of the detachEdges attribute for the resulting poly split node.
        edgepoint | ep: (create, multiuse) - The given edge is split into two new edges by inserting a new vertex located the given percentage along the edge.  Note: This flag is not recommended for use from Python.  See the insertpoint flag instead.
        facepoint | fp: (create, multiuse) - A new vertex is inserted, lying at the given coordinates inside the given face. Coordinates are given in the local object space.  Note: This flag is not recommended for use from Python.  See the insertpoint flag instead.
        insertWithEdgeFlow | ief: (create, edit, query) - True to enable edge flow. Otherwise, the edge flow is disabled.
        insertpoint | ip: (create, multiuse) - This flag allows the caller to insert a new vertex into an edge or a face.  To insert a new vertex in an edge, pass the index of the edge and a percentage along the edge at which to insert the new vertex.  When used to insert a vertex into an edge, this flag takes two arguments.  To insert a new vertex into a face, pass the index of the face and three values which define the coordinates for the insertion in local object space.  When used to insert a vertex into a face, this flag takes four arguments.  This flag replaces the edgepoint and facepoint flags.
        projectedCurve | pc: (create, multiuse) - Curves to be projected.
        projectedCurveTolerance | pct: (create) - Tolerance for curve projection.
        smoothingangle | sma: (create) - Subdivide new edges will be soft if less then this angle. C: Default is 0.0
        subdivision | s: (create, edit, query) - Subdivide new edges into the given number of sections. Edges involving free points won't be subdivided. C: Default is 1 (no subdivision). Q: When queried, this flag returns an int.
    """
    ...


def polySplitEdge(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., operation: Optional[Union[int, bool]] = ..., op: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Split Edges.
    
    There are two operations for this command depending on the value of the
    -operation flag.
    
    If -operation is set to 1 then this command will split apart faces along all
    selected manifold edges.
    
    If -operation is set to 0 then this command will split non-manifold edges
    so as to make them manifold edges. It creates the minimum number of edges
    that can be created to make the edge manifold.
    
    The default value for -operation is 1, operate on manifold edges.
    
    Resulting mesh may have extra vertices or edges to ensure
    geometry is valid.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        operation | op: (create, edit, query) - 0 means use a Non-Manifold method, 1 means use a Manifold method
    """
    ...


def polySplitRing(*args, adjustEdgeFlow: Optional[Union[float, bool]] = ..., aef: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., direction: bool = ..., dr: bool = ..., divisions: Optional[Union[int, bool]] = ..., div: Optional[Union[int, bool]] = ..., enableProfileCurve: bool = ..., epc: bool = ..., fixQuads: bool = ..., fq: bool = ..., insertWithEdgeFlow: bool = ..., ief: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., profileCurveInputOffset: Optional[Union[float, bool]] = ..., pio: Optional[Union[float, bool]] = ..., profileCurveInputScale: Optional[Union[float, bool]] = ..., pis: Optional[Union[float, bool]] = ..., profileCurve_FloatValue: Optional[Union[float, bool]] = ..., pfv: Optional[Union[float, bool]] = ..., profileCurve_Interp: Optional[Union[int, bool]] = ..., pi: Optional[Union[int, bool]] = ..., profileCurve_Position: Optional[Union[float, bool]] = ..., pp: Optional[Union[float, bool]] = ..., rootEdge: Optional[Union[int, bool]] = ..., re: Optional[Union[int, bool]] = ..., smoothingAngle: Optional[Union[float, bool]] = ..., sma: Optional[Union[float, bool]] = ..., splitType: Optional[Union[int, bool]] = ..., stp: Optional[Union[int, bool]] = ..., useEqualMultiplier: bool = ..., uem: bool = ..., useFaceNormalsAtEnds: bool = ..., fne: bool = ..., weight: Optional[Union[float, bool]] = ..., wt: Optional[Union[float, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Splits a series of ring edges of connected quads and
    inserts connecting edges between them.

    Args:
        adjustEdgeFlow | aef: (create, edit, query) - The weight value of the edge vertices to be positioned. Default: 1.0f
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        direction | dr: (create, edit, query) - This attribute is used when doing an absolute split.  If true then the distance is taken from the start vertex of the root edge.  If false the distance is taken from the end vertext of the root edge. Default: true
        divisions | div: (create, edit, query) - Number of divisions. Default: 2
        enableProfileCurve | epc: (create, edit, query) - Enables the use of the profile curve. Default: true
        fixQuads | fq: (create, edit, query) - Fixes splits which go across a quad face leaving a 5 and 3 sided faces by splitting from the middle of the new edge to the vertex accross from the edge on the 5 sided face. Default: false
        insertWithEdgeFlow | ief: (create, edit, query) - True to enable edge flow. Otherwise, the edge flow is disabled. Default: false
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        profileCurveInputOffset | pio: (create, edit, query) - Changes the offset to the multisplit profile curve. eg. if the profile curve values go between 0 and 1 and this value is set to -1 then the profile curves values will be adjusted to go between -1 and 0. Default: 0.0f
        profileCurveInputScale | pis: (create, edit, query) - Changes the range of values that the profile curve represents. eg. if the profile curve values go between 0 and 1 and this value is set to 2 then the profile curves values will be adjusted to go between 0 and 2. Default: 1.0f
        profileCurve_FloatValue | pfv: (create, edit, query) - ?????
        profileCurve_Interp | pi: (create, edit, query) - ????? Default: 0
        profileCurve_Position | pp: (create, edit, query) - ?????
        rootEdge | re: (create, edit, query) - The weight attribute uses the start vertex of this edge to determine where the new split occurs. Default: -1
        smoothingAngle | sma: (create, edit, query) - Angle below which new edges will be smoothed Default: kPi
        splitType | stp: (create, edit, query) - Format: 0 - Absolute, 1 - Relative, 2 - Multi Default: TdnpolySplitRing::Relative
        useEqualMultiplier | uem: (create, edit, query) - Changes how the profile curve effects the offset when doing a multisplit.  If true then the verts will be offset the same distance based on the shortest edge being split.  If false then each inserted edge loop will be offset a distance relative to the length of the edge that is being split. Default: true
        useFaceNormalsAtEnds | fne: (create, edit, query) - When doing a multisplit on a set of non-closed edge ring this will toggle the normals at the ends of the split to be calculated as the edge normal or the face normal. Default: true
        weight | wt: (create, edit, query) - Weight value controlling the relative positioning of the new points on existing edges. Range is [0.0, 1.0]. Value of 0.1 indicates the new edges will be placed closer to the start vertex of the first edge of the sequence of edges. Default: 0.5
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polySplitVertex(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Use this command to split one or more vertices.  A mesh is made up
    of one or more faces.  The faces are defined by edges which connect vertices
    together.  Typically a face will share vertices and edges with adjacent
    faces in the same mesh.  Sharing vertices and edges helps reduce the amount
    of memory used by a mesh.  It also ensures that when a face is moved, all
    the connected faces move together.
    Sometimes you may want to separate a face from its connected faces so that
    it may be moved in isolation.  There are three ways to accomplish this depending
    upon which parts of the face you want to extract:
    
    
    polySplitVertex split one or more vertices so that each face that
    shared the vertex acquires its own copy of the vertex
    
    
    polySplitEdge split one or more edges so that each face that shared
    the vertex acquires its own copy of the edge
    
    
    polyChipOff completely extract the face so that it has its own vertices
    and edges
    
    
    
    Notice that the area of affect of each operation is different.  polySplitVertex
    will affect all the edges and faces that shared the vertex.  This is the broadest
    effect.  polySplitEdge will only affect the faces which shared the edge and polyChipOff
    will affect a specific face.  If we just count vertices to measure the effect of each
    command when splitting all components of a face, starting from a 3x3 plane which has 16
    vertices and we were to split the middle face:
    
    
    polySplitVertex applied to the four vertices would end up creating 12 new vertices
    
    
    polySplitEdge applied to the four edges would end up creating 4 new vertices
    
    
    polyChipOff applied to the middle face would end up creating 4 new vertices
    
    
    
    Note that polySplitVertex may create non-manifold geometry as a part of this operation.
    You can use Polygons->Cleanup afterwards to to clean up any non-manifold geometry.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polyStraightenUVBorder(*args, blendOriginal: Optional[Union[float, bool]] = ..., bo: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., curvature: Optional[Union[float, bool]] = ..., c: Optional[Union[float, bool]] = ..., gapTolerance: Optional[Union[int, bool]] = ..., gt: Optional[Union[int, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., preserveLength: Optional[Union[float, bool]] = ..., pl: Optional[Union[float, bool]] = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Move border UVs along a simple curve.

    Args:
        blendOriginal | bo: (create, query) - Interpolation factor between the target and original UV shape. When the value is 0, the UVs will exactly fit the target curve. When the value is 1, no UV move.
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        curvature | c: (create, query) - How curved the UV path will be. 0 is a straight line. When the values is 1, the mid point of the curve will be moved away from a straight line by 1/2 the length of the UV segment.
        gapTolerance | gt: (create, query) - When non 0, Small gaps between UV selection are filled. The integer number represent how many UVs must be traversed to connect togeterh selected pieces.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        preserveLength | pl: (create, query) - How much we want to respect the UV edge ratios. When the value is 1, we build new UV position along the desired curve, respecting the original UV spacings. When the value is 0, new UVs are equally spaced along the curve.
        uvSetName | uvs: (create) - Name of the UV set to be created
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polySubdivideEdge(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., divisions: Optional[Union[int, bool]] = ..., dv: Optional[Union[int, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., size: Optional[Union[float, bool]] = ..., s: Optional[Union[float, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Subdivides an edge into two or more subedges.
    
    Default : divide edge into two edges of equal length.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        divisions | dv: (create, edit, query) - The maximum number of vertices to be inserted in each edge. This number may be reduced if it creates edges shorter than the specified minimum length. C: Default is 1 (divide edges in half). Q: When queried, this flag returns an int.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        size | s: (create, edit, query) - The minimum length of each subedge created. If the given subdivision creates edges that are shorter than this length, the number of divisions is changed to respect min length. C: Default is 0.0. Q: When queried, this flag returns a float.
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def polySubdivideFacet(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., divisions: Optional[Union[int, bool]] = ..., dv: Optional[Union[int, bool]] = ..., divisionsU: Optional[Union[int, bool]] = ..., duv: Optional[Union[int, bool]] = ..., divisionsV: Optional[Union[int, bool]] = ..., dvv: Optional[Union[int, bool]] = ..., mode: Optional[Union[int, bool]] = ..., m: Optional[Union[int, bool]] = ..., subdMethod: Optional[Union[int, bool]] = ..., sbm: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Subdivides a face into quads or triangles.
    
    In quad mode, a center point is introduced at the center of each face
    and midpoints are inserted on all the edges of each face. New faces (all
    quadrilaterals) are built by adding edges from the midpoints towards the center.
    In triangle mode, only the center point is created; new faces (all
    triangles) are created by connecting the center point to all the existing
    vertices of the face.
    Default : one subdivision step in quad mode (polySubdFacet -dv 1 -m 0;)

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        divisions | dv: (create, edit, query) - This number specifies how many times to recursively subdivide the selected faces. For example, with divisions set to 3 in quad mode, each initial quadrilateral will be recursively subdivided into 4 subfaces 3 times, yielding a total of 4 * 4 * 4 = 64 faces. C: Default is 1. Q: When queried, this flag returns an int.
        divisionsU | duv: (create, edit, query) - The number of subdivision steps to perform along the U direction. A square face will be subdivided into 4^(divisions) faces in quad mode, 4*3^(divisions-1) in triangle mode.
        divisionsV | dvv: (create, edit, query) - The number of subdivision steps to perform along the V direction. A square face will be subdivided into 4^(divisions) faces in quad mode, 4*3^(divisions-1) in triangle mode.
        mode | m: (create, edit, query) - The subdivision mode.  0: subdivision into quads  1: subdivision into triangles C: Default is 0. Q: When queried, this flag returns an int.
        subdMethod | sbm: (create, edit, query) - Type of subdivision to use: 0 - exponential - traditional subdivision 1 - linear - number of faces per edge grows linearly
    """
    ...


def polyTorus(*args, axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., createUVs: bool = ..., cuv: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., sectionRadius: Optional[Union[float, bool]] = ..., sr: Optional[Union[float, bool]] = ..., subdivisionsAxis: Optional[Union[int, bool]] = ..., sa: Optional[Union[int, bool]] = ..., subdivisionsHeight: Optional[Union[int, bool]] = ..., sh: Optional[Union[int, bool]] = ..., subdivisionsX: Optional[Union[int, bool]] = ..., sx: Optional[Union[int, bool]] = ..., subdivisionsY: Optional[Union[int, bool]] = ..., sy: Optional[Union[int, bool]] = ..., texture: bool = ..., tx: bool = ..., twist: Optional[Union[float, bool]] = ..., tw: Optional[Union[float, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The torus command creates a new polygonal torus.

    Args:
        axis | ax: (create, edit, query) - This flag specifies the primitive axis used to build the torus. Q: When queried, this flag returns a vector.
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        createUVs | cuv: (create, edit, query) - Create UVs or not. Default: true
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        object | o: (create) - Create the result, or just the dependency node (where applicable).
        radius | r: (create, edit, query) - Radius of the torus. Default: 1.0
        sectionRadius | sr: (create, edit, query) - Section of the torus. Default: 0.50
        subdivisionsAxis | sa: (create, edit, query) - Subdivisions about the vertical axis. Default: 20
        subdivisionsHeight | sh: (create, edit, query) - Subdivisions along the height. Default: 20
        subdivisionsX | sx: (create, edit, query) - This specifies the number of subdivisions in the X direction for the torus (number of sections). C: Default is 20. Q: When queried, this flag returns an int.
        subdivisionsY | sy: (create, edit, query) - This flag specifies the number of subdivisions in the Y direction for the torus (number of segments per section). C: Default is 20. Q: When queried, this flag returns an int.
        texture | tx: (create, edit, query) - Apply texture or not. this is an old attribute. This is unsupported and would be removed in a future release. Default: true
        twist | tw: (create, edit, query) - Twist angle of the torus. Default: 0.0
    """
    ...


def polyToSubdiv(*args, absolutePosition: bool = ..., ap: bool = ..., applyMatrixToResult: bool = ..., amr: bool = ..., caching: bool = ..., cch: bool = ..., maxEdgesPerVert: Optional[Union[int, bool]] = ..., me: Optional[Union[int, bool]] = ..., maxPolyCount: Optional[Union[int, bool]] = ..., mpc: Optional[Union[int, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., preserveVertexOrdering: bool = ..., pvo: bool = ..., quickConvert: bool = ..., qc: bool = ..., uvPoints: Optional[Union[Tuple[float, float], bool]] = ..., uvp: Optional[Union[Tuple[float, float], bool]] = ..., uvPointsU: Optional[Union[float, bool]] = ..., uvu: Optional[Union[float, bool]] = ..., uvPointsV: Optional[Union[float, bool]] = ..., uvv: Optional[Union[float, bool]] = ..., uvTreatment: Optional[Union[int, bool]] = ..., uvt: Optional[Union[int, bool]] = ..., addUnderTransform: bool = ..., aut: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command converts a polygon and produces a subd surface.
    The name of the new subdivision surface is returned.
    If construction history is ON, then the name of the new dependency
    node is returned as well.

    Args:
        absolutePosition | ap: (create, edit, query) - If true, the possible blind data information that comes from the polygon will be treated as absolute positions of the vertices, instead of the relative offsets.  You most likelly just want to use the default of false, unless you know that the blind data has the absolute positions in it. Default: false
        applyMatrixToResult | amr: (create, edit, query) - If true, the matrix on the input geometry is applied to the object and the resulting geometry will have identity matrix on it.  If false the conversion is done on the local space object and the resulting geometry has the input object's matrix on it. Default: true
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        maxEdgesPerVert | me: (create, edit, query) - The maximum allowed valence for a vertex on the input mesh Default: 32
        maxPolyCount | mpc: (create, edit, query) - The maximum number of polygons accepted on the input mesh. Default: 1000
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        preserveVertexOrdering | pvo: (create, edit, query) - Preserve vertex ordering in conversion Default: true
        quickConvert | qc: (create, edit, query) - Debug flag to test the performance Default: true
        uvPoints | uvp: (create, edit, multiuse, query) - This is a cached uv point needed to transfer uv data associated with finer level vertices (when switching between standard editing mode and poly proxy mode.
        uvPointsU | uvu: (create, edit, query) - U value of a cached uv point
        uvPointsV | uvv: (create, edit, query) - V value of a cached uv point
        uvTreatment | uvt: (create, edit, query) - Treatment of Subd UVs when in proxy mode:   0 - preserve Subd UVs  1 - build Subd UVs from Poly UVs  2 - no UVs on Subd  Default: 0
        addUnderTransform | aut: (create) - If true then add the new subdivision surface under the poly's transform.
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
    """
    ...


def polyTransfer(*args, alternateObject: Optional[Union[str, bool]] = ..., ao: Optional[Union[str, bool]] = ..., caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., uvSets: bool = ..., uv: bool = ..., vertexColor: bool = ..., vc: bool = ..., vertices: bool = ..., v: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Transfer information from one polygonal object to another one. Both objects
    must have identical topology, that is same vertex, edge, and face
    numbering. The flags specify which of the vertices, UV sets
    or vertex colors will be copied.

    Args:
        alternateObject | ao: (create, edit, query) - Name of the alternate object.
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        uvSets | uv: (create, edit, query) - When true, the UV sets are copied from the alternate object. C: Default is "on".
        vertexColor | vc: (create, edit, query) - When true, the colors per vertex are copied from the alternate object. C: Default is "off".
        vertices | v: (create, edit, query) - When true, the vertices positions are copied from the alternate object. C: Default is "off".
    """
    ...


def polyTriangulate(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Triangulation breaks polygons down into triangles, ensuring that all
    faces are planar and non-holed.
    Triangulation of models can be beneficial in many areas.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def polyUnite(*args, caching: bool = ..., cch: bool = ..., mergeUVSets: Optional[Union[int, bool]] = ..., muv: Optional[Union[int, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., centerPivot: bool = ..., cp: bool = ..., objectPivot: bool = ..., op: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command creates a new poly as an union of a list of polys
    If no objects are specified in the command line, then the
    objects from the active list are used.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        mergeUVSets | muv: (create) - Specify how UV sets will be merged on the output mesh. The choices are 0 | 1 | 2. 0 = Do not merge. Each UV set on each mesh will become a new UV set in the output. 1 = Merge by name. UV sets with the same name will be merged. 2 = Merge by UV links. UV sets will be merged so that UV linking on the input meshes continues to work. The default is 1 (merge by name).
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        centerPivot | cp: (create) - Set the resulting object's pivot to the center of the selected objects bounding box.
        objectPivot | op: (create) - Set the resulting object's pivot to last selected object's pivot.
    """
    ...


def polyUnsmooth(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., divisionLevels: Optional[Union[int, bool]] = ..., dlv: Optional[Union[int, bool]] = ..., frozen: bool = ..., fzn: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Attempt to recreate the lower subdivision levels of a mesh that was subdivided
    with the Catmull-Clark subdivision method.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        divisionLevels | dlv: (create, edit, query) - This flag specifies how many subdivision levels to attempt to step backwards.
        frozen | fzn: (create, edit, query) - Inherited from base class TpolyCleanCmd.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace) (not available in all commands). NOTE: This flag is intended for use by the "Unsmoorh" menu item. If 'polyUnsmooth -rpo 0' is executed from the command line, Shader information will not be copied from the original mesh to the result.
    """
    ...


def polyUVCoverage(*args, uvRange: Optional[Union[Tuple[float, float, float, float], bool]] = ..., ur: Optional[Union[Tuple[float, float, float, float], bool]] = ...) -> Any:
    r"""
    Return the UV space coverage of the specified components.
    If no objects are specified in the command line, then components from selection list will be used.

    Args:
        uvRange | ur: (create) - UV space range for calculating the coverage The 4 values specify the minimum U, V and maximum U, V in that order. Default is 0.0 0.0 1.0 1.0.
    """
    ...


def polyUVOverlap(*args, nonOverlappingComponents: bool = ..., noc: bool = ..., overlappingComponents: bool = ..., oc: bool = ...) -> Any:
    r"""
    Return the required result on the specified components.
    If no objects are specified in the command line, then components from selection list will be used.

    Args:
        nonOverlappingComponents | noc: (create) - Return non-overlapping components based on selected/specified components
        overlappingComponents | oc: (create) - Return overlapping components based on selected/specified components
    """
    ...


def polyUVRectangle(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Given two vertices, does one of the following:
    1) If the vertices define opposite corners of a rectangular area of quads,
    assigns a grid of UVs spanning the 0-1 area to that rectangle.
    2) If the vertices define an edge in a rectangular and topologically
    cylindrical area of quads, assigns UVs spanning the 0-1 area to that
    cylindrical patch, using the defined edge as the U=0 edge.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def polyUVSet(*args, allUVSets: bool = ..., auv: bool = ..., allUVSetsIndices: bool = ..., uvn: bool = ..., allUVSetsWithCount: bool = ..., awc: bool = ..., copy: bool = ..., cp: bool = ..., create: bool = ..., cr: bool = ..., currentLastUVSet: bool = ..., luv: bool = ..., currentPerInstanceUVSet: bool = ..., cpi: bool = ..., currentUVSet: bool = ..., cuv: bool = ..., delete: bool = ..., d: bool = ..., genNewUVSet: bool = ..., gen: bool = ..., newUVSet: Optional[Union[str, bool]] = ..., nuv: Optional[Union[str, bool]] = ..., perInstance: bool = ..., pi: bool = ..., projections: bool = ..., pr: bool = ..., rename: bool = ..., rn: bool = ..., reorder: bool = ..., ro: bool = ..., shareInstances: bool = ..., si: bool = ..., unshared: bool = ..., us: bool = ..., uvSet: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Command to do the following to uv sets:
            - delete an existing uv set.
            - rename an existing uv set.
        - create a new empty uv set.
        - copy the values from one uv set to a another
          pre-existing uv set.
            - reorder two uv sets
            - set the current uv set to a pre-existing uv set.
        - modify sharing between instances of per-instance uv sets
            - query the current uv set.
            - set the current uv set to the last uv set added to an object.
        - query the names of all uv sets.

    Args:
        allUVSets | auv: (edit, query) - This flag when used in in a query will return a list of all of the uv set names
        allUVSetsIndices | uvn: (edit, query) - This flag when queried will return a list of the logical plug indices of all the uv sets in the sparse uv set array.
        allUVSetsWithCount | awc: (edit, query) - This flag when used in a query will return a list of all of the uv set family names, with a count appended to the perInstance sets indicating the number of instances in the uv set shared by the specified or selected shape.
        copy | cp: (create, edit, query) - This flag when used will result in the copying of the uv set corresponding to name specified with the uvSet flag to the uvset corresponding to the name specified with the newUVSet flag
        create | cr: (create, edit, query) - This flag when used will result in the creation of an empty uv set corresponding to the name specified with the uvSet flag. If a uvSet with that name already exists, then no new uv set will be created.
        currentLastUVSet | luv: (create, edit, query) - This flag when used will set the current uv set that the object needs to work on, to be the last uv set added to the object. If no uv set exists for the object, then no uv set name will be returned.
        currentPerInstanceUVSet | cpi: (edit, query) - This is a query-only flag for use when the current uv set is a per-instance uv set family. This returns the member of the set family that corresponds to the currently select instance.
        currentUVSet | cuv: (create, edit, query) - This flag when used will set the current uv set that the object needs to work on, to be the uv set corresponding to the name specified with the uvSet flag. This does require that a uvSet with the specified name exist. When queried, this returns the current uv set.
        delete | d: (create, edit, query) - This flag when used will result in the deletion of the uv set corresponding to the name specified with the uvSet flag.
        genNewUVSet | gen: (edit, query) - This is a query-only flag to generate a new unique name.
        newUVSet | nuv: (create, edit, query) - Specifies the name that the uv set corresponding to the name specified with the uvSet flag, needs to be renamed to.
        perInstance | pi: (create, edit, query) - This flag can be used in conjunction with the create flag to indicate whether or not the uv set is per-instance. When you create a per-instance uv set, the set will be applied as shared between all selected instances of the shape unless the unshared flag is used. The perInstance flag can be used in query mode with the currentUVSet or allUVSets  flag to indicate that the set family names (i.e. not containing instance identifiers) will be returned by the query. 			In query mode, this flag can accept a value.
        projections | pr: (edit, query) - This flag when used in a query will return a list of polygon uv projection node names. The order of the list is from most-recently-applied to least-recently-applied.
        rename | rn: (create, edit, query) - This flag when used will result in the renaming of the uv set corresponding to the name specified with the uvSet flag to the name specified using the newUVSet flag.
        reorder | ro: (create, edit, query) - This flag when used will result in the reordering of two uv sets corresponding to name specified with the uvSet flag, and the uvset corresponding to the name specified with the newUVSet flag
        shareInstances | si: (create, edit, query) - This flag is used to modify the sharing of per-instance uv sets within a given uv set family so that all selected instances share the specified set. In query mode, it returns a list of the instances that share the set specified by the uvSet flag.
        unshared | us: (create, edit, query) - This flag can be used in conjunction with the create and perInstance flags to indicate that the newly created per-instance set should be created with a separate set per instance.
        uvSet | uvs: (create, edit, query) - Specifies the name of the uv set that this command needs to work on. This flag has to be specified for this command to do anything meaningful other than query the current uv set. 			In query mode, this flag needs a value.
    """
    ...


def polyUVStackSimilarShells(*args, onlyMatch: bool = ..., om: bool = ..., tolerance: Optional[Union[float, bool]] = ..., to: Optional[Union[float, bool]] = ...) -> Any:
    r"""
    Stack Similar UV Shells.

    Args:
        onlyMatch | om: (create) - If this flag is true, only match UV shells and return UVs of target UV shells but don't stack.
        tolerance | to: (create) - The tolerance setting for stacking how similar UV shells.
    """
    ...


def polyWedgeFace(*args, axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., caching: bool = ..., cch: bool = ..., center: Optional[Union[Tuple[float, float, float], bool]] = ..., cen: Optional[Union[Tuple[float, float, float], bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., divisions: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., edge: Optional[Union[int, bool]] = ..., ed: Optional[Union[int, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., wedgeAngle: Optional[Union[float, bool]] = ..., wa: Optional[Union[float, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Extrude faces about an axis.
    The axis is the average of all the selected edges.
    If the edges are not aligned, the wedge may not look
    intuitive.  To separately wedge faces about different
    wedge axes, the command should be issued as many times
    as the wedge axes. (as in the second example)

    Args:
        axis | ax: (create) - This flag (along with -center) can be used instead of the -edge flag to specify the axis about which the wedge is performed. The flag expects three coordinates that form a vector about which the rotation is performed.
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        center | cen: (create) - This flag (along with -axis) can be used instead of the -edge flag to specify the location about which the wedge is performed. The flag expects three coordinates that define the center of rotation.
        constructionHistory | ch: (create, query) - Turn the construction history on or off (where applicable). If construction history is on then the corresponding node will be inserted into the history chain for the mesh. If construction history is off then the operation will be performed directly on the object.  Note: If the object already has construction history then this flag is ignored and the node will always be inserted into the history chain.
        divisions | d: (create) - This flag specifies the number of subdivisions along the extrusion.
        edge | ed: (create, multiuse) - This flag specifies the edgeId that should be used to perform the wedge about. Multiple edges can be specified. The wedge operation is performed about an axis that is the average of all the edges. It is recommended that only colinear edges are used, otherwise the result may not look intuitive.  Instead of specifying the -edge flag, the wedge can be performed about a point and axis. See the -center and -axis flags for details.
        name | n: (create) - Give a name to the resulting node.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        wedgeAngle | wa: (create) - This flag specifies the angle of rotation.
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is off. Q: When queried, this flag returns an int.
    """
    ...


def projectCurve(*args, caching: bool = ..., cch: bool = ..., direction: Optional[Union[Tuple[float, float, float], bool]] = ..., d: Optional[Union[Tuple[float, float, float], bool]] = ..., directionX: Optional[Union[float, bool]] = ..., dx: Optional[Union[float, bool]] = ..., directionY: Optional[Union[float, bool]] = ..., dy: Optional[Union[float, bool]] = ..., directionZ: Optional[Union[float, bool]] = ..., dz: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., useNormal: bool = ..., un: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., range: bool = ..., rn: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The projectCurve command creates curves on surface where all
    selected curves project onto the selected surfaces. Projection can
    be done using the surface normals or the user can specify the vector to
    project along. Note: the user does not have to specify the curves and
    surfaces in any particular order in the command line.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        direction | d: (create, edit, query) - Direction of projection. Available only if useNormal is false.
        directionX | dx: (create, edit, query) - X direction of projection. Default: 0.0
        directionY | dy: (create, edit, query) - Y direction of projection. Default: 0.0
        directionZ | dz: (create, edit, query) - Z direction of projection. Default: 1.0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        tolerance | tol: (create, edit, query) - Tolerance to fit to. Default: 0.01
        useNormal | un: (create, edit, query) - True if the surface normal is to be used and false if the direction vector should be used instead. Default: false
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        range | rn: (create) - Force a curve range on complete input curve.
    """
    ...


def projectTangent(*args, caching: bool = ..., cch: bool = ..., curvature: bool = ..., c: bool = ..., curvatureScale: Optional[Union[float, bool]] = ..., cs: Optional[Union[float, bool]] = ..., ignoreEdges: bool = ..., ie: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., reverseTangent: bool = ..., rt: bool = ..., rotate: Optional[Union[float, bool]] = ..., ro: Optional[Union[float, bool]] = ..., tangentDirection: Optional[Union[int, bool]] = ..., td: Optional[Union[int, bool]] = ..., tangentScale: Optional[Union[float, bool]] = ..., ts: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The project tangent command is used to align (for tangents) a curve
    to two other curves or a surface. A surface isoparm may be selected
    to define the direction (U or V) to align to. The end of the curve
    must intersect with these other objects. Curvature continuity may also
    be applied if required.
    
    Tangent continuity means the end of the curve is modified to be tangent
    at the point it meets the other objects.
    
    Curvature continuity means the end of the curve is modified to be
    curvature continuous as well as tangent.
    
    If the normal tangent direction is used, the curvature continuity
    and rotation do not apply. Also, curvature continuity is only available
    if align to a surface (not with 2 curves).

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        curvature | c: (create, edit, query) - Curvature continuity is on if true and off otherwise. Default: false
        curvatureScale | cs: (create, edit, query) - Curvature scale applied to curvature of curve to align. Available if curvature option is true. Default: 0.0
        ignoreEdges | ie: (create, edit, query) - If false, use the tangents of the trim edge curves if the surface is trimmed. If true, use the tangents of the underlying surface in the U/V directions. Default: false
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        reverseTangent | rt: (create, edit, query) - Reverse the tangent direction if true and leave it the way it is if false. Default: false
        rotate | ro: (create, edit, query) - Amount by which the tangent of the curve to align will be rotated. Available only if the normal direction (3) is not used for tangentDirection. Default: 0.0
        tangentDirection | td: (create, edit, query) - Tangent align direction type legal values: 1=u direction (of surface or use first curve), 2=v direction (of surface or use second curve), 3=normal direction (at point of intersection). Default: 1
        tangentScale | ts: (create, edit, query) - Tangent scale applied to tangent of curve to align. Default: 1.0
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def propMove(*args, percent: Optional[Union[float, bool]] = ..., p: Optional[Union[float, bool]] = ..., percentX: Optional[Union[float, bool]] = ..., px: Optional[Union[float, bool]] = ..., percentY: Optional[Union[float, bool]] = ..., py: Optional[Union[float, bool]] = ..., percentZ: Optional[Union[float, bool]] = ..., pz: Optional[Union[float, bool]] = ..., pivot: Optional[Union[Tuple[float, float, float], bool]] = ..., pi: Optional[Union[Tuple[float, float, float], bool]] = ..., rotate: Optional[Union[Tuple[float, float, float], bool]] = ..., r: Optional[Union[Tuple[float, float, float], bool]] = ..., scale: Optional[Union[Tuple[float, float, float], bool]] = ..., s: Optional[Union[Tuple[float, float, float], bool]] = ..., translate: Optional[Union[Tuple[float, float, float], bool]] = ..., t: Optional[Union[Tuple[float, float, float], bool]] = ..., worldSpace: bool = ..., ws: bool = ...) -> Any:
    r"""
    Performs a proportional translate, scale or rotate operation on any
    number of objects. The percentages to rotate, scale or translate by
    can be specified using either the -p flags or -px, -py, -pz
    flags. Each selected object must have a corresponding -p or -px, -py,
    -pz flag. The rotate, scale or translate performed is relative.

    Args:
        percent | p: (create, multiuse) - The percentage effect that the specified x,y,z has on an object. This flag must be specified once for each object, ie. if there are 4 objects specified, there must be 4 "-p" flags, (otherwise a percentage of 1.0 will be used).  This flag generally has a range between 0.0 and 1.0, but can be any float value.
        percentX | px: (create, multiuse) - The percentage effect that the specified x has on an object. This flag is specified one per object. The value ranges between 0.0 and 1.0, but can be any float value. If the -p flag has been specified, this flag usage is invalid.
        percentY | py: (create, multiuse) - The percentage effect that the specified y has on an object. This flag is specified one per object. The value ranges between 0.0 and 1.0, but can be any float value. If the -p flag has been specified, this flag usage is invalid.
        percentZ | pz: (create, multiuse) - The percentage effect that the specified z has on an object. This flag is specified one per object. The value ranges between 0.0 and 1.0, but can be any float value. If the -p flag has been specified, this flag usage is invalid.
        pivot | pi: (create) - Specify the pivot about which a rotation or scale will occur. The change in pivot lasts only as long as the current 'propMove' command, and so must be used in conjunction with one of the above move flags for any effect to be noticeable.
        rotate | r: (create) - Proportionally rotate each object by the given angles. The rotation values are scaled by the percentage specified by that object's corresponding "-percent" flag. All angles are in degrees. The rotation is about the pivot specified by the "-pivot" flag, or (0, 0, 0) if the "-pivot" flag is not present.
        scale | s: (create) - Proportionally scale each object by the given amounts. The scale values are scaled by the percentage specified by that object's corresponding "-percent" flag. The position and size of each object is measured relative to the pivot specified by the "-pivot" flag, and defaults to each object's individual pivot. In the case of control vertices, or some other object component, the default is the parent object's pivot.
        translate | t: (create) - Proportionally translate each object by the given amounts. The translation values are scaled by the percentage specified by that object's corresponding "-percent" flag. The "-pivot" flag has no effect on translation.
        worldSpace | ws: (create) - Use worldspace for the calculations.
    """
    ...


def querySubdiv(*args, action: Optional[Union[int, bool]] = ..., a: Optional[Union[int, bool]] = ..., level: Optional[Union[int, bool]] = ..., l: Optional[Union[int, bool]] = ..., relative: bool = ..., r: bool = ...) -> Any:
    r"""
    Queries a subdivision surface based on a set of query parameters and updates the selection list with the results.

    Args:
        action | a: (create) - Specifies the query parameter:         1 = find all tweaked verticies at level         2 = find all sharpened vertices at level         3 = find all sharpened edges at level         4 = find all faces at level If the attribute "level" is not specified then the query is applied to the current component display level. If the attribute level is specified then the query is applied to that level, either absolute or relative to the current level based on the "relative" flag state.
        level | l: (create) - Specify the level of the subdivision surface on which to perform the operation.
        relative | r: (create) - If set, level flag refers to the level relative to the current component display level.
    """
    ...


def rebuildCurve(*args, caching: bool = ..., cch: bool = ..., degree: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., endKnots: Optional[Union[int, bool]] = ..., end: Optional[Union[int, bool]] = ..., fitRebuild: bool = ..., fr: bool = ..., keepControlPoints: bool = ..., kcp: bool = ..., keepEndPoints: bool = ..., kep: bool = ..., keepRange: Optional[Union[int, bool]] = ..., kr: Optional[Union[int, bool]] = ..., keepTangents: bool = ..., kt: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., rebuildType: Optional[Union[int, bool]] = ..., rt: Optional[Union[int, bool]] = ..., smartSurfaceCurveRebuild: bool = ..., scr: bool = ..., spans: Optional[Union[int, bool]] = ..., s: Optional[Union[int, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., range: bool = ..., rn: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command rebuilds a curve by modifying its parameterization.
    In some cases the shape may also change. The rebuildType (-rt)
    determines how the curve is to be rebuilt.
    
    The optional second curve can be used to specify a reference
    parameterization.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        degree | d: (create, edit, query) - The degree of the resulting curve 1 - linear, 2 - quadratic, 3 - cubic, 5 - quintic, 7 - heptic Default: 3
        endKnots | end: (create, edit, query) - End conditions for the curve 0 - uniform end knots, 1 - multiple end knots, Default: 0
        fitRebuild | fr: (create, edit, query) - If true use the least squares fit rebuild. Otherwise use the convert method. Default: true
        keepControlPoints | kcp: (create, edit, query) - If true, the CVs will remain the same. This forces uniform parameterization unless rebuildType is matchKnots. Default: false
        keepEndPoints | kep: (create, edit, query) - If true, keep the endpoints the same. Default: true
        keepRange | kr: (create, edit, query) - Determine the parameterization for the resulting curve. 0 - reparameterize the resulting curve from 0 to 1, 1 - keep the original curve parameterization, 2 - reparameterize the result from 0 to number of spans Default: 1
        keepTangents | kt: (create, edit, query) - If true, keep the end tangents the same. Default: true
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        rebuildType | rt: (create, edit, query) - How to rebuild the input curve. 0 - uniform, 1 - reduce spans, 2 - match knots, 3 - remove multiple knots, 4 - curvature 5 - rebuild ends 6 - clean Default: 0
        smartSurfaceCurveRebuild | scr: (create, edit, query) - If true, curve on surface is rebuild in 3D and 2D info is kept Default: false
        spans | s: (create, edit, query) - The number of spans in resulting curve Used only if rebuildType is uniform. Default: 4
        tolerance | tol: (create, edit, query) - The tolerance with which to rebuild. Default: 0.01
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        range | rn: (create) - Force a curve range on complete input curve.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def rebuildSurface(*args, caching: bool = ..., cch: bool = ..., degreeU: Optional[Union[int, bool]] = ..., du: Optional[Union[int, bool]] = ..., degreeV: Optional[Union[int, bool]] = ..., dv: Optional[Union[int, bool]] = ..., direction: Optional[Union[int, bool]] = ..., dir: Optional[Union[int, bool]] = ..., endKnots: Optional[Union[int, bool]] = ..., end: Optional[Union[int, bool]] = ..., fitRebuild: Optional[Union[int, bool]] = ..., fr: Optional[Union[int, bool]] = ..., keepControlPoints: bool = ..., kcp: bool = ..., keepCorners: bool = ..., kc: bool = ..., keepRange: Optional[Union[int, bool]] = ..., kr: Optional[Union[int, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., rebuildType: Optional[Union[int, bool]] = ..., rt: Optional[Union[int, bool]] = ..., spansU: Optional[Union[int, bool]] = ..., su: Optional[Union[int, bool]] = ..., spansV: Optional[Union[int, bool]] = ..., sv: Optional[Union[int, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command rebuilds a surface by modifying its parameterization.
    In some cases the shape of the surface may also change. The
    rebuildType (-rt) attribute determines how the surface is rebuilt.
    
    The optional second surface can be used to specify a reference
    parameterization.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        degreeU | du: (create, edit, query) - The degree of the resulting surface in the u direction 0 - maintain current, 1 - linear, 2 - quadratic, 3 - cubic, 5 - quintic, 7 - heptic Default: 3
        degreeV | dv: (create, edit, query) - The degree of the resulting surface in the v direction 0 - maintain current, 1 - linear, 2 - quadratic, 3 - cubic, 5 - quintic, 7 - heptic Default: 3
        direction | dir: (create, edit, query) - The direction in which to rebuild: 0 - U, 1 - V, 2 - Both U and V Default: 2
        endKnots | end: (create, edit, query) - End conditions for the surface 0 - uniform end knots, 1 - multiple end knots, Default: 0
        fitRebuild | fr: (create, edit, query) - Specify the type of rebuild method to be used: 0 - Convert Classic, the default and original convert method. 1 - Fit using the least squares fit method. 2 - Convert Match, alternate matching convert method. 3 - Convert Grid, uses a grid-based fit algorithm. Default: 0
        keepControlPoints | kcp: (create, edit, query) - Use the control points of the input surface. This forces uniform parameterization unless rebuildType is 2 (match knots) Default: false
        keepCorners | kc: (create, edit, query) - The corners of the resulting surface will not change from the corners of the input surface. Default: true
        keepRange | kr: (create, edit, query) - Determine the parameterization for the resulting surface. 0 - reparameterize the resulting surface from 0 to 1; 1 - keep the original surface parameterization; 2 - reparameterize the result from 0 to number of spans Default: 1
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        rebuildType | rt: (create, edit, query) - The rebuild type: 0 - uniform, 1 - reduce spans, 2 - match knots, 3 - remove multiple knots, 4 - force non rational 5 - rebuild ends 6 - trim convert (uniform) 7 - into Bezier mesh Default: 0
        spansU | su: (create, edit, query) - The number of spans in the u direction in resulting surface. Used only when rebuildType is 0 - uniform. If 0, keep the same number of spans as the original surface. Default: 4
        spansV | sv: (create, edit, query) - The number of spans in the v direction in resulting surface. Used only when rebuildType is 0 - uniform. If 0, keep the same number of spans as the original surface. Default: 4
        tolerance | tol: (create, edit, query) - The tolerance with which to rebuild Default: 0.01
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def refineSubdivSelectionList(*args) -> Any:
    r"""
    Refines a subdivision surface set of components based on the selection list. The
    selected components are subdivided. The selection list after the command is the
    newly created components at the finer subdivision level.

    Args:
    """
    ...


def reverseCurve(*args, caching: bool = ..., cch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., curveOnSurface: bool = ..., cos: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., range: bool = ..., rn: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The reverseCurve command reverses the direction of a curve or
    curve-on-surface.  A string is returned containing the pathname
    of the newly reversed curve and the name of the resulting dependency
    node.  The reversed curve has the same parameter range as the original
    curve.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        constructionHistory | ch: (create) - Turn the construction history on or off.
        curveOnSurface | cos: (create) - If possible, create 2D curve as a result.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        range | rn: (create) - Force a curve range on complete input curve.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def reverseSurface(*args, caching: bool = ..., cch: bool = ..., direction: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The reverseSurface command reverses one or both directions of a
    surface or can be used to "swap" the U and V directions (this creates
    the effect of reversing the surface normal). The name of the newly
    reversed surface and the name of the resulting dependency node is
    returned. The resulting surface has the same parameter ranges as the
    original surface.
    
    This command also handles selected surface isoparms. For a selected
    isoparm, imagine that the isoparm curve is reversed after the
    operation. E.g. reverseSurface surface.v[0.1] will reverse in the U
    direction.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        direction | d: (create, edit, query) - The direction to reverse the surface in: 0 - U, 1 - V, 2 - Both U and V, 3 - Swap Default: 0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def revolve(*args, autoCorrectNormal: bool = ..., acn: bool = ..., axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., axisChoice: Optional[Union[int, bool]] = ..., aco: Optional[Union[int, bool]] = ..., axisX: Optional[Union[float, bool]] = ..., axx: Optional[Union[float, bool]] = ..., axisY: Optional[Union[float, bool]] = ..., axy: Optional[Union[float, bool]] = ..., axisZ: Optional[Union[float, bool]] = ..., axz: Optional[Union[float, bool]] = ..., bridge: bool = ..., br: bool = ..., caching: bool = ..., cch: bool = ..., computePivotAndAxis: Optional[Union[int, bool]] = ..., cpa: Optional[Union[int, bool]] = ..., degree: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., endSweep: Optional[Union[float, bool]] = ..., esw: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., pivot: Optional[Union[Tuple[float, float, float], bool]] = ..., p: Optional[Union[Tuple[float, float, float], bool]] = ..., pivotX: Optional[Union[float, bool]] = ..., px: Optional[Union[float, bool]] = ..., pivotY: Optional[Union[float, bool]] = ..., py: Optional[Union[float, bool]] = ..., pivotZ: Optional[Union[float, bool]] = ..., pz: Optional[Union[float, bool]] = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., radiusAnchor: Optional[Union[float, bool]] = ..., ra: Optional[Union[float, bool]] = ..., sections: Optional[Union[int, bool]] = ..., s: Optional[Union[int, bool]] = ..., startSweep: Optional[Union[float, bool]] = ..., ssw: Optional[Union[float, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., useTolerance: bool = ..., ut: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., range: bool = ..., rn: bool = ..., rebuild: bool = ..., rb: bool = ..., useLocalPivot: bool = ..., ulp: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command creates a revolved surface by revolving the given profile
    curve about an axis.  The profile curve can be a curve, curve-on-surface,
    surface isoparm, or trim edge.

    Args:
        autoCorrectNormal | acn: (create, edit, query) - If this is set to true we will attempt to reverse the direction of the axis in case it is necessary to do so for the surface normals to end up pointing to the outside of the object. Default: false
        axis | ax: (create, edit, query) - Revolve axis
        axisChoice | aco: (create, edit, query) - Only used for computed axis/pivot case.  As we are computing the axis for a planar curve, we have two choices for the major axis based axis.  We will choose the axis corresponding to the longer dimension of the object (0), or explicitly choose one or the other (choices 1 and 2). Default: 0
        axisX | axx: (create, edit, query) - X of the axis Default: 1
        axisY | axy: (create, edit, query) - Y of the axis Default: 0
        axisZ | axz: (create, edit, query) - Z of the axis Default: 0
        bridge | br: (create, edit, query) - If true, we will close a partial revolve to get a pie shaped surface.  The surface will be closed, but not periodic the way it is in the full revolve case. Default: false
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        computePivotAndAxis | cpa: (create, edit, query) - If this is set to 2, we will compute the axis, use the curve position and radius to compute the pivot for the revolve internally.  The value of the pivot and axis attributes are ignored.  If this is set to 1, we will take the supplied axis, but compute the pivot.  If this is set to 0, we will take both the supplied axis and pivot. Default: 0
        degree | d: (create, edit, query) - The degree of the resulting surface. Default: 3
        endSweep | esw: (create, edit, query) - The value for the end sweep angle, in the current units.  This must be no more than the maximum, 360 degrees, or 2 Pi radians. Default: 6.2831853
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        pivot | p: (create, edit, query) - Revolve pivot point
        pivotX | px: (create, edit, query) - X of the pivot Default: 0
        pivotY | py: (create, edit, query) - Y of the pivot Default: 0
        pivotZ | pz: (create, edit, query) - Z of the pivot Default: 0
        radius | r: (create, edit, query) - The pivot point will be this distance away from the bounding box of the curve, if computedPivot is set to true.  The value of the pivot attribute is ignored. Default: 1
        radiusAnchor | ra: (create, edit, query) - The position on the curve for the anchor point so that we can compute the pivot using the radius value.  If in 0 - 1 range, its on the curve, normalized parameter range.  If < 0 or > 1, its computed based on the bounding box. Default: -1
        sections | s: (create, edit, query) - Number of sections of the resulting surface (if tolerance is not used). Default: 8
        startSweep | ssw: (create, edit, query) - The value for the start sweep angle, in the current units.  This must be no more than the maximum, 360 degrees, or 2 Pi radians. Default: 0
        tolerance | tol: (create, edit, query) - Tolerance to build to (if useTolerance attribute is set) Default: 0.01
        useTolerance | ut: (create, edit, query) - Use the tolerance, or the number of sections to control the sections. Default: false
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
        range | rn: (create) - Force a curve range on complete input curve.
        rebuild | rb: (create) - Rebuild the input curve(s) before using them in the operation.  Use nurbsCurveRebuildPref to set the parameters for the conversion.
        useLocalPivot | ulp: (create, edit, query) - If true, then the pivot of the profile curve is used as the start point of the axis of revolution.
    """
    ...


def roundConstantRadius(*args, append: bool = ..., a: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., radiuss: Optional[Union[float, bool]] = ..., rad: Optional[Union[float, bool]] = ..., side: Optional[Union[Tuple[str, int], bool]] = ..., s: Optional[Union[Tuple[str, int], bool]] = ..., sidea: Optional[Union[int, bool]] = ..., sa: Optional[Union[int, bool]] = ..., sideb: Optional[Union[int, bool]] = ..., sb: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command generates constant radius NURBS fillets and NURBS
    corner surfaces for matching edge pairs on NURBS surfaces.  An
    edge pair is a matching pair of surface isoparms or trim edges.
    This command
    can handle more than one edge pair at a time.
    This command can also handle compound edges, which is where an edge
    pair is composed of more than two surfaces.  Use the "-sa" and "-sb"
    flags in this case.
    
    The results from this command are three surface var groups plus the
    name of the new roundConstantRadius dependency node, if history was on.
    The 1st var group contains trimmed copies of the original surfaces.  The 2nd
    var group contains the new NURBS fillet surfaces.  The 3rd var group
    contains the new NURBS corners (if any).
    
    A simple example of an edge pair is an edge of a NURBS cube,
    where two faces of the cube meet.  This command generates a NURBS
    fillet at the edge and trims back the faces.
    
    Another example is a NURBS cylinder with a planar trim surface cap.
    This command will create a NURBS fillet where the cap meets the
    the cylinder and will trim back the cap and the cylinder.
    
    Another example involves all 12 edges of a NURBS cube.  NURBS fillets
    are created where any face meets another face.  NURBS corners are
    created whenever 3 edges meet at a corner.

    Args:
        append | a: (create) - If true, then an edge pair is being added to an existing round dependency node.  Default is false. When this flag is true, an existing round dependency node must be specified. See example below.
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        radiuss | rad: (create, multiuse) - Use this flag to specify radius.  This overrides the "r/radius" flag.  If only one "rad" flag is used, then it is applied to all edge pairs.  If more than one "rad" flag is used, then the number of "-rad" flags must equal the number of edge pairs.  For example, for four edge pairs, zero, one or four "rad" flags must be specified.
        side | s: (create, multiuse) - Use this flag for compound edges.  It replaces the sidea/sideb flags and is compatible with Python.  The first argument must be either "a" or "b".  The same number of "a" values as "b" values must be specified. If no sides are specified with the "side" flag (or sidea/sideb flags), then the edges are assumed to be in pairs. See also examples below. For example, two faces of a cube meet at an edge pair. Suppose one of the faces is then split in two pieces at the middle of the edge, so that there is one face on side "A", and two pieces on side "B".  In this case the flag combination: -side "a" 1 -side "b" 2 would be used. The edges must be specified in the corresponding order: // MEL roundConstantRadius -side "a" 1 -side "b" 2 isoA isoB1 isoB2; # Python maya.cmds.roundConstantRadius( 'isoA', 'isoB1', 'isoB2', side=[("a",1), ("b",2)] )
        sidea | sa: (create, multiuse) - Use this flag for compound edges in conjunction with the following "-sb" flag.  This flag is not intended for use from Python.  Please see "side" flag instead.  The same number of "-sa" flags as "-sb" flags must be specified. If no "-sa" nor "-sb" flags are specified, then the edges are assumed to be in pairs. See also examples below. For example, two faces of a cube meet at an edge pair. Suppose one of the faces is then split in two pieces at the middle of the edge, so that there is one face on side "A", and two pieces on side "B".  In this case, the flag combination: -sidea 1 -sideb 2 would be used. The edges must be specified in the corresponding order: roundConstantRadius -sidea 1 -sideb 2 isoA isoB1 isoB2;
        sideb | sb: (create, multiuse) - Use this flag for compound edges in conjunction with the "-sa" flag.  See description for the "-sa" flag.  This flag is not intended for use from Python.  Please see "side" flag instead.
    """
    ...


def setXformManip(*args, showUnits: bool = ..., su: bool = ..., suppress: bool = ..., s: bool = ..., useRotatePivot: bool = ..., urp: bool = ..., worldSpace: bool = ..., ws: bool = ..., query: bool = ...) -> Any:
    r"""
    This command changes some of the settings of the xform manip,
    to control its appearance.

    Args:
        showUnits | su: (query) - If set to true, the xform manip displays current units; otherwise, the manip hides them.
        suppress | s: (query) - If set to true, the xform manip is suppressed and therefore not visible or usable.
        useRotatePivot | urp: (query) - If set to true, the xform manip uses the rotate pivot; otherwise, the manip uses the bounding-box center. Defaults false.
        worldSpace | ws: (query) - If set to true, the xform manip is always in world space. If false, the manip is in object space. (Note: when multiple objects are selected the manip is always in world space, no matter what this is set to)
    """
    ...


def showMetadata(*args, auto: bool = ..., a: bool = ..., dataType: Optional[Union[str, bool]] = ..., dt: Optional[Union[str, bool]] = ..., interpolation: bool = ..., i: bool = ..., isActivated: bool = ..., ia: bool = ..., listAllStreams: bool = ..., las: bool = ..., listMembers: bool = ..., lm: bool = ..., listValidMethods: bool = ..., lvm: bool = ..., listVisibleStreams: bool = ..., lvs: bool = ..., member: Optional[Union[str, bool]] = ..., mb: Optional[Union[str, bool]] = ..., method: Optional[Union[str, bool]] = ..., m: Optional[Union[str, bool]] = ..., off: bool = ..., range: Optional[Union[Tuple[float, float], bool]] = ..., r: Optional[Union[Tuple[float, float], bool]] = ..., rayScale: Optional[Union[float, bool]] = ..., rs: Optional[Union[float, bool]] = ..., stream: Optional[Union[str, bool]] = ..., s: Optional[Union[str, bool]] = ..., query: bool = ...) -> Any:
    r"""
    This command is used to show metadata values which is in the
    specified channels "vertex", "edge", "face", and "vertexFace" in
    the viewport. You can view the data by three ways:
    
    "color": draw color on the components. 
    "ray": draw a ray on the components. 
    "string": draw 2d strings on the components. 
    
    For example, if the metadata of "shape.vtx[1]" is (1, 0, 0), you can turn on
    the visualization with all three modes.
    On "color" mode, you can see a red vertex which is on the position of "shape.vtx[1]".
    On "ray" mode, you can see a ray with the direction (1, 0, 0).
    On "string" mode, you can see strings "1 0 0" below the vertex in the viewport.
    
    
    To use "color" or "ray" mode, you should make the member of the data structure
    with three or less items, such as float[3]. The three items are mapped to "RGB" as a color, or "XYZ"
    as a vector. The structure with two items works similarly. The only difference
    is that the third value will always be zero.
    However, if the structure has only one item, the value is mapped to all three variables.
    That means if the structure is "int" and its value is 1, the color will be white(1, 1, 1)
    and the vector will be (1, 1, 1).
    
    
    You can get the current status of the flags on the query mode (using "-query").
    But you can query only the status of one flag in a single command and
    you cannot set values on the query mode.
    
    
    You can use the command on some specified objects, or run it with no arguments
    to make changes on all objects in the scene. The object must be a mesh shape.
    Components are not allowed as the command arguments.

    Args:
        auto | a: (create, query) - Similar to the flag "-range", but uses the min/max value from the metadata in the same stream and member instead of the specified input value. In query mode, you can use the flag to query if "auto" is on.
        dataType | dt: (create, query) - In create mode, when used with the flags "stream" and "member", specify a member to show. If the flag "off" is used, specify the member to turn off. In query mode, when used with the flags "stream" and "member", query the visualization state of the specified member. Only one member of each shape can be visualized at a time. 			In query mode, this flag can accept a value.
        interpolation | i: (create, query) - In create mode, enable/disable interpolation for "color" method. When interpolation is on, the components will be displayed in the interpolated color, which is computed by averaging their metadata values. In query mode, query the current state of interpolation flag of the selected objects.
        isActivated | ia: (create, query) - Used to check if the given stream is activated. If some shapes are selected, query their states. If no shape is selected, query the states of all shapes in the scene.
        listAllStreams | las: (create, query) - Used with object names to list all streams of the specified objects. no matter if they are visible in the viewport. Or you can use the flag individually to list all streams in the scene. Due to the fact that different objects may have the same stream name, the returned list will merge the duplicated stream names automatically.
        listMembers | lm: (create, query) - Used with the flag 'stream' to get the member list in the specified stream.
        listValidMethods | lvm: (create, query) - List the valid visual methods that can be set for the current stream and member. Some data type cannot be displayed by some methods. For example, if the data type is "string", it cannot be displayed by "color" or by "ray". In other words, only the method "string" will be returned when you list the methods.
        listVisibleStreams | lvs: (create, query) - Used with object names to list the name of the current visible streams of the specified object. Or you can use the flag with no object name to list all visible streams in the scene.
        member | mb: (create, query) - In create mode, when used with the flags "stream" and "dataType", specify a member to show. If the flag "off" is on, specify the member to turn off. In query mode, when used with the flags "stream" and "dataType", query the visualization state of the specified member. Only one member of each shape can be visualized at a time. 			In query mode, this flag can accept a value.
        method | m: (create, query) - Determine the method of visualization: "color"         convert metadata to a color value and draw the components with the color "ray"           convert metadata to a vector and draw this vector line which starts from the center of the component "string"        display the metadata through 2d string beside the component in the viewport The argument must be a string and must be one of the three words. The default method is "color". If the data type is string, you can only show it with "string" method. In query mode, you can use the flag with no arguments to query the method of a specified stream and member.
        off: (create, query) - In create mode, turn off the member which is specified by the flags "stream", "member" and "dataType".
        range | r: (create, query) - Specify the range of data to use. The value which is out of the range will be clamped to the min/max value. If the method of visualization is "color", the range will be mapped to the color. That means the min value will be displayed in black while the max value will be in white. In query mode, you can use the flag individually to query the current range.
        rayScale | rs: (create, query) - Specify the scale of the ray to display it with a proper length.
        stream | s: (create, query) - In create mode, when used with the flags "member" and "dataType", specify a member to show. If the flag "off" is used, specify the member to turn off. In query mode, when used with the flags "member" and "dataType", query the visualization state of the specified member. When used with the flag "listMembers", query the members in the specified stream. Only one member of each shape can be visualized at a time. 			In query mode, this flag can accept a value.
    """
    ...


def singleProfileBirailSurface(*args, caching: bool = ..., cch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., tangentContinuityProfile1: bool = ..., tp1: bool = ..., transformMode: Optional[Union[int, bool]] = ..., tm: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This cmd creates a railed surface by sweeping the profile curve along
    the two rail curves. One of the requirements for surface creation is
    the profile curve must intersect the two rail curves. If the profile
    is a surface curve i.e. isoparm, curve on surface or trimmed edge then
    tangent continuity across the surface underlying the profile may be
    enabled using the flag -tp1 true.
    
    The first argument represetns the profile curve, the second and third
    the rails.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        tangentContinuityProfile1 | tp1: (create, edit, query) - Need to be tangent continuous across the profile. The profile must be a surface curve. Default: false
        transformMode | tm: (create, edit, query) - transform mode ( Non proportional, proportional ). Non proportional is default value. Default: 0
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
    """
    ...


def smoothCurve(*args, caching: bool = ..., cch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., smoothness: Optional[Union[float, bool]] = ..., s: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The smooth command smooths the curve at the given control points.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        smoothness | s: (create, edit, query) - smoothness factor Default: 10.0
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def smoothTangentSurface(*args, caching: bool = ..., cch: bool = ..., direction: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., parameter: Optional[Union[float, bool]] = ..., p: Optional[Union[float, bool]] = ..., smoothness: Optional[Union[int, bool]] = ..., s: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The smoothTangentSurface command smooths the surface along
    an isoparm at each parameter value.
    The name of the surface is returned and
    if history is on, the name of the resulting dependency node is
    also returned.
    This command only applies to parameter values with a multiple knot
    value.
    (If the given parameter value has no multiple knot associated
    with it, then the dependency node is created but the surface
    doesn't change.)
    
    When would you use this?  If you have a surface consisting of
    a number of Bezier patches or any isoparms with more than a single
    knot multiplicity, you could get into a situation where a
    tangent break occurs.  So, it only makes sense to do this operation
    on the knot isoparms, and not anywhere in between, because the
    surface is already smooth everywhere in between.
    
    If you have a cubic or higher degree surface, asking for the maximal
    smoothness will give you tangent, curvature, etc. up to the degree-1
    continuity.  Asking for tangent will just give you tangent continuity.
    
    It should be mentioned that this is "C", not "G" continuity we're
    talking about, so technically, you can still see visual tangent breaks
    if the surface is degenerate.
    
    Note: A single smoothTangentSurface command cannot smooth in both directions
    at once; you must use two separate commands to do this.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        direction | d: (create, edit, query) - Direction in which to smooth knot: 0 - V direction, 1 - U direction Default: 1
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        parameter | p: (create, edit, multiuse, query) - Parameter value(s) where knots are added Default: 0.0
        smoothness | s: (create, edit, query) - Smoothness to get: 0 - Tangent, 1 - Maximum (based on the degree) Default: 1
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def sphere(*args, axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., caching: bool = ..., cch: bool = ..., degree: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., endSweep: Optional[Union[float, bool]] = ..., esw: Optional[Union[float, bool]] = ..., heightRatio: Optional[Union[float, bool]] = ..., hr: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., pivot: Optional[Union[Tuple[float, float, float], bool]] = ..., p: Optional[Union[Tuple[float, float, float], bool]] = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., sections: Optional[Union[int, bool]] = ..., s: Optional[Union[int, bool]] = ..., spans: Optional[Union[int, bool]] = ..., nsp: Optional[Union[int, bool]] = ..., startSweep: Optional[Union[float, bool]] = ..., ssw: Optional[Union[float, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., useTolerance: bool = ..., ut: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The sphere command creates a new sphere. The number of spans
    in the in each direction of the sphere is determined by the
    useTolerance attribute. If -ut is true then the -tolerance
    attribute will be used. If -ut is false then the -sections
    attribute will be used.

    Args:
        axis | ax: (create, edit, query) - The primitive's axis
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        degree | d: (create, edit, query) - The degree of the resulting surface: 1 - linear, 3 - cubic Default: 3
        endSweep | esw: (create, edit, query) - The angle at which to end the surface of revolution. Default is 2Pi radians, or 360 degrees. Default: 6.2831853
        heightRatio | hr: (create, edit, query) - Ratio of "height" to "width" Default: 2.0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        pivot | p: (create, edit, query) - The primitive's pivot point
        radius | r: (create, edit, query) - The radius of the object Default: 1.0
        sections | s: (create, edit, query) - The number of sections determines the resolution of the surface in the sweep direction. Used only if useTolerance is false. Default: 8
        spans | nsp: (create, edit, query) - The number of spans determines the resolution of the surface in the opposite direction. Default: 1
        startSweep | ssw: (create, edit, query) - The angle at which to start the surface of revolution Default: 0
        tolerance | tol: (create, edit, query) - The tolerance with which to build the surface. Used only if useTolerance is true Default: 0.01
        useTolerance | ut: (create, edit, query) - Use the specified tolerance to determine resolution. Otherwise number of sections will be used. Default: false
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
    """
    ...


def squareSurface(*args, caching: bool = ..., cch: bool = ..., continuityType1: Optional[Union[int, bool]] = ..., ct1: Optional[Union[int, bool]] = ..., continuityType2: Optional[Union[int, bool]] = ..., ct2: Optional[Union[int, bool]] = ..., continuityType3: Optional[Union[int, bool]] = ..., ct3: Optional[Union[int, bool]] = ..., continuityType4: Optional[Union[int, bool]] = ..., ct4: Optional[Union[int, bool]] = ..., curveFitCheckpoints: Optional[Union[int, bool]] = ..., cfc: Optional[Union[int, bool]] = ..., endPointTolerance: Optional[Union[float, bool]] = ..., ept: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., rebuildCurve1: bool = ..., rc1: bool = ..., rebuildCurve2: bool = ..., rc2: bool = ..., rebuildCurve3: bool = ..., rc3: bool = ..., rebuildCurve4: bool = ..., rc4: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command produces a square surface given 3 or 4 curves.
    This resulting square surface is created within the intersecting
    region of the selected curves. The order of selection is important
    and the curves must intersect or their ends must meet.
    
    You must specify one continuity type flag for each selected curve.
    If continuity type is 1 (fixed, no tangent continuity) then the
    curveFitCheckpoints flag (cfc) is not required.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        continuityType1 | ct1: (create, edit, query) - Continuity type legal values for curve 1: 1 - fixed boundary 2 - tangent continuity 3 - implied tangent continuity Default: 2
        continuityType2 | ct2: (create, edit, query) - Continuity type legal values for curve 2: 1 - fixed boundary 2 - tangent continuity 3 - implied tangent continuity Default: 2
        continuityType3 | ct3: (create, edit, query) - Continuity type legal values for curve 3: 1 - fixed boundary 2 - tangent continuity 3 - implied tangent continuity Default: 2
        continuityType4 | ct4: (create, edit, query) - Continuity type legal values for curve 4: 1 - fixed boundary 2 - tangent continuity 3 - implied tangent continuity Default: 2
        curveFitCheckpoints | cfc: (create, edit, query) - The number of points per span to check the tangency deviation between the boundary curve and the created tangent square surface. Only available for the tangent continuity type. Default: 5
        endPointTolerance | ept: (create, edit, query) - Tolerance for end points, only used if endPoint attribute is true. Default: 0.1
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        rebuildCurve1 | rc1: (create, edit, query) - A boolean to determine if input curve 1 should be rebuilt (with curvature continuity). Default: false
        rebuildCurve2 | rc2: (create, edit, query) - A boolean to determine if input curve 2 should be rebuilt (with curvature continuity). Default: false
        rebuildCurve3 | rc3: (create, edit, query) - A boolean to determine if input curve 3 should be rebuilt (with curvature continuity). Default: false
        rebuildCurve4 | rc4: (create, edit, query) - A boolean to determine if input curve 4 should be rebuilt (with curvature continuity). Default: false
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
    """
    ...


def stitchSurface(*args, bias: Optional[Union[float, bool]] = ..., b: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., cvIthIndex: Optional[Union[int, bool]] = ..., ci: Optional[Union[int, bool]] = ..., cvJthIndex: Optional[Union[int, bool]] = ..., cj: Optional[Union[int, bool]] = ..., fixBoundary: bool = ..., fb: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., parameterU: Optional[Union[float, bool]] = ..., u: Optional[Union[float, bool]] = ..., parameterV: Optional[Union[float, bool]] = ..., v: Optional[Union[float, bool]] = ..., positionalContinuity: bool = ..., pc: bool = ..., stepCount: Optional[Union[int, bool]] = ..., sc: Optional[Union[int, bool]] = ..., tangentialContinuity: bool = ..., tc: bool = ..., togglePointNormals: bool = ..., tpn: bool = ..., togglePointPosition: bool = ..., tpp: bool = ..., toggleTolerance: bool = ..., tt: bool = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., cascade: bool = ..., c: bool = ..., constructionHistory: bool = ..., ch: bool = ..., keepG0Continuity: bool = ..., kg0: bool = ..., keepG1Continuity: bool = ..., kg1: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., numberOfSamples: Optional[Union[int, bool]] = ..., ns: Optional[Union[int, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., weight0: Optional[Union[float, bool]] = ..., wt0: Optional[Union[float, bool]] = ..., weight1: Optional[Union[float, bool]] = ..., wt1: Optional[Union[float, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The stitchSurface command aligns two surfaces together to be
    G(0) and/or G(1) continuous by ajusting only the Control Vertices
    of the surfaces. The two surfaces can be stitched by specifying
    the two isoparm boundary edges that are to stitched together. The
    edge to which the two surfaces are stitched together is obtained
    by doing a weighted average of the two edges. The weights for the
    two edges is specified using the flags -wt0, -wt1 respectively.

    Args:
        bias | b: (create, edit, query) - Blend CVs in between input surface and result from stitch. A value of 0.0 returns the input surface. Default: 1.0
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        cvIthIndex | ci: (create, edit, multiuse, query) - The ith boundary CV index on the input surface. Default: -1
        cvJthIndex | cj: (create, edit, multiuse, query) - The jth boundary CV index on the input surface. Default: -1
        fixBoundary | fb: (create, edit, query) - Fix Boundary CVs while solving for any G1 constraints. Default: false
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        parameterU | u: (create, edit, multiuse, query) - The U parameter value on surface for a point constraint. Default: -10000
        parameterV | v: (create, edit, multiuse, query) - The V parameter value on surface for a point constraint. Default: -10000
        positionalContinuity | pc: (create, edit, multiuse, query) - Toggle on (off) G0 continuity at edge corresponding to multi index. Default: true
        stepCount | sc: (create, edit, multiuse, query) - Step count for the number of discretizations. Default: 20
        tangentialContinuity | tc: (create, edit, multiuse, query) - Toggle on (off) G1 continuity across edge corresponding to multi index. Default: false
        togglePointNormals | tpn: (create, edit, query) - Toggle on (off) normal point constraints on the surface. Default: false
        togglePointPosition | tpp: (create, edit, query) - Toggle on (off) position point constraints on the surface. Default: true
        toggleTolerance | tt: (create, edit, multiuse, query) - Toggle on (off) so as to use Tolerance or specified steps for discretization. Default: false
        tolerance | tol: (create, edit, multiuse, query) - Tolerance to use while discretizing the edge. Default: 0.1
        cascade | c: (create) - Cascade the created stitch node. (Only if the surface has a stitch history) Default is 'false'.
        constructionHistory | ch: (create) - Turn the construction history on or off.
        keepG0Continuity | kg0: (create) - Stitch together with positional continuity. Default is 'true'.
        keepG1Continuity | kg1: (create) - Stitch together with tangent continuity. Default is 'false'.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        numberOfSamples | ns: (create) - The number of samples on the edge. Default is 20.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
        weight0 | wt0: (create) - The weighting factor for the first edge. Default is 0.5.
        weight1 | wt1: (create) - The weighting factor for the second edge. Default is 0.5.
    """
    ...


def stitchSurfacePoints(*args, bias: Optional[Union[float, bool]] = ..., b: Optional[Union[float, bool]] = ..., caching: bool = ..., cch: bool = ..., cvIthIndex: Optional[Union[int, bool]] = ..., ci: Optional[Union[int, bool]] = ..., cvJthIndex: Optional[Union[int, bool]] = ..., cj: Optional[Union[int, bool]] = ..., fixBoundary: bool = ..., fb: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., parameterU: Optional[Union[float, bool]] = ..., u: Optional[Union[float, bool]] = ..., parameterV: Optional[Union[float, bool]] = ..., v: Optional[Union[float, bool]] = ..., positionalContinuity: bool = ..., pc: bool = ..., stepCount: Optional[Union[int, bool]] = ..., sc: Optional[Union[int, bool]] = ..., tangentialContinuity: bool = ..., tc: bool = ..., togglePointNormals: bool = ..., tpn: bool = ..., togglePointPosition: bool = ..., tpp: bool = ..., toggleTolerance: bool = ..., tt: bool = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., cascade: bool = ..., c: bool = ..., constructionHistory: bool = ..., ch: bool = ..., equalWeight: bool = ..., ewt: bool = ..., keepG0Continuity: bool = ..., kg0: bool = ..., keepG1Continuity: bool = ..., kg1: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The stitchSurfacePoints command aligns two or more surface points
    along the boundaries together to a single point. In the process, a
    node to average the points is created. The points are averaged
    together in a weighted fashion. The points may be control vertices
    along the boundaries. If the points are CVs then they are stitched
    together only with positional continuity.
    
    Note: No two points can lie on the same surface.

    Args:
        bias | b: (create, edit, query) - Blend CVs in between input surface and result from stitch. A value of 0.0 returns the input surface. Default: 1.0
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        cvIthIndex | ci: (create, edit, multiuse, query) - The ith boundary CV index on the input surface. Default: -1
        cvJthIndex | cj: (create, edit, multiuse, query) - The jth boundary CV index on the input surface. Default: -1
        fixBoundary | fb: (create, edit, query) - Fix Boundary CVs while solving for any G1 constraints. Default: false
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        parameterU | u: (create, edit, multiuse, query) - The U parameter value on surface for a point constraint. Default: -10000
        parameterV | v: (create, edit, multiuse, query) - The V parameter value on surface for a point constraint. Default: -10000
        positionalContinuity | pc: (create, edit, multiuse, query) - Toggle on (off) G0 continuity at edge corresponding to multi index. Default: true
        stepCount | sc: (create, edit, multiuse, query) - Step count for the number of discretizations. Default: 20
        tangentialContinuity | tc: (create, edit, multiuse, query) - Toggle on (off) G1 continuity across edge corresponding to multi index. Default: false
        togglePointNormals | tpn: (create, edit, query) - Toggle on (off) normal point constraints on the surface. Default: false
        togglePointPosition | tpp: (create, edit, query) - Toggle on (off) position point constraints on the surface. Default: true
        toggleTolerance | tt: (create, edit, multiuse, query) - Toggle on (off) so as to use Tolerance or specified steps for discretization. Default: false
        tolerance | tol: (create, edit, multiuse, query) - Tolerance to use while discretizing the edge. Default: 0.1
        cascade | c: (create) - Cascade the created stitch node. (Only if the surface has a stitch history) Default is 'false'.
        constructionHistory | ch: (create) - Turn the construction history on or off.
        equalWeight | ewt: (create) - Assign equal weights to all the points being stitched together. Default is 'true'. If false, the first point is assigned a weight of 1.0 and the rest are assigned 0.0.
        keepG0Continuity | kg0: (create) - Stitch together the points with positional continuity. Default is 'true'.
        keepG1Continuity | kg1: (create) - Stitch together the points with tangent continuity. Default is 'false'.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
    """
    ...


def subdAutoProjection(*args, caching: bool = ..., cch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., layout: Optional[Union[int, bool]] = ..., l: Optional[Union[int, bool]] = ..., layoutMethod: Optional[Union[int, bool]] = ..., lm: Optional[Union[int, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., optimize: Optional[Union[int, bool]] = ..., o: Optional[Union[int, bool]] = ..., percentageSpace: Optional[Union[float, bool]] = ..., ps: Optional[Union[float, bool]] = ..., planes: Optional[Union[int, bool]] = ..., p: Optional[Union[int, bool]] = ..., scale: Optional[Union[int, bool]] = ..., sc: Optional[Union[int, bool]] = ..., skipIntersect: bool = ..., si: bool = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Projects a texture map onto an object, using several orthogonal projections
    simultaneously.
    
    The argument is a face selection list.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        constructionHistory | ch: (create) - Turn the construction history on or off.
        layout | l: (create, edit, query) - What layout algorithm should be used: 0 UV pieces are aligned along the U axis. 1 UV pieces are moved in a square shape.
        layoutMethod | lm: (create, edit, query) - Which layout method to use: 0 Block Stacking. 1 Shape Stacking.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        optimize | o: (create, edit, query) - Use two different flavors for the cut generation. 0 Every face is assigned to the best plane. This optimizes the map distortion. 1 Small UV pieces are incorporated into larger ones, when the extra distortion introduced is reasonable. This tends to produce fewer UV pieces.
        percentageSpace | ps: (create, edit, query) - When layout is set to square, this value is a percentage of the texture area which is added around each UV piece. It can be used to ensure each UV piece uses different pixels in the texture. Maximum value is 5 percent.
        planes | p: (create, edit, query) - Number of intermediate projections used. Valid numbers are 4, 5, 6, 8, and 12. C: Default is 6.
        scale | sc: (create, edit, query) - How to scale the pieces, after projections: 0 No scale is applied. 1 Uniform scale to fit in unit square. 2 Non proportional scale to fit in unit square.
        skipIntersect | si: (create, edit, query) - When on, self intersection of UV pieces are not tested. This makes the projection faster and produces fewer pieces, but may lead to overlaps in UV space.
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is "off".
    """
    ...


def subdCleanTopology(*args) -> Any:
    r"""
    Command cleans topology of subdiv surfaces - at all levels. It cleans the
    geometry of vertices that satisfy the following conditions:
                    - Zero edits
                    - Default uvs (uvs obtained by subdividing parent face).
                    - No creases.

    Args:
    """
    ...


def subdCollapse(*args, caching: bool = ..., cch: bool = ..., level: Optional[Union[int, bool]] = ..., l: Optional[Union[int, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command converts a takes a subdivision surface, passed as the
    argument, and produces
    a subdivision surface with a number of hierarchy levels "removed".
    Returns the name of the subdivision surface created and optionally
    the DG node that does the conversion.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        level | l: (create, edit, query) - The level that will now become the base mesh. Default: 0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
    """
    ...


def subdDuplicateAndConnect(*args) -> Any:
    r"""
    This command duplicates the input subdivision surface object, connects
    up the outSubdiv attribute of the original subd shape to
    the create attribute of the newly created duplicate shape and
    copies over the shader assignments from the original shape
    to the new duplicated shape.
    
    The command will fail if no objects are selected or sent as
    argument or if the object sent as argument is not a subdivision surface
    object.

    Args:
    """
    ...


def subdEditUV(*args, angle: Optional[Union[float, bool]] = ..., a: Optional[Union[float, bool]] = ..., pivotU: Optional[Union[float, bool]] = ..., pu: Optional[Union[float, bool]] = ..., pivotV: Optional[Union[float, bool]] = ..., pv: Optional[Union[float, bool]] = ..., relative: bool = ..., r: bool = ..., rotateRatio: Optional[Union[float, bool]] = ..., rr: Optional[Union[float, bool]] = ..., rotation: bool = ..., rot: bool = ..., scale: bool = ..., s: bool = ..., scaleU: Optional[Union[float, bool]] = ..., su: Optional[Union[float, bool]] = ..., scaleV: Optional[Union[float, bool]] = ..., sv: Optional[Union[float, bool]] = ..., uValue: Optional[Union[float, bool]] = ..., u: Optional[Union[float, bool]] = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ..., vValue: Optional[Union[float, bool]] = ..., v: Optional[Union[float, bool]] = ..., query: bool = ...) -> Any:
    r"""
    Command edits uvs on subdivision surfaces. When used with the query flag, it
    returns the uv values associated with the specified components.

    Args:
        angle | a: (create, query) - Specifies the angle value (in degrees) that the uv values are to be rotated by.
        pivotU | pu: (create, query) - Specifies the pivot value, in the u direction, about which the scale or rotate is to be performed.
        pivotV | pv: (create, query) - Specifies the pivot value, in the v direction, about which the scale or rotate is to be performed.
        relative | r: (create, query) - Specifies whether this command is editing the values relative to the currently existing values. Default is true;
        rotateRatio | rr: (create, query) - Specifies the ratio value that the uv values are to be rotated by Default is 1.0
        rotation | rot: (create, query) - Specifies whether this command is editing the values with rotation values
        scale | s: (create, query) - Specifies whether this command is editing the values with scale values
        scaleU | su: (create, query) - Specifies the scale value in the u direction.
        scaleV | sv: (create, query) - Specifies the scale value in the v direction.
        uValue | u: (create, query) - Specifies the value, in the u direction - absolute if relative flag is false..
        uvSetName | uvs: (create, query) - Specifies the name of the uv set to edit uvs on. If not specified will use the current uv set if it exists.
        vValue | v: (create, query) - Specifies the value, in the v direction - absolute if relative flag is false..
    """
    ...


def subdiv(*args, currentLevel: bool = ..., cl: bool = ..., currentSubdLevel: bool = ..., csl: bool = ..., deepestLevel: Optional[Union[int, bool]] = ..., dl: Optional[Union[int, bool]] = ..., displayLoad: bool = ..., dsl: bool = ..., edgeStats: bool = ..., est: bool = ..., faceStats: bool = ..., fst: bool = ..., maxPossibleLevel: Optional[Union[int, bool]] = ..., mpl: Optional[Union[int, bool]] = ..., proxyMode: Optional[Union[int, bool]] = ..., pm: Optional[Union[int, bool]] = ..., smallOffsets: bool = ..., so: bool = ..., query: bool = ...) -> Any:
    r"""
    Provides useful information about the selected subdiv or components, such
    as the deepest subdivided level, the children or parents of the currently
    selected components, etc.

    Args:
        currentLevel | cl: (create, query) - When queried, this flag returns an integer representing the level of the currently selected subdiv surface component(s). Returns -1, if there are more than one level of CVs are selected, (even if they are from different objects) Returns -2, if there are no input subdiv CVs to process.
        currentSubdLevel | csl: (create, query) - When queried, this flag returns an integer representing the level of the currently selected subdiv surface, regardless of whether components are selected or not. Returns -2, if there are no input subdiv CVs to process.
        deepestLevel | dl: (create, query) - When queried, this flag returns an integer representing the deepest level to which the queried subdiv surface has been subdivided.
        displayLoad | dsl: (create, query) - When queried, this flag prints the display load of selected subdiv
        edgeStats | est: (create, query) - When queried, this flag prints stats on the current subd.
        faceStats | fst: (create, query) - When queried, this flag prints stats on the current subd.
        maxPossibleLevel | mpl: (create, query) - When queried, this flag returns an integer representing the maximum possible level to which the queried subdiv surface can been subdivided.
        proxyMode | pm: (create, query) - When queried, this flag returns an integer representing whether or not the subdivision surface is in "polygon proxy" mode. "Proxy" mode allows the base mesh of a subdivision surface without construction history to be edited using the polygonal editing tools. Returns 1, if the subdivision surface is in "polygon proxy" mode. Returns 0, if the surface is not currently in "proxy" mode, but could be put into "proxy" mode since it has no construction history.  (This state is also known as "standard" mode.) Returns 2, if the surface is not in "proxy" mode and cannot be put into proxy mode, as it has construction history.
        smallOffsets | so: (create, query) - When queried, this flag prints the number of subdiv vertices in the hierarchy that have a small enough offset so that the vertex is not required
    """
    ...


def subdivCrease(*args, sharpness: bool = ..., sh: bool = ...) -> Any:
    r"""
    Set the creasing on subdivision mesh edges or mesh points that are on
    the selection list.

    Args:
        sharpness | sh: (create) - Specifies the sharpness value to set the crease to
    """
    ...


def subdivDisplaySmoothness(*args, all: bool = ..., smoothness: Optional[Union[int, bool]] = ..., s: Optional[Union[int, bool]] = ..., query: bool = ...) -> Any:
    r"""
    Sets or querys the display smoothness of subdivision surfaces on the selection list or of all subdivision surfaces if the -all option is set.  Smoothness options are; rough, medium, or fine.  Rough is the default.

    Args:
        all: (create, query) - If set, change smoothness for all subdivision surfaces
        smoothness | s: (create, query) - Smoothness - 1 rough, 2 medium, 3 fine
    """
    ...


def subdLayoutUV(*args, caching: bool = ..., cch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., flipReversed: bool = ..., fr: bool = ..., layout: Optional[Union[int, bool]] = ..., l: Optional[Union[int, bool]] = ..., layoutMethod: Optional[Union[int, bool]] = ..., lm: Optional[Union[int, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., percentageSpace: Optional[Union[float, bool]] = ..., ps: Optional[Union[float, bool]] = ..., rotateForBestFit: Optional[Union[int, bool]] = ..., rbf: Optional[Union[int, bool]] = ..., scale: Optional[Union[int, bool]] = ..., sc: Optional[Union[int, bool]] = ..., separate: Optional[Union[int, bool]] = ..., se: Optional[Union[int, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Move UVs in the texture plane to avoid overlaps.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        constructionHistory | ch: (create) - Turn the construction history on or off.
        flipReversed | fr: (create, edit, query) - If this flag is turned on, the reversed UV pieces are fliped.
        layout | l: (create, edit, query) - How to move the UV pieces, after cuts are applied: 0 No move is applied. 1 Layout the pieces along the U axis. 2 Layout the pieces in a square shape.
        layoutMethod | lm: (create, edit, query) - Which layout method to use: 0 Block Stacking. 1 Shape Stacking.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        percentageSpace | ps: (create, edit, query) - When layout is set to square, this value is a percentage of the texture area which is added around each UV piece. It can be used to ensure each UV piece uses different pixels in the texture. Maximum value is 5 percent.
        rotateForBestFit | rbf: (create, edit, query) - 0 No rotation is applied. 1 Only allow 90 degree rotations. 2 Allow free rotations.
        scale | sc: (create, edit, query) - How to scale the pieces, after move and cuts: 0 No scale is applied. 1 Uniform scale to fit in unit square. 2 Non proportional scale to fit in unit square.
        separate | se: (create, edit, query) - Which UV edges should be cut: 0 No cuts. 1 Cut only along folds. 2 Make all necessary cuts to avoid all intersections.
        worldSpace | ws: (create, edit, query) - If true, performs the operation in world space coordinates as opposed to local space.
    """
    ...


def subdListComponentConversion(*args, border: bool = ..., bo: bool = ..., fromEdge: bool = ..., fe: bool = ..., fromFace: bool = ..., ff: bool = ..., fromUV: bool = ..., fuv: bool = ..., fromVertex: bool = ..., fv: bool = ..., internal: bool = ..., toEdge: bool = ..., te: bool = ..., toFace: bool = ..., tf: bool = ..., toUV: bool = ..., tuv: bool = ..., toVertex: bool = ..., tv: bool = ..., uvShell: bool = ..., uvs: bool = ..., uvShellBorder: bool = ..., uvb: bool = ...) -> Any:
    r"""
    This command converts subdivision surface components from one or
    more types to another one or more types, and returns the list of the
    conversion. It does not change the currently selected objects.
    
    Use the "-in/internal" flag to specify conversion to
    "connected" vs. "contained" components.  For example,
    if the internal flag is specified when converting
    from subdivision surface vertices to faces, then
    only faces that are entirely contained by the vertices
    will be returned.  If the internal flag is not specified,
    then all faces that are connected to the vertices will
    be returned.

    Args:
        border | bo: (create) - Convert to a border.
        fromEdge | fe: (create) - Indicates the component type to convert from: Edges
        fromFace | ff: (create) - Indicates the component type to convert from: Faces
        fromUV | fuv: (create) - Indicates the component type to convert from: UVs
        fromVertex | fv: (create) - Indicates the component type to convert from: Vertex
        internal | internal: (create) - Applicable when converting from "smaller" component types to larger ones. Specifies conversion to "connected" vs. "contained" components. See examples below.
        toEdge | te: (create) - Indicates the component type to convert to: Edges
        toFace | tf: (create) - Indicates the component type to convert to: Faces
        toUV | tuv: (create) - Indicates the component type to convert to: UVs
        toVertex | tv: (create) - Indicates the component type to convert to: Vertices
        uvShell | uvs: (create) - Will return UV components within the same UV shell. Only works with -tuv and -fuv flags.
        uvShellBorder | uvb: (create) - Will return UV components on the border within the same UV shell. Only works with -tuv and -fuv flags.
    """
    ...


def subdMapCut(*args, caching: bool = ..., cch: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Cut along edges of the texture mapping. The cut edges become map borders.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
    """
    ...


def subdMapSewMove(*args, caching: bool = ..., cch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., limitPieceSize: bool = ..., lps: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., numberFaces: Optional[Union[int, bool]] = ..., nf: Optional[Union[int, bool]] = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command can be used to Move and Sew together separate UV pieces
    along geometric edges. UV pieces that correspond to the same geometric
    edge, are merged together by moving the smaller piece to the larger
    one.
    
    The argument is a UV selection list.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        constructionHistory | ch: (create) - Turn the construction history on or off.
        limitPieceSize | lps: (create, edit, query) - When on, this flag specifies that the face number limit described above should be used.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        numberFaces | nf: (create, edit, query) - Maximum number of faces in a UV piece. When trying to combine two UV pieces into a single one, the merge operation is rejected if the smaller piece has more faces than the number specified by this flag. This flag is only used when limitPieceSize is set to on.
        worldSpace | ws: (create, edit, query) - If true, performs the operation in world space coordinates as opposed to local space.
    """
    ...


def subdMatchTopology(*args, frontOfChain: bool = ..., foc: bool = ...) -> Any:
    r"""
    Command matches topology across multiple subdiv surfaces - at all levels.

    Args:
        frontOfChain | foc: (create) - This command is used to specify that the new addTopology node should be placed ahead (upstream) of existing deformer and skin nodes in the shape's history (but not ahead of existing tweak nodes). The input to the addTopology node will be the upstream shape rather than the visible downstream shape, so the behavior of this flag is the most intuitive if the downstream deformers are in their reset (hasNoEffect) position when the new deformer is added.
    """
    ...


def subdMirror(*args, caching: bool = ..., cch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., xMirror: bool = ..., xm: bool = ..., yMirror: bool = ..., ym: bool = ..., zMirror: bool = ..., zm: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command takes a subdivision surface, passed as the argument, and produces
    a subdivision surface that is a mirror.
    Returns the name of the subdivision surface created and optionally
    the DG node that does the mirroring.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        xMirror | xm: (create, edit, query) - Mirror the vertices in X Default: false
        yMirror | ym: (create, edit, query) - Mirror the vertices in Y Default: false
        zMirror | zm: (create, edit, query) - Mirror the vertices in Z Default: false
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
    """
    ...


def subdPlanarProjection(*args, caching: bool = ..., cch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., createNewMap: bool = ..., cm: bool = ..., imageCenter: Optional[Union[Tuple[float, float], bool]] = ..., ic2: Optional[Union[Tuple[float, float], bool]] = ..., imageCenterX: Optional[Union[float, bool]] = ..., icx: Optional[Union[float, bool]] = ..., imageCenterY: Optional[Union[float, bool]] = ..., icy: Optional[Union[float, bool]] = ..., imageScale: Optional[Union[Tuple[float, float], bool]] = ..., is2: Optional[Union[Tuple[float, float], bool]] = ..., imageScaleU: Optional[Union[float, bool]] = ..., isu: Optional[Union[float, bool]] = ..., imageScaleV: Optional[Union[float, bool]] = ..., isv: Optional[Union[float, bool]] = ..., insertBeforeDeformers: bool = ..., ibd: bool = ..., keepImageRatio: bool = ..., kir: bool = ..., mapDirection: Optional[Union[str, bool]] = ..., md: Optional[Union[str, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., projectionCenter: Optional[Union[Tuple[float, float, float], bool]] = ..., pc: Optional[Union[Tuple[float, float, float], bool]] = ..., projectionCenterX: Optional[Union[float, bool]] = ..., pcx: Optional[Union[float, bool]] = ..., projectionCenterY: Optional[Union[float, bool]] = ..., pcy: Optional[Union[float, bool]] = ..., projectionCenterZ: Optional[Union[float, bool]] = ..., pcz: Optional[Union[float, bool]] = ..., projectionHeight: Optional[Union[float, bool]] = ..., ph: Optional[Union[float, bool]] = ..., projectionScale: Optional[Union[Tuple[float, float], bool]] = ..., ps: Optional[Union[Tuple[float, float], bool]] = ..., projectionWidth: Optional[Union[float, bool]] = ..., pw: Optional[Union[float, bool]] = ..., rotate: Optional[Union[Tuple[float, float, float], bool]] = ..., ro: Optional[Union[Tuple[float, float, float], bool]] = ..., rotateX: Optional[Union[float, bool]] = ..., rx: Optional[Union[float, bool]] = ..., rotateY: Optional[Union[float, bool]] = ..., ry: Optional[Union[float, bool]] = ..., rotateZ: Optional[Union[float, bool]] = ..., rz: Optional[Union[float, bool]] = ..., rotationAngle: Optional[Union[float, bool]] = ..., ra: Optional[Union[float, bool]] = ..., smartFit: bool = ..., sf: bool = ..., worldSpace: bool = ..., ws: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    TsubProjCmdBase is a base class for the command to create a mapping on the selected subdivision faces.
    Projects a map onto an object, using an orthogonal projection. The
    piece of the map defined from isu, isv, icx, icy area, is placed at
    pcx, pcy, pcz location.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        constructionHistory | ch: (create) - Turn the construction history on or off.
        createNewMap | cm: (create, edit, query) - This flag when set true will create a new map with a the name passed in, if the map does not already exist.
        imageCenter | ic2: (create, edit, query) - This flag specifies the center point of the 2D model layout. C: Default is 0.5 0.5. Q: When queried, this flag returns a float[2].
        imageCenterX | icx: (create, edit, query) - This flag specifies X for the center point of the 2D model layout. C: Default is 0.5. Q: When queried, this flag returns a float.
        imageCenterY | icy: (create, edit, query) - This flag specifies Y for the center point of the 2D model layout. C: Default is 0.5. Q: When queried, this flag returns a float.
        imageScale | is2: (create, edit, query) - This flag specifies the UV scale : Enlarges or reduces the 2D version of the model in U or V space relative to the 2D centerpoint. C: Default is 1.0 1.0. Q: When queried, this flag returns a float[2].
        imageScaleU | isu: (create, edit, query) - This flag specifies the U scale : Enlarges or reduces the 2D version of the model in U space relative to the 2D centerpoint. C: Default is 1.0. Q: When queried, this flag returns a float.
        imageScaleV | isv: (create, edit, query) - This flag specifies the V scale : Enlarges or reduces the 2D version of the model in V space relative to the 2D centerpoint. C: Default is 1.0. Q: When queried, this flag returns a float.
        insertBeforeDeformers | ibd: (create) - This flag specifies if the projection node should be inserted before or after deformer nodes already applied to the shape. Inserting the projection after the deformer leads to texture swimming during animation and is most often undesirable. C: Default is on.
        keepImageRatio | kir: (create) - True means keep any image ratio
        mapDirection | md: (create) - This flag specifies the mapping direction. 'x', 'y' and 'z' projects the map along the corresponding axis. 'c' projects along the current camera viewing direction. 'p' does perspective projection if current camera is perspective. 'b' projects along the best plane fitting the objects selected.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        projectionCenter | pc: (create, edit, query) - This flag specifies the origin point from which the map is projected. C: Default is 0.0 0.0 0.0. Q: When queried, this flag returns a float[3].
        projectionCenterX | pcx: (create, edit, query) - This flag specifies X for the origin point from which the map is projected. C: Default is 0.0. Q: When queried, this flag returns a float.
        projectionCenterY | pcy: (create, edit, query) - This flag specifies Y for the origin point from which the map is projected. C: Default is 0.0. Q: When queried, this flag returns a float.
        projectionCenterZ | pcz: (create, edit, query) - This flag specifies Z for the origin point from which the map is projected. C: Default is 0.0. Q: When queried, this flag returns a float.
        projectionHeight | ph: (create, edit, query) - This flag specifies the height of the map relative to the 3D projection axis. C: Default is 1.0 Q: When queried, this flag returns a float.
        projectionScale | ps: (create, edit, query) - This flag specifies the width and the height of the map relative to the 3D projection axis. C: Default is 1.0 1.0. Q: When queried, this flag returns a float[2].
        projectionWidth | pw: (create, edit, query) - This flag specifies the width of the map relative to the 3D projection axis. C: Default is 1.0 Q: When queried, this flag returns a float.
        rotate | ro: (create, edit, query) - This flag specifies the mapping rotate angles. C: Default is 0.0 0.0 0.0. Q: When queried, this flag returns a float[3].
        rotateX | rx: (create, edit, query) - This flag specifies X mapping rotate angle. C: Default is 0.0. Q: When queried, this flag returns a float[3].
        rotateY | ry: (create, edit, query) - This flag specifies Y mapping rotate angle. C: Default is 0.0. Q: When queried, this flag returns a float.
        rotateZ | rz: (create, edit, query) - This flag specifies Z mapping rotate angle. C: Default is 0.0. Q: When queried, this flag returns a float.
        rotationAngle | ra: (create, edit, query) - This flag specifies the rotation angle in the mapping space. When the angle is positive, then the map rotates counterclockwise on the mapped model, whereas when it is negative then the map rotates lockwise on the mapped model. C: Default is 10.0. Q: When queried, this flag returns a float.
        smartFit | sf: (create) - True means use the smart fit algorithm
        worldSpace | ws: (create, edit, query) - This flag specifies which reference to use. If "on" : all geometrical values are taken in world reference. If "off" : all geometrical values are taken in object reference. C: Default is "off". Q: When queried, this flag returns an int.
    """
    ...


def subdToBlind(*args, absolutePosition: bool = ..., ap: bool = ..., includeCreases: bool = ..., ic: bool = ..., includeZeroOffsets: bool = ..., izo: bool = ...) -> Any:
    r"""
    The subdivision surface hierarchical edits will get copied into blind
    data on the given polygon.  The polygon face count and topology
    must match the subdivision surface base mesh face count and topology.
    If they don't, the blind data will still appear, but is not guaranteed
    to produce the same result when converted back to a subdivision surface.
    
    The command takes a single subdivision surface and a single polygonal
    object.  Additional subdivision surfaces or polygonal objects will be
    ignored.

    Args:
        absolutePosition | ap: (create) - If set to true, the hierarchical edits are represented as the point positions, not the point offsets.  Most of the time, this is not desirable, but if you're just going to be merging/deleting a bunch of things and not move any vertices, then you could set it to true.  False is the default and saves the offsets.
        includeCreases | ic: (create) - If set, the creases get transfered as well.  With it false, the subdivision surface created from the blind data + polygon will have lost all the craese information.  The default is false.
        includeZeroOffsets | izo: (create) - If set, the zero offset will get included in the blind data.  This will greatly increase the size of the blind data, but will also let you keep all created vertices in the conversion back to polys.  This flag does not change the behaviour for the vertices up to and including level 2 as they're always created.  If not set, only the edited vertices will be included in the blind data.  This will still maintain the shape of your object faithfully.  The default is false.
    """
    ...


def subdToPoly(*args, applyMatrixToResult: bool = ..., amr: bool = ..., caching: bool = ..., cch: bool = ..., copyUVTopology: bool = ..., cut: bool = ..., depth: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., extractPointPosition: bool = ..., epp: bool = ..., format: Optional[Union[int, bool]] = ..., f: Optional[Union[int, bool]] = ..., inSubdCVId: Optional[Union[Tuple[int, int], bool]] = ..., inSubdCVIdLeft: Optional[Union[int, bool]] = ..., isl: Optional[Union[int, bool]] = ..., inSubdCVIdRight: Optional[Union[int, bool]] = ..., isr: Optional[Union[int, bool]] = ..., maxPolys: Optional[Union[int, bool]] = ..., mp: Optional[Union[int, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., outSubdCVId: Optional[Union[Tuple[int, int], bool]] = ..., os: Optional[Union[Tuple[int, int], bool]] = ..., outSubdCVIdLeft: Optional[Union[int, bool]] = ..., osl: Optional[Union[int, bool]] = ..., outSubdCVIdRight: Optional[Union[int, bool]] = ..., osr: Optional[Union[int, bool]] = ..., outv: Optional[Union[int, bool]] = ..., ov: Optional[Union[int, bool]] = ..., preserveVertexOrdering: bool = ..., pvo: bool = ..., sampleCount: Optional[Union[int, bool]] = ..., sc: Optional[Union[int, bool]] = ..., shareUVs: bool = ..., suv: bool = ..., subdNormals: bool = ..., un: bool = ..., addUnderTransform: bool = ..., aut: bool = ..., connectShaders: bool = ..., cs: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command tessellates a subdivision surface and produces polygon.
    The name of the new polygon is returned.
    If construction history is ON, then the name of the new dependency
    node is returned as well.

    Args:
        applyMatrixToResult | amr: (create, edit, query) - If true, the matrix on the input geometry is applied to the object and the resulting geometry will have identity matrix on it.  If false the conversion is done on the local space object and the resulting geometry has the input object's matrix on it. Default: true
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        copyUVTopology | cut: (create, edit, query) - Copy over uv topology (shared/unshared) from the original subdivision surface to the converted polygonal mesh. Default: false
        depth | d: (create, edit, query) - The depth at which constant-depth tessellates the surface Default: 0
        extractPointPosition | epp: (create, edit, query) - Determines how the position of a mesh point is calculated If on the position of the mesh point is returned. If off the position of the point of the surface is returned. Default: false
        format | f: (create, edit, query) - Format:  0 - Uniform 1 - Adaptive 2 - Polygon Count 3 - Vertices  Default: 0
        inSubdCVId | inSubdCVId: (create, edit, multiuse, query) - Input CV Id
        inSubdCVIdLeft | isl: (create, edit, query) - Higher 32 bit integer of the input CV Id
        inSubdCVIdRight | isr: (create, edit, query) - Lower 32 bit integer of the input CV Id
        maxPolys | mp: (create, edit, query) - The maximum number of polygons at which by polygons tessellates. If this attribute is greater than zero, it will override the sample count and depth attributes. Default: 0
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        outSubdCVId | os: (create, edit, multiuse, query) - Output CV Id
        outSubdCVIdLeft | osl: (create, edit, query) - Higher 32 bit integer of the output CV Id
        outSubdCVIdRight | osr: (create, edit, query) - Lower 32 bit integer of the output CV Id
        outv | ov: (create, edit, multiuse, query) - Out Vertices corresponding to the inSubDCVs.
        preserveVertexOrdering | pvo: (create, edit, query) - Preserve vertex ordering in conversion Default: true
        sampleCount | sc: (create, edit, query) - The number of samples per face Default: 1
        shareUVs | suv: (create, edit, query) - Force sharing of uvs on all common vertices - the value of this attribute gets overridden by the value of the copyUVTopology attribute. Default: false
        subdNormals | un: (create, edit, query) - Keep subdiv surface normals Default: false
        addUnderTransform | aut: (create, query) - If true then add the result underneath a transform node
        connectShaders | cs: (create) - If true, all shader assignment will be copied from the original subdiv surface to the converted polygonal surface. Default: true
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
    """
    ...


def subdTransferUVsToCache(*args) -> Any:
    r"""
    The subdivision surface finer level uvs will get copied to the polygonToSubd
    node sent in as argument.
    
    The command takes a single subdivision surface and a single polygonToSubd
    node as input. Additional inputs will be ignored.
    Please note that this command is an internal command and is to be used
    with care, directly by the user

    Args:
    """
    ...


def surface(*args, degreeU: Optional[Union[int, bool]] = ..., du: Optional[Union[int, bool]] = ..., degreeV: Optional[Union[int, bool]] = ..., dv: Optional[Union[int, bool]] = ..., formU: Optional[Union[str, bool]] = ..., fu: Optional[Union[str, bool]] = ..., formV: Optional[Union[str, bool]] = ..., fv: Optional[Union[str, bool]] = ..., knotU: Optional[Union[float, bool]] = ..., ku: Optional[Union[float, bool]] = ..., knotV: Optional[Union[float, bool]] = ..., kv: Optional[Union[float, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., objectSpace: bool = ..., ob: bool = ..., point: Optional[Union[Tuple[float, float, float], bool]] = ..., p: Optional[Union[Tuple[float, float, float], bool]] = ..., pointWeight: Optional[Union[Tuple[float, float, float, float], bool]] = ..., pw: Optional[Union[Tuple[float, float, float, float], bool]] = ..., worldSpace: bool = ..., ws: bool = ...) -> Any:
    r"""
    The cmd creates a NURBS spline surface (rational or non rational).
    The surface is created by specifying control vertices (CV's) and
    knot sequences in the U and V direction.  You cannot query
    the properties of the surface using this command.  See examples
    below.

    Args:
        degreeU | du: (create) - Degree in surface U direction.  Default is degree 3.
        degreeV | dv: (create) - Degree in surface V direction.  Default is degree 3.
        formU | fu: (create) - The string for open is "open" , for closed is "closed"  or for periodic is "periodic" in U.
        formV | fv: (create) - The string for open is "open" , for closed is "closed"  or for periodic is "periodic" in V.
        knotU | ku: (create, multiuse) - Knot value(s) in U direction.  One flag per knot value. There must be (numberOfPointsInU + degreeInU - 1) knots and the knot vector must be non-decreasing.
        knotV | kv: (create, multiuse) - Knot value(s) in V direction.  One flag per knot value. There must be (numberOfPointsInV + degreeInV - 1) knots and the knot vector must be non-decreasing.
        name | n: (create) - Name to use for new transforms.
        objectSpace | ob: (create) - Should the operation happen in objectSpace?
        point | p: (create, multiuse) - To specify non rational CV with (x, y, z) values.  "linear" means that this flag can take values with units.  Note that you must specify (degree+1) surface points in any direction to create a visible surface span.  eg.  if the surface is degree 3 in the U direction, you must specify 4 CVs in the U direction. Points are specified in rows of U and columns of V.  If you want to incorporate units, add the unit name to the value, eg. "-p 3.3in 5.5ft 6.6yd"
        pointWeight | pw: (create, multiuse) - To specify rational CV with (x, y, z, w) values.  "linear" means that this flag can take values with units.  Note that you must specify (degree+1) surface points in any direction to create a visible surface span.  eg.  if the surface is degree 3 in the U direction, you must specify 4 CVs in the U direction. Points are specified in rows of U and columns of V.
        worldSpace | ws: (create) - Should the operation happen in worldSpace?
    """
    ...


def textCurves(*args, font: Optional[Union[str, bool]] = ..., f: Optional[Union[str, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., text: Optional[Union[str, bool]] = ..., t: Optional[Union[str, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The textCurves command creates NURBS curves from a text string
    using the specified font.
    
    A single letter can be made up of more than one NURBS curve.
    The number of curves per letter varies with the font.

    Args:
        font | f: (create) - The font to use.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        text | t: (create) - The string to create the curves for.
    """
    ...


def tolerance(*args, angular: Optional[Union[float, bool]] = ..., a: Optional[Union[float, bool]] = ..., linear: Optional[Union[float, bool]] = ..., l: Optional[Union[float, bool]] = ..., query: bool = ...) -> Any:
    r"""
    This command sets tolerances used by modelling operations
    that require a tolerance, such as surface fillet.
    Linear tolerance is also known as "positional" tolerance.
    Angular tolerance is also known as "tangential" tolerance.

    Args:
        angular | a: (create, query) - Sets the angular, or "tangential" tolerance.
        linear | l: (create, query) - Sets the linear, or "positonal" tolerance.
    """
    ...


def torus(*args, axis: Optional[Union[Tuple[float, float, float], bool]] = ..., ax: Optional[Union[Tuple[float, float, float], bool]] = ..., caching: bool = ..., cch: bool = ..., degree: Optional[Union[int, bool]] = ..., d: Optional[Union[int, bool]] = ..., endSweep: Optional[Union[float, bool]] = ..., esw: Optional[Union[float, bool]] = ..., heightRatio: Optional[Union[float, bool]] = ..., hr: Optional[Union[float, bool]] = ..., minorSweep: Optional[Union[float, bool]] = ..., msw: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., pivot: Optional[Union[Tuple[float, float, float], bool]] = ..., p: Optional[Union[Tuple[float, float, float], bool]] = ..., radius: Optional[Union[float, bool]] = ..., r: Optional[Union[float, bool]] = ..., sections: Optional[Union[int, bool]] = ..., s: Optional[Union[int, bool]] = ..., spans: Optional[Union[int, bool]] = ..., nsp: Optional[Union[int, bool]] = ..., startSweep: Optional[Union[float, bool]] = ..., ssw: Optional[Union[float, bool]] = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., useTolerance: bool = ..., ut: bool = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., polygon: Optional[Union[int, bool]] = ..., po: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    The torus command creates a new torus and/or a
    dependency node that creates one, and returns their names.

    Args:
        axis | ax: (create, edit, query) - The primitive's axis
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        degree | d: (create, edit, query) - The degree of the resulting surface: 1 - linear, 3 - cubic Default: 3
        endSweep | esw: (create, edit, query) - The angle at which to end the surface of revolution. Default is 2Pi radians, or 360 degrees. Default: 6.2831853
        heightRatio | hr: (create, edit, query) - Ratio of "height" to "width" Default: 2.0
        minorSweep | msw: (create, edit, query) - The sweep angle for the minor circle in the torus Default: 6.2831853
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        pivot | p: (create, edit, query) - The primitive's pivot point
        radius | r: (create, edit, query) - The radius of the object Default: 1.0
        sections | s: (create, edit, query) - The number of sections determines the resolution of the surface in the sweep direction. Used only if useTolerance is false. Default: 8
        spans | nsp: (create, edit, query) - The number of spans determines the resolution of the surface in the opposite direction. Default: 1
        startSweep | ssw: (create, edit, query) - The angle at which to start the surface of revolution Default: 0
        tolerance | tol: (create, edit, query) - The tolerance with which to build the surface. Used only if useTolerance is true Default: 0.01
        useTolerance | ut: (create, edit, query) - Use the specified tolerance to determine resolution. Otherwise number of sections will be used. Default: false
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
        polygon | po: (create) - The value of this argument controls the type of the object created by this operation   0: nurbs surface  1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)  2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)  3: Bezier surface  4: subdivision surface solid (use nurbsToSubdivPref to set the parameters for the conversion)
    """
    ...


def transferAttributes(*args, after: bool = ..., af: bool = ..., afterReference: bool = ..., ar: bool = ..., before: bool = ..., bf: bool = ..., colorBorders: Optional[Union[int, bool]] = ..., clb: Optional[Union[int, bool]] = ..., components: bool = ..., cmp: bool = ..., deformerTools: bool = ..., dt: bool = ..., exclusive: Optional[Union[str, bool]] = ..., ex: Optional[Union[str, bool]] = ..., flipUVs: Optional[Union[int, bool]] = ..., fuv: Optional[Union[int, bool]] = ..., frontOfChain: bool = ..., foc: bool = ..., geometry: Optional[Union[str, bool]] = ..., g: Optional[Union[str, bool]] = ..., geometryIndices: bool = ..., gi: bool = ..., ignoreSelected: bool = ..., includeHiddenSelections: bool = ..., ihs: bool = ..., matchChoice: Optional[Union[int, bool]] = ..., mch: Optional[Union[int, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., parallel: bool = ..., par: bool = ..., prune: bool = ..., pr: bool = ..., remove: bool = ..., rm: bool = ..., sampleSpace: Optional[Union[int, bool]] = ..., spa: Optional[Union[int, bool]] = ..., searchMethod: Optional[Union[int, bool]] = ..., sm: Optional[Union[int, bool]] = ..., searchScaleX: Optional[Union[float, bool]] = ..., ssx: Optional[Union[float, bool]] = ..., searchScaleY: Optional[Union[float, bool]] = ..., ssy: Optional[Union[float, bool]] = ..., searchScaleZ: Optional[Union[float, bool]] = ..., ssz: Optional[Union[float, bool]] = ..., selectedComponents: bool = ..., cms: bool = ..., sourceColorSet: Optional[Union[str, bool]] = ..., scs: Optional[Union[str, bool]] = ..., sourceUvSet: Optional[Union[str, bool]] = ..., suv: Optional[Union[str, bool]] = ..., sourceUvSpace: Optional[Union[str, bool]] = ..., sus: Optional[Union[str, bool]] = ..., split: bool = ..., sp: bool = ..., targetColorSet: Optional[Union[str, bool]] = ..., tcs: Optional[Union[str, bool]] = ..., targetUvSet: Optional[Union[str, bool]] = ..., tuv: Optional[Union[str, bool]] = ..., targetUvSpace: Optional[Union[str, bool]] = ..., tus: Optional[Union[str, bool]] = ..., transferColors: Optional[Union[int, bool]] = ..., col: Optional[Union[int, bool]] = ..., transferNormals: Optional[Union[int, bool]] = ..., nml: Optional[Union[int, bool]] = ..., transferPositions: Optional[Union[int, bool]] = ..., pos: Optional[Union[int, bool]] = ..., transferUVs: Optional[Union[int, bool]] = ..., uvs: Optional[Union[int, bool]] = ..., useComponentTags: bool = ..., uct: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Samples the attributes of a source surface (first argument) and
    transfers them onto a target surface (second argument).

    Args:
        after | af: (create, edit) - If the default behavior for insertion/appending into/onto the existing chain is not the desired behavior then this flag can be used to force the command to place the deformer node after the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet).
        afterReference | ar: (create, edit) - The -afterReference flag is used to specify deformer ordering in a hybrid way that choses between -before and -after automatically. If the geometry being deformed is referenced then the -after mode is used when adding the new deformer, otherwise the -before mode is used. The net effect when using -afterReference to build deformer chains is that internal shape nodes in the deformer chain will only appear at reference file boundaries, leading to lightweight deformer networks that may be more amicable to reference swapping.
        before | bf: (create, edit) - If the default behavior for insertion/appending into/onto the existing chain is not the desired behavior then this flag can be used to force the command to place the deformer node before the selected node in the chain even if a new geometry shape has to be created in order to do so. Works in create mode (and edit mode if the deformer has no geometry added yet).
        colorBorders | clb: (create, edit) - Controls whether color borders are preserved when transferring color data. If this is non-zero, any color borders will be mapped onto the nearest edge on the target geometry. 0 means any color borders will be smoothly blended onto the vertices of the target geometry.
        components | cmp: (query) - Returns the components used by the deformer
        deformerTools | dt: (query) - Returns the name of the deformer tool objects (if any) as string string ...
        exclusive | ex: (create, query) - Puts the deformation set in a deform partition.
        flipUVs | fuv: (create, edit) - Controls how sampled UV data is flipped before being transferred to the target. 0 means no flipping; 1 means UV data is flipped in the U direction; 2 means UV data is flipped in the V direction; and 3 means it is flipped in both directions. In conjunction with mirroring, this allows the creation of symmetric UV mappings (e.g. the left hand side of the character on one side of the UV map, the right hand side on the other).
        frontOfChain | foc: (create, edit) - This command is used to specify that the new deformer node should be placed ahead (upstream) of existing deformer and skin nodes in the shape's history (but not ahead of existing tweak nodes). The input to the deformer will be the upstream shape rather than the visible downstream shape, so the behavior of this flag is the most intuitive if the downstream deformers are in their reset (hasNoEffect) position when the new deformer is added. Works in create mode (and edit mode if the deformer has no geometry added yet).
        geometry | g: (edit, multiuse, query) - The specified object will be added to the list of objects being deformed by this deformer object, unless the -rm flag is also specified. When queried, this flag returns string string string ...
        geometryIndices | gi: (query) - Complements the -geometry flag in query mode. Returns the multi index of each geometry.
        ignoreSelected | ignoreSelected: (create) - Tells the command to not deform objects on the current selection list
        includeHiddenSelections | ihs: (create) - Apply the deformer to any visible and hidden objects in the selection list. Default is false.
        matchChoice | mch: (create, edit) - When using topological component matching, selects between possible matches. If the meshes involved in the transfer operation have symmetries in their topologies, there may be more than one possible topological match. Maya scores the possible matches (by comparing the shapes of the meshes) and assigns them an index, starting at zero. Match zero, the default, is considered the best, but in the event that Maya chooses the wrong one, changing this value will allow the user to explore the other matches.
        name | n: (create) - Used to specify the name of the node being created.
        parallel | par: (create, edit) - Inserts the new deformer in a parallel chain to any existing deformers in the history of the object. A blendShape is inserted to blend the parallel results together. Works in create mode (and edit mode if the deformer has no geometry added yet).
        prune | pr: (edit) - Removes any points not being deformed by the deformer in its current configuration from the deformer set.
        remove | rm: (edit, multiuse) - Specifies that objects listed after the -g flag should be removed from this deformer.
        sampleSpace | spa: (create, edit) - Selects which space the attribute transfer is performed in. 0 is world space, 1 is model space, 4 is component-based, 5 is topology-based. The default is world space.
        searchMethod | sm: (create, edit) - Specifies which search method to use when correlating points. 0 is closest along normal, 3 is closest to point. The default is closest to point.
        searchScaleX | ssx: (create, edit) - Specifies an optional scale that should be applied to the x-axis of the target model before transferring data. A value of 1.0 (the default) means no scaling; a value of -1.0 would indicate mirroring along the x-axis.
        searchScaleY | ssy: (create, edit) - Specifies an optional scale that should be applied to the y-axis of the target model before transferring data. A value of 1.0 (the default) means no scaling; a value of -1.0 would indicate mirroring along the y-axis.
        searchScaleZ | ssz: (create, edit) - Specifies an optional scale that should be applied to the z-axis of the target model before transferring data. A value of 1.0 (the default) means no scaling; a value of -1.0 would indicate mirroring along the z-axis.
        selectedComponents | cms: (query) - Returns the components used by the deformer that are currently selected. This intersects the current selection with the components affected by the deformer.
        sourceColorSet | scs: (create) - Specifies the name of a single color set on the source surface(s) that should be transferred to the target. This value is only used when the operation is configured to transfer a single color set (see the transferColors flag).
        sourceUvSet | suv: (create) - Specifies the name of a single UV set on the source surface(s) that should be transferred to the target. This value is only used when the operation is configured to transfer a single UV set (see the transferUVs flag).
        sourceUvSpace | sus: (create) - Specifies the name of the UV set on the source surface(s) that should be used as the transfer space. This value is only used when the operation is configured to transfer attributes in UV space.
        split | sp: (create, edit) - Branches off a new chain in the dependency graph instead of inserting/appending the deformer into/onto an existing chain. Works in create mode (and edit mode if the deformer has no geometry added yet).
        targetColorSet | tcs: (create) - Specifies the name of a single color set on the target surface that should be receive the sampled color data. This value is only used when the operation is configured to transfer a single color set (see the transferColors flag).
        targetUvSet | tuv: (create) - Specifies the name of a single UV set on the target surface that should be receive the sampled UV data. This value is only used when the operation is configured to transfer a single UV set (see the transferUVs flag).
        targetUvSpace | tus: (create) - Specifies the name of the UV set on the target surface( that should be used as the transfer space. This value is only used when the operation is configured to transfer attributes in UV space.
        transferColors | col: (create, edit) - Controls color set transfer. 0 means no color sets are transferred, 1 means that a single color set (specified by sourceColorSet and targetColorSet) is transferred, and 2 means that all color sets are transferred.
        transferNormals | nml: (create, edit) - A non-zero value indicates vertex normals should be sampled and written into user normals on the target surface.
        transferPositions | pos: (create, edit) - A non-zero value indicates vertex position should be sampled, causing the target surface to "wrap" to the source surface(s).
        transferUVs | uvs: (create, edit) - Controls UV set transfer. 0 means no UV sets are transferred, 1 means that a single UV set (specified by sourceUVSet and targetUVSet) is transferred, and 2 means that all UV sets are transferred.
        useComponentTags | uct: (create) - When this flag is specified a setup using componentTags will be created. This means no groupId, groupParts, tweak or objectSet nodes will be created and connected to the new deformer.
    """
    ...


def transferShadingSets(*args, sampleSpace: Optional[Union[int, bool]] = ..., spa: Optional[Union[int, bool]] = ..., searchMethod: Optional[Union[int, bool]] = ..., sm: Optional[Union[int, bool]] = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Command to transfer shading set assignments between meshes.
    The last mesh in the list receives the shading assignments from the other meshes.

    Args:
        sampleSpace | spa: (create, edit, query) - Selects which space the attribute transfer is performed in. 0 is world space, 1 is model space. The default is world space.
        searchMethod | sm: (create, edit, query) - Specifies which search method to use when correlating points. 0 is closest along normal, 3 is closest to point. The default is closest to point.
    """
    ...


def trim(*args, caching: bool = ..., cch: bool = ..., locatorU: Optional[Union[float, bool]] = ..., lu: Optional[Union[float, bool]] = ..., locatorV: Optional[Union[float, bool]] = ..., lv: Optional[Union[float, bool]] = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., selected: Optional[Union[int, bool]] = ..., sl: Optional[Union[int, bool]] = ..., shrink: bool = ..., sh: bool = ..., tolerance: Optional[Union[float, bool]] = ..., tol: Optional[Union[float, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., object: bool = ..., o: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    This command trims a surface to its curves on surface by first
    splitting the surface and then selecting which regions to keep
    or discard.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        locatorU | lu: (create, edit, multiuse, query) - u parameter value to position a locator on the surface. Default: 0.5
        locatorV | lv: (create, edit, multiuse, query) - v parameter value to position a locator on the surface. Default: 0.5
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        selected | sl: (create, edit, query) - Specify whether to keep or discard selected regions. Default: 0
        shrink | sh: (create, edit, query) - If true, shrink underlying surface to outer boundaries of trimmed surface. Default: false
        tolerance | tol: (create, edit, query) - The tolerance with which to trim. Default: 0.001
        constructionHistory | ch: (create) - Turn the construction history on or off.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        object | o: (create) - Create the result, or just the dependency node.
    """
    ...


def unfold(*args, applyToShell: bool = ..., areaWeight: Optional[Union[float, bool]] = ..., aw: Optional[Union[float, bool]] = ..., globalBlend: Optional[Union[float, bool]] = ..., gb: Optional[Union[float, bool]] = ..., globalMethodBlend: Optional[Union[float, bool]] = ..., gmb: Optional[Union[float, bool]] = ..., iterations: Optional[Union[int, bool]] = ..., i: Optional[Union[int, bool]] = ..., optimizeAxis: Optional[Union[int, bool]] = ..., oa: Optional[Union[int, bool]] = ..., pinSelected: bool = ..., ps: bool = ..., pinUvBorder: bool = ..., pub: bool = ..., scale: Optional[Union[float, bool]] = ..., s: Optional[Union[float, bool]] = ..., stoppingThreshold: Optional[Union[float, bool]] = ..., ss: Optional[Union[float, bool]] = ..., useScale: bool = ..., us: bool = ...) -> Any:
    r"""
    None

    Args:
        applyToShell | applyToShell: (create) - Specifies that the selected components should be only work on shells that have something have been selected or pinned.
        areaWeight | aw: (create) - Surface driven importance. 0 treat all faces equal. 1 gives more importance to large ones.
        globalBlend | gb: (create) - This allows the user to blend between a local optimization method (globalBlend = 0.0) and a global optimization method (globalBlend = 1.0). The local optimization method looks at the ratio between the triangles on the object and the triangles in UV space.  It has a side affect that it can sometimes introduce tapering problems.  The global optimization is much slower, but takes into consideration the entire object when optimizing uv placement.
        globalMethodBlend | gmb: (create) - The global optimization method uses two functions to compute a minimization.  The first function controls edge stretch by using edges lengths between xyz and uv.  The second function penalizes the first function by preventing configurations where triangles would overlap.  For every surface there is a mix between these two functions that will give the appropriate response. Values closer to 1.0 give more weight to the edge length function. Values closer to 0.0 give more weight to surface area.  The default value of '0.5' is a even mix between these two values.
        iterations | i: (create) - Maximum number of iterations for each connected UV piece.
        optimizeAxis | oa: (create) - Degree of freedom for optimization 0=Optimize freely, 1=Move vertically only, 2=Move horzontally only
        pinSelected | ps: (create) - Specifies that the selected components should be pinned instead the unselected components.
        pinUvBorder | pub: (create) - Specifies that the UV border should be pinned when doing the solve. By default only unselected components are pinned.
        scale | s: (create) - Ratio between 2d and 3d space.
        stoppingThreshold | ss: (create) - Minimum distorsion improvement between two steps in %.
        useScale | us: (create) - Adjust the scale or not.
    """
    ...


def untangleUV(*args, mapBorder: Optional[Union[str, bool]] = ..., mb: Optional[Union[str, bool]] = ..., maxRelaxIterations: Optional[Union[int, bool]] = ..., mri: Optional[Union[int, bool]] = ..., pinBorder: bool = ..., pb: bool = ..., pinSelected: bool = ..., ps: bool = ..., pinUnselected: bool = ..., pu: bool = ..., relax: Optional[Union[str, bool]] = ..., r: Optional[Union[str, bool]] = ..., relaxTolerance: Optional[Union[float, bool]] = ..., rt: Optional[Union[float, bool]] = ..., shapeDetail: Optional[Union[float, bool]] = ..., sd: Optional[Union[float, bool]] = ...) -> Any:
    r"""
    This command will aid in the creation of non-overlapping regions (i.e. polygons)
    in texture space by untangling texture UVs. This is done in two stages:
    1) Use this command to map the UV border determined by the current selection
    or passed component into a shape that is more suitable for subsequent relaxation.
    2) Relax all the internal texture UVs by performing a length minimization
    algorithm on all edges in texture space.

    Args:
        mapBorder | mb: (create) - Map the border containing the selected UV into a variety of shapes that may be more amenable to UV relaxation operations. There are various types of mapping available. All the resulting mappings are fit inside the unit square.  Valid values for the STRING are: circular - a circular mapping with picked UV closest to (0,0) square - map to unit square with picked UV at (0,0) shape - a mapping which attempts to reflect the actual shape of the object         where the picked UV is placed on the line from (0,0) -> (0.5,0.5) shape_circular - shape mapping which will interpolate to a circular mapping                  just enough to prevent self-intersections of the mapped border  shape_square - shape mapping which will interpolate to a square mapping just                enough to prevent self-intersections of the mapped border
        maxRelaxIterations | mri: (create) - The relaxation process is an iterative algorithm. Using this flag will put an upper limit on the number of iterations that will be performed.
        pinBorder | pb: (create) - If this is true, then the relevant texture borders are pinned in place during any relaxation
        pinSelected | ps: (create) - If this is true, then then any selected UVs are pinned in place during any relaxation
        pinUnselected | pu: (create) - If this is true, then all unselected UVs in each mesh are pinned in place during any relaxation
        relax | r: (create) - Relax all UVs in the shell of the selected UV's. The relaxation is done by simulating a spring system where each UV edge is treated as a spring. There are a number of different methods characterized by the way the UV edges are weighted in the spring system. These weightings are determined by STRING. Valid values for STRING are: uniform - every edge is weighted the same. This is the fastest method. inverse_length - every edge weight is inversely proportional to it's world space length. inverse_sqrt_length - every edge weight is inversely proportional the the square root of it's world space length. harmonic - this weighting can yield near optimal results in matching the UV's with the geometry, but can also take a long time.
        relaxTolerance | rt: (create) - This sets the tolerance which is used to determine when the relaxation process can stop. Smaller tolerances yield better results but can take much longer.
        shapeDetail | sd: (create) - If the mapBorder flag is set to circular or square, then this flag will control how much of the border's corresponding surface shape should be retained in the final mapped border.
    """
    ...


def untrim(*args, caching: bool = ..., cch: bool = ..., nodeState: Optional[Union[int, bool]] = ..., nds: Optional[Union[int, bool]] = ..., constructionHistory: bool = ..., ch: bool = ..., curveOnSurface: bool = ..., cos: bool = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., noChanges: bool = ..., nc: bool = ..., object: bool = ..., o: bool = ..., replaceOriginal: bool = ..., rpo: bool = ..., untrimAll: bool = ..., all: bool = ..., edit: bool = ..., query: bool = ...) -> Any:
    r"""
    Untrim the surface.

    Args:
        caching | cch: (create, edit, query) - Toggle caching for all attributes so that no recomputation is needed
        nodeState | nds: (create, edit, query) - Maya dependency nodes have 6 possible states. The Normal (0), HasNoEffect (1), and Blocking (2) states can be used to alter how the graph is evaluated.    The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5) are for internal use only. They temporarily shut off parts of the graph during interaction (e.g., manipulation). The understanding is that once the operation is done, the state will be reset appropriately, e.g. Waiting-Blocking will reset back to Blocking.    The Normal and Blocking cases apply to all nodes, while HasNoEffect is node specific; many nodes do not support this option. Plug-ins store state in the MPxNode::state attribute. Anyone can set it or check this attribute.  Additional details about each of these 3 states follow.     State Description   Normal The normal node state. This is the default.   HasNoEffect   The HasNoEffect option (a.k.a. pass-through), is used in cases where there is an operation on an input producing an output of the same data type. Nearly all deformers support this state, as do a few other nodes. As stated earlier, it is not supported by all nodes.   It’s typical to implement support for the HasNoEffect state in the node’s compute method and to perform appropriate operations. Plug-ins can also support HasNoEffect.   The usual implementation of this state is to copy the input directly to the matching output without applying the algorithm in the node. For deformers, applying this state leaves the input geometry undeformed on the output.     Blocking   This is implemented in the depend node base class and applies to all nodes. Blocking is applied during the evaluation phase to connections. An evaluation request to a blocked connection will return as failures, causing the destination plug to retain its current value. Dirty propagation is indirectly affected by this state since blocked connections are never cleaned.   When a node is set to Blocking the behavior is supposed to be the same as if all outgoing connections were broken. As long as nobody requests evaluation of the blocked node directly it won’t evaluate after that. Note that a blocked node will still respond to getAttr requests but a getAttr on a downstream node will not reevaluate the blocked node.   Setting the root transform of a hierarchy to Blocking won’t automatically influence child transforms in the hierarchy. To do this, you’d need to explicitly set all child nodes to the Blocking state.   For example, to set all child transforms to Blocking, you could use the following script.    import maya.cmds as cmds def blockTree(root): nodesToBlock = [] for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys(): nodesToBlock += cmds.listConnections(node, source=True, destination=True ) for node in {source:1 for source in nodesToBlock}.keys(): cmds.setAttr( '%s.nodeState' % node, 2 )    Applying this script would continue to draw objects but things would not be animated.     Default: kdnNormal
        constructionHistory | ch: (create) - Turn the construction history on or off.
        curveOnSurface | cos: (create) - If possible, create 2D curve as a result.
        name | n: (create) - Sets the name of the newly-created node. If it contains namespace path, the new node will be created under the specified namespace; if the namespace does not exist, it will be created.
        noChanges | nc: (create, edit, query) - If set then the operation node will be automatically put into pass-through mode.
        object | o: (create) - Create the result, or just the dependency node.
        replaceOriginal | rpo: (create) - Create "in place" (i.e., replace).
        untrimAll | all: (edit, query) - if true, untrim all the trims for the surface else untrim only the last trim
    """
    ...


def uvSnapshot(*args, antiAliased: bool = ..., aa: bool = ..., blueColor: Optional[Union[int, bool]] = ..., b: Optional[Union[int, bool]] = ..., entireUVRange: bool = ..., euv: bool = ..., fileFormat: Optional[Union[str, bool]] = ..., ff: Optional[Union[str, bool]] = ..., greenColor: Optional[Union[int, bool]] = ..., g: Optional[Union[int, bool]] = ..., name: Optional[Union[str, bool]] = ..., n: Optional[Union[str, bool]] = ..., overwrite: bool = ..., o: bool = ..., redColor: Optional[Union[int, bool]] = ..., r: Optional[Union[int, bool]] = ..., uMax: Optional[Union[float, bool]] = ..., umx: Optional[Union[float, bool]] = ..., uMin: Optional[Union[float, bool]] = ..., umn: Optional[Union[float, bool]] = ..., uvSetName: Optional[Union[str, bool]] = ..., uvs: Optional[Union[str, bool]] = ..., vMax: Optional[Union[float, bool]] = ..., vmx: Optional[Union[float, bool]] = ..., vMin: Optional[Union[float, bool]] = ..., vmn: Optional[Union[float, bool]] = ..., xResolution: Optional[Union[int, bool]] = ..., xr: Optional[Union[int, bool]] = ..., yResolution: Optional[Union[int, bool]] = ..., yr: Optional[Union[int, bool]] = ...) -> Any:
    r"""
    Builds an image containg the UVs of the selected objects.

    Args:
        antiAliased | aa: (create) - When this flag is set, lines are antialiased.
        blueColor | b: (create) - Blue component of line drawing. Default is 255.
        entireUVRange | euv: (create) - When this flag is set, the generated image will contain the entire uv range. Default is UV in 0-1 range.
        fileFormat | ff: (create) - Output file format. Any of those keyword:                                 "iff", "sgi", "pic", "tif", "als", "gif", "rla", "jpg"         Default is iff.
        greenColor | g: (create) - Green component of line drawing. Default is 255.
        name | n: (create) - Name of the file to be created.
        overwrite | o: (create) - When this flag is set, existing file can be ovewritten.
        redColor | r: (create) - Red component of line drawing. Default is 255.
        uMax | umx: (create) - Optional User Specified Max value for U. Default value is 1. This will take precedence over the "entire range" -euv flag.
        uMin | umn: (create) - Optional User Specified Min value for U. Default value is 0. This will take precedence over the "entire range" -euv flag.
        uvSetName | uvs: (create) - Name of the uv set to use. Default is the current one.
        vMax | vmx: (create) - Optional User Specified Max value for V. Default value is 1. This will take precedence over the "entire range" -euv flag.
        vMin | vmn: (create) - Optional User Specified Min value for V. Default value is 0. This will take precedence over the "entire range" -euv flag.
        xResolution | xr: (create) - Horizontal size of the image. Default is 512.
        yResolution | yr: (create) - Vertical size of the image. Default is 512.
    """
    ...


